"format global";
/* */ 
"format global";
(function (global) {
  var babelHelpers = global.babelHelpers = {};

  babelHelpers.inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  babelHelpers.defaults = function (obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);

      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }

    return obj;
  };

  babelHelpers.createClass = (function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();

  babelHelpers.createDecoratedClass = (function () {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor || descriptor.initializer) descriptor.writable = true;

        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];

            if (typeof decorator === "function") {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
            }
          }

          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }

        Object.defineProperty(target, key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps) defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();

  babelHelpers.createDecoratedObject = function (descriptors) {
    var target = {};

    for (var i = 0; i < descriptors.length; i++) {
      var descriptor = descriptors[i];
      var decorators = descriptor.decorators;
      var key = descriptor.key;
      delete descriptor.key;
      delete descriptor.decorators;
      descriptor.enumerable = true;
      descriptor.configurable = true;
      if ("value" in descriptor || descriptor.initializer) descriptor.writable = true;

      if (decorators) {
        for (var f = 0; f < decorators.length; f++) {
          var decorator = decorators[f];

          if (typeof decorator === "function") {
            descriptor = decorator(target, key, descriptor) || descriptor;
          } else {
            throw new TypeError("The decorator for method " + descriptor.key + " is of the invalid type " + typeof decorator);
          }
        }
      }

      if (descriptor.initializer) {
        descriptor.value = descriptor.initializer.call(target);
      }

      Object.defineProperty(target, key, descriptor);
    }

    return target;
  };

  babelHelpers.defineDecoratedPropertyDescriptor = function (target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor) return;
    var descriptor = {};

    for (var _key in _descriptor) descriptor[_key] = _descriptor[_key];

    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  };

  babelHelpers.taggedTemplateLiteral = function (strings, raw) {
    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  };

  babelHelpers.taggedTemplateLiteralLoose = function (strings, raw) {
    strings.raw = raw;
    return strings;
  };

  babelHelpers.toArray = function (arr) {
    return Array.isArray(arr) ? arr : Array.from(arr);
  };

  babelHelpers.toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  babelHelpers.slicedToArray = (function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();

  babelHelpers.slicedToArrayLoose = function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      var _arr = [];

      for (var _iterator = arr[Symbol.iterator](), _step; !(_step = _iterator.next()).done;) {
        _arr.push(_step.value);

        if (i && _arr.length === i) break;
      }

      return _arr;
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };

  babelHelpers.objectWithoutProperties = function (obj, keys) {
    var target = {};

    for (var i in obj) {
      if (keys.indexOf(i) >= 0) continue;
      if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
      target[i] = obj[i];
    }

    return target;
  };

  babelHelpers.hasOwn = Object.prototype.hasOwnProperty;
  babelHelpers.slice = Array.prototype.slice;
  babelHelpers.bind = Function.prototype.bind;

  babelHelpers.defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  babelHelpers.asyncToGenerator = function (fn) {
    return function () {
      var gen = fn.apply(this, arguments);
      return new Promise(function (resolve, reject) {
        var callNext = step.bind(null, "next");
        var callThrow = step.bind(null, "throw");

        function step(key, arg) {
          try {
            var info = gen[key](arg);
            var value = info.value;
          } catch (error) {
            reject(error);
            return;
          }

          if (info.done) {
            resolve(value);
          } else {
            Promise.resolve(value).then(callNext, callThrow);
          }
        }

        callNext();
      });
    };
  };

  babelHelpers.interopExportWildcard = function (obj, defaults) {
    var newObj = defaults({}, obj);
    delete newObj["default"];
    return newObj;
  };

  babelHelpers.interopRequireWildcard = function (obj) {
    if (obj && obj.__esModule) {
      return obj;
    } else {
      var newObj = {};

      if (obj != null) {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
        }
      }

      newObj["default"] = obj;
      return newObj;
    }
  };

  babelHelpers.interopRequireDefault = function (obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  };

  babelHelpers._typeof = function (obj) {
    return obj && obj.constructor === Symbol ? "symbol" : typeof obj;
  };

  babelHelpers._extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  babelHelpers.get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  babelHelpers.set = function set(object, property, value, receiver) {
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent !== null) {
        set(parent, property, value, receiver);
      }
    } else if ("value" in desc && desc.writable) {
      desc.value = value;
    } else {
      var setter = desc.set;

      if (setter !== undefined) {
        setter.call(receiver, value);
      }
    }

    return value;
  };

  babelHelpers.newArrowCheck = function (innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  };

  babelHelpers.classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  babelHelpers.objectDestructuringEmpty = function (obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  };

  babelHelpers.temporalUndefined = {};

  babelHelpers.temporalAssertDefined = function (val, name, undef) {
    if (val === undef) {
      throw new ReferenceError(name + " is not defined - temporal dead zone");
    }

    return true;
  };

  babelHelpers.selfGlobal = typeof global === "undefined" ? self : global;
  babelHelpers.typeofReactElement = typeof Symbol === "function" && Symbol["for"] && Symbol["for"]("react.element") || 60103;

  babelHelpers.defaultProps = function (defaultProps, props) {
    if (defaultProps) {
      for (var propName in defaultProps) {
        if (typeof props[propName] === "undefined") {
          props[propName] = defaultProps[propName];
        }
      }
    }

    return props;
  };

  babelHelpers._instanceof = function (left, right) {
    if (right != null && right[Symbol.hasInstance]) {
      return right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  };

  babelHelpers.interopRequire = function (obj) {
    return obj && obj.__esModule ? obj["default"] : obj;
  };
})(typeof global === "undefined" ? self : global);

(function(global) {

  var defined = {};

  // indexOf polyfill for IE8
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var getOwnPropertyDescriptor = true;
  try {
    Object.getOwnPropertyDescriptor({ a: 0 }, 'a');
  }
  catch(e) {
    getOwnPropertyDescriptor = false;
  }

  var defineProperty;
  (function () {
    try {
      if (!!Object.defineProperty({}, 'a', {}))
        defineProperty = Object.defineProperty;
    }
    catch (e) {
      defineProperty = function(obj, prop, opt) {
        try {
          obj[prop] = opt.value || opt.get.call(obj);
        }
        catch(e) {}
      }
    }
  })();

  function register(name, deps, declare) {
    if (arguments.length === 4)
      return registerDynamic.apply(this, arguments);
    doRegister(name, {
      declarative: true,
      deps: deps,
      declare: declare
    });
  }

  function registerDynamic(name, deps, executingRequire, execute) {
    doRegister(name, {
      declarative: false,
      deps: deps,
      executingRequire: executingRequire,
      execute: execute
    });
  }

  function doRegister(name, entry) {
    entry.name = name;

    // we never overwrite an existing define
    if (!(name in defined))
      defined[name] = entry;

    // we have to normalize dependencies
    // (assume dependencies are normalized for now)
    // entry.normalizedDeps = entry.deps.map(normalize);
    entry.normalizedDeps = entry.deps;
  }


  function buildGroups(entry, groups) {
    groups[entry.groupIndex] = groups[entry.groupIndex] || [];

    if (indexOf.call(groups[entry.groupIndex], entry) != -1)
      return;

    groups[entry.groupIndex].push(entry);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];

      // not in the registry means already linked / ES6
      if (!depEntry || depEntry.evaluated)
        continue;

      // now we know the entry is in our unlinked linkage group
      var depGroupIndex = entry.groupIndex + (depEntry.declarative != entry.declarative);

      // the group index of an entry is always the maximum
      if (depEntry.groupIndex === undefined || depEntry.groupIndex < depGroupIndex) {

        // if already in a group, remove from the old group
        if (depEntry.groupIndex !== undefined) {
          groups[depEntry.groupIndex].splice(indexOf.call(groups[depEntry.groupIndex], depEntry), 1);

          // if the old group is empty, then we have a mixed depndency cycle
          if (groups[depEntry.groupIndex].length == 0)
            throw new TypeError("Mixed dependency cycle detected");
        }

        depEntry.groupIndex = depGroupIndex;
      }

      buildGroups(depEntry, groups);
    }
  }

  function link(name) {
    var startEntry = defined[name];

    startEntry.groupIndex = 0;

    var groups = [];

    buildGroups(startEntry, groups);

    var curGroupDeclarative = !!startEntry.declarative == groups.length % 2;
    for (var i = groups.length - 1; i >= 0; i--) {
      var group = groups[i];
      for (var j = 0; j < group.length; j++) {
        var entry = group[j];

        // link each group
        if (curGroupDeclarative)
          linkDeclarativeModule(entry);
        else
          linkDynamicModule(entry);
      }
      curGroupDeclarative = !curGroupDeclarative; 
    }
  }

  // module binding records
  var moduleRecords = {};
  function getOrCreateModuleRecord(name) {
    return moduleRecords[name] || (moduleRecords[name] = {
      name: name,
      dependencies: [],
      exports: {}, // start from an empty module and extend
      importers: []
    })
  }

  function linkDeclarativeModule(entry) {
    // only link if already not already started linking (stops at circular)
    if (entry.module)
      return;

    var module = entry.module = getOrCreateModuleRecord(entry.name);
    var exports = entry.module.exports;

    var declaration = entry.declare.call(global, function(name, value) {
      module.locked = true;

      if (typeof name == 'object') {
        for (var p in name)
          exports[p] = name[p];
      }
      else {
        exports[name] = value;
      }

      for (var i = 0, l = module.importers.length; i < l; i++) {
        var importerModule = module.importers[i];
        if (!importerModule.locked) {
          for (var j = 0; j < importerModule.dependencies.length; ++j) {
            if (importerModule.dependencies[j] === module) {
              importerModule.setters[j](exports);
            }
          }
        }
      }

      module.locked = false;
      return value;
    });

    module.setters = declaration.setters;
    module.execute = declaration.execute;

    // now link all the module dependencies
    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      var depEntry = defined[depName];
      var depModule = moduleRecords[depName];

      // work out how to set depExports based on scenarios...
      var depExports;

      if (depModule) {
        depExports = depModule.exports;
      }
      else if (depEntry && !depEntry.declarative) {
        depExports = depEntry.esModule;
      }
      // in the module registry
      else if (!depEntry) {
        depExports = load(depName);
      }
      // we have an entry -> link
      else {
        linkDeclarativeModule(depEntry);
        depModule = depEntry.module;
        depExports = depModule.exports;
      }

      // only declarative modules have dynamic bindings
      if (depModule && depModule.importers) {
        depModule.importers.push(module);
        module.dependencies.push(depModule);
      }
      else
        module.dependencies.push(null);

      // run the setter for this dependency
      if (module.setters[i])
        module.setters[i](depExports);
    }
  }

  // An analog to loader.get covering execution of all three layers (real declarative, simulated declarative, simulated dynamic)
  function getModule(name) {
    var exports;
    var entry = defined[name];

    if (!entry) {
      exports = load(name);
      if (!exports)
        throw new Error("Unable to load dependency " + name + ".");
    }

    else {
      if (entry.declarative)
        ensureEvaluated(name, []);

      else if (!entry.evaluated)
        linkDynamicModule(entry);

      exports = entry.module.exports;
    }

    if ((!entry || entry.declarative) && exports && exports.__useDefault)
      return exports['default'];

    return exports;
  }

  function linkDynamicModule(entry) {
    if (entry.module)
      return;

    var exports = {};

    var module = entry.module = { exports: exports, id: entry.name };

    // AMD requires execute the tree first
    if (!entry.executingRequire) {
      for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
        var depName = entry.normalizedDeps[i];
        var depEntry = defined[depName];
        if (depEntry)
          linkDynamicModule(depEntry);
      }
    }

    // now execute
    entry.evaluated = true;
    var output = entry.execute.call(global, function(name) {
      for (var i = 0, l = entry.deps.length; i < l; i++) {
        if (entry.deps[i] != name)
          continue;
        return getModule(entry.normalizedDeps[i]);
      }
      throw new TypeError('Module ' + name + ' not declared as a dependency.');
    }, exports, module);

    if (output)
      module.exports = output;

    // create the esModule object, which allows ES6 named imports of dynamics
    exports = module.exports;
 
    if (exports && exports.__esModule) {
      entry.esModule = exports;
    }
    else {
      entry.esModule = {};
      
      // don't trigger getters/setters in environments that support them
      if (typeof exports == 'object' || typeof exports == 'function') {
        if (getOwnPropertyDescriptor) {
          var d;
          for (var p in exports)
            if (d = Object.getOwnPropertyDescriptor(exports, p))
              defineProperty(entry.esModule, p, d);
        }
        else {
          var hasOwnProperty = exports && exports.hasOwnProperty;
          for (var p in exports) {
            if (!hasOwnProperty || exports.hasOwnProperty(p))
              entry.esModule[p] = exports[p];
          }
         }
       }
      entry.esModule['default'] = exports;
      defineProperty(entry.esModule, '__useDefault', {
        value: true
      });
    }
  }

  /*
   * Given a module, and the list of modules for this current branch,
   *  ensure that each of the dependencies of this module is evaluated
   *  (unless one is a circular dependency already in the list of seen
   *  modules, in which case we execute it)
   *
   * Then we evaluate the module itself depth-first left to right 
   * execution to match ES6 modules
   */
  function ensureEvaluated(moduleName, seen) {
    var entry = defined[moduleName];

    // if already seen, that means it's an already-evaluated non circular dependency
    if (!entry || entry.evaluated || !entry.declarative)
      return;

    // this only applies to declarative modules which late-execute

    seen.push(moduleName);

    for (var i = 0, l = entry.normalizedDeps.length; i < l; i++) {
      var depName = entry.normalizedDeps[i];
      if (indexOf.call(seen, depName) == -1) {
        if (!defined[depName])
          load(depName);
        else
          ensureEvaluated(depName, seen);
      }
    }

    if (entry.evaluated)
      return;

    entry.evaluated = true;
    entry.module.execute.call(global);
  }

  // magical execution function
  var modules = {};
  function load(name) {
    if (modules[name])
      return modules[name];

    // node core modules
    if (name.substr(0, 6) == '@node/')
      return require(name.substr(6));

    var entry = defined[name];

    // first we check if this module has already been defined in the registry
    if (!entry)
      throw "Module " + name + " not present.";

    // recursively ensure that the module and all its 
    // dependencies are linked (with dependency group handling)
    link(name);

    // now handle dependency execution in correct order
    ensureEvaluated(name, []);

    // remove from the registry
    defined[name] = undefined;

    // exported modules get __esModule defined for interop
    if (entry.declarative)
      defineProperty(entry.module.exports, '__esModule', { value: true });

    // return the defined module object
    return modules[name] = entry.declarative ? entry.module.exports : entry.esModule;
  };

  return function(mains, depNames, declare) {
    return function(formatDetect) {
      formatDetect(function(deps) {
        var System = {
          _nodeRequire: typeof require != 'undefined' && require.resolve && typeof process != 'undefined' && require,
          register: register,
          registerDynamic: registerDynamic,
          get: load, 
          set: function(name, module) {
            modules[name] = module; 
          },
          newModule: function(module) {
            return module;
          }
        };
        System.set('@empty', {});

        // register external dependencies
        for (var i = 0; i < depNames.length; i++) (function(depName, dep) {
          if (dep && dep.__esModule)
            System.register(depName, [], function(_export) {
              return {
                setters: [],
                execute: function() {
                  for (var p in dep)
                    if (p != '__esModule' && !(typeof p == 'object' && p + '' == 'Module'))
                      _export(p, dep[p]);
                }
              };
            });
          else
            System.registerDynamic(depName, [], false, function() {
              return dep;
            });
        })(depNames[i], arguments[i]);

        // register modules in this bundle
        declare(System);

        // load mains
        var firstLoad = load(mains[0]);
        if (mains.length > 1)
          for (var i = 1; i < mains.length; i++)
            load(mains[i]);

        if (firstLoad.__useDefault)
          return firstLoad['default'];
        else
          return firstLoad;
      });
    };
  };

})(typeof self != 'undefined' ? self : global)
/* (['mainModule'], ['external-dep'], function($__System) {
  System.register(...);
})
(function(factory) {
  if (typeof define && define.amd)
    define(['external-dep'], factory);
  // etc UMD / module pattern
})*/

(['1', '2', '3', '4', '5', '6', '7'], [], function($__System) {

(function(__global) {
  var loader = $__System;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  function readMemberExpression(p, value) {
    var pParts = p.split('.');
    while (pParts.length)
      value = value[pParts.shift()];
    return value;
  }

  // bare minimum ignores for IE8
  var ignoredGlobalProps = ['_g', 'sessionStorage', 'localStorage', 'clipboardData', 'frames', 'external', 'mozAnimationStartTime', 'webkitStorageInfo', 'webkitIndexedDB'];

  var globalSnapshot;

  function forEachGlobal(callback) {
    if (Object.keys)
      Object.keys(__global).forEach(callback);
    else
      for (var g in __global) {
        if (!hasOwnProperty.call(__global, g))
          continue;
        callback(g);
      }
  }

  function forEachGlobalValue(callback) {
    forEachGlobal(function(globalName) {
      if (indexOf.call(ignoredGlobalProps, globalName) != -1)
        return;
      try {
        var value = __global[globalName];
      }
      catch (e) {
        ignoredGlobalProps.push(globalName);
      }
      callback(globalName, value);
    });
  }

  loader.set('@@global-helpers', loader.newModule({
    prepareGlobal: function(moduleName, exportName, globals) {
      // disable module detection
      var curDefine = __global.define;
       
      __global.define = undefined;
      __global.exports = undefined;
      if (__global.module && __global.module.exports)
        __global.module = undefined;

      // set globals
      var oldGlobals;
      if (globals) {
        oldGlobals = {};
        for (var g in globals) {
          oldGlobals[g] = globals[g];
          __global[g] = globals[g];
        }
      }

      // store a complete copy of the global object in order to detect changes
      if (!exportName) {
        globalSnapshot = {};

        forEachGlobalValue(function(name, value) {
          globalSnapshot[name] = value;
        });
      }

      // return function to retrieve global
      return function() {
        var globalValue;

        if (exportName) {
          globalValue = readMemberExpression(exportName, __global);
        }
        else {
          var singleGlobal;
          var multipleExports;
          var exports = {};

          forEachGlobalValue(function(name, value) {
            if (globalSnapshot[name] === value)
              return;
            if (typeof value == 'undefined')
              return;
            exports[name] = value;

            if (typeof singleGlobal != 'undefined') {
              if (!multipleExports && singleGlobal !== value)
                multipleExports = true;
            }
            else {
              singleGlobal = value;
            }
          });
          globalValue = multipleExports ? exports : singleGlobal;
        }

        // revert globals
        if (oldGlobals) {
          for (var g in oldGlobals)
            __global[g] = oldGlobals[g];
        }
        __global.define = curDefine;

        return globalValue;
      };
    }
  }));

})(typeof self != 'undefined' ? self : global);

(function(__global) {
  var loader = $__System;
  var indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++)
      if (this[i] === item)
        return i;
    return -1;
  }

  var commentRegEx = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg;
  var cjsRequirePre = "(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])";
  var cjsRequirePost = "\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)";
  var fnBracketRegEx = /\(([^\)]*)\)/;
  var wsRegEx = /^\s+|\s+$/g;
  
  var requireRegExs = {};

  function getCJSDeps(source, requireIndex) {

    // remove comments
    source = source.replace(commentRegEx, '');

    // determine the require alias
    var params = source.match(fnBracketRegEx);
    var requireAlias = (params[1].split(',')[requireIndex] || 'require').replace(wsRegEx, '');

    // find or generate the regex for this requireAlias
    var requireRegEx = requireRegExs[requireAlias] || (requireRegExs[requireAlias] = new RegExp(cjsRequirePre + requireAlias + cjsRequirePost, 'g'));

    requireRegEx.lastIndex = 0;

    var deps = [];

    var match;
    while (match = requireRegEx.exec(source))
      deps.push(match[2] || match[3]);

    return deps;
  }

  /*
    AMD-compatible require
    To copy RequireJS, set window.require = window.requirejs = loader.amdRequire
  */
  function require(names, callback, errback, referer) {
    // in amd, first arg can be a config object... we just ignore
    if (typeof names == 'object' && !(names instanceof Array))
      return require.apply(null, Array.prototype.splice.call(arguments, 1, arguments.length - 1));

    // amd require
    if (typeof names == 'string' && typeof callback == 'function')
      names = [names];
    if (names instanceof Array) {
      var dynamicRequires = [];
      for (var i = 0; i < names.length; i++)
        dynamicRequires.push(loader['import'](names[i], referer));
      Promise.all(dynamicRequires).then(function(modules) {
        if (callback)
          callback.apply(null, modules);
      }, errback);
    }

    // commonjs require
    else if (typeof names == 'string') {
      var module = loader.get(names);
      return module.__useDefault ? module['default'] : module;
    }

    else
      throw new TypeError('Invalid require');
  }

  function define(name, deps, factory) {
    if (typeof name != 'string') {
      factory = deps;
      deps = name;
      name = null;
    }
    if (!(deps instanceof Array)) {
      factory = deps;
      deps = ['require', 'exports', 'module'].splice(0, factory.length);
    }

    if (typeof factory != 'function')
      factory = (function(factory) {
        return function() { return factory; }
      })(factory);

    // in IE8, a trailing comma becomes a trailing undefined entry
    if (deps[deps.length - 1] === undefined)
      deps.pop();

    // remove system dependencies
    var requireIndex, exportsIndex, moduleIndex;
    
    if ((requireIndex = indexOf.call(deps, 'require')) != -1) {
      
      deps.splice(requireIndex, 1);

      // only trace cjs requires for non-named
      // named defines assume the trace has already been done
      if (!name)
        deps = deps.concat(getCJSDeps(factory.toString(), requireIndex));
    }

    if ((exportsIndex = indexOf.call(deps, 'exports')) != -1)
      deps.splice(exportsIndex, 1);
    
    if ((moduleIndex = indexOf.call(deps, 'module')) != -1)
      deps.splice(moduleIndex, 1);

    var define = {
      name: name,
      deps: deps,
      execute: function(req, exports, module) {

        var depValues = [];
        for (var i = 0; i < deps.length; i++)
          depValues.push(req(deps[i]));

        module.uri = module.id;

        module.config = function() {};

        // add back in system dependencies
        if (moduleIndex != -1)
          depValues.splice(moduleIndex, 0, module);
        
        if (exportsIndex != -1)
          depValues.splice(exportsIndex, 0, exports);
        
        if (requireIndex != -1) 
          depValues.splice(requireIndex, 0, function(names, callback, errback) {
            if (typeof names == 'string' && typeof callback != 'function')
              return req(names);
            return require.call(loader, names, callback, errback, module.id);
          });

        var output = factory.apply(exportsIndex == -1 ? __global : exports, depValues);

        if (typeof output == 'undefined' && module)
          output = module.exports;

        if (typeof output != 'undefined')
          return output;
      }
    };

    // anonymous define
    if (!name) {
      // already defined anonymously -> throw
      if (lastModule.anonDefine)
        throw new TypeError('Multiple defines for anonymous module');
      lastModule.anonDefine = define;
    }
    // named define
    else {
      // if we don't have any other defines,
      // then let this be an anonymous define
      // this is just to support single modules of the form:
      // define('jquery')
      // still loading anonymously
      // because it is done widely enough to be useful
      if (!lastModule.anonDefine && !lastModule.isBundle) {
        lastModule.anonDefine = define;
      }
      // otherwise its a bundle only
      else {
        // if there is an anonDefine already (we thought it could have had a single named define)
        // then we define it now
        // this is to avoid defining named defines when they are actually anonymous
        if (lastModule.anonDefine && lastModule.anonDefine.name)
          loader.registerDynamic(lastModule.anonDefine.name, lastModule.anonDefine.deps, false, lastModule.anonDefine.execute);

        lastModule.anonDefine = null;
      }

      // note this is now a bundle
      lastModule.isBundle = true;

      // define the module through the register registry
      loader.registerDynamic(name, define.deps, false, define.execute);
    }
  }
  define.amd = {};

  // adds define as a global (potentially just temporarily)
  function createDefine(loader) {
    lastModule.anonDefine = null;
    lastModule.isBundle = false;

    // ensure no NodeJS environment detection
    var oldModule = __global.module;
    var oldExports = __global.exports;
    var oldDefine = __global.define;

    __global.module = undefined;
    __global.exports = undefined;
    __global.define = define;

    return function() {
      __global.define = oldDefine;
      __global.module = oldModule;
      __global.exports = oldExports;
    };
  }

  var lastModule = {
    isBundle: false,
    anonDefine: null
  };

  loader.set('@@amd-helpers', loader.newModule({
    createDefine: createDefine,
    require: require,
    define: define,
    lastModule: lastModule
  }));
  loader.amdDefine = define;
  loader.amdRequire = require;
})(typeof self != 'undefined' ? self : global);

"bundle";
$__System.register("8", [], function() { return { setters: [], execute: function() {} } });

$__System.register("9", [], function() { return { setters: [], execute: function() {} } });

$__System.register("a", [], function() { return { setters: [], execute: function() {} } });

$__System.register('b', [], function (_export) {
  'use strict';

  var debug, ws_url;
  return {
    setters: [],
    execute: function () {
      debug = false;

      _export('debug', debug);

      ws_url = 'wss://a2z-scheduler-dev.herokuapp.com/v1/websocket';

      _export('ws_url', ws_url);
    }
  };
});
$__System.registerDynamic("c", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    if (!Array.prototype.lastIndex) {
      Object.defineProperty(Array.prototype, 'lastIndex', {get: function() {
          return this.length - 1;
        }});
    }
    if (!Array.prototype.last) {
      Array.prototype.last = function() {
        return this[this.lastIndex];
      };
    }
    if (!Array.prototype.set) {
      Array.prototype.set = function(item, bubble) {
        if (typeof(bubble) === 'undefined')
          bubble = false;
        var index = this.findIndex(function(i) {
          return i == item;
        });
        if (index == -1)
          this.push(item);
        else if (bubble)
          this.move(index, this.lastIndex);
      };
    }
    if (!Array.prototype.has) {
      Array.prototype.has = function(item) {
        return (this.indexOf(item) != -1);
      };
    }
    if (!Array.prototype.remove) {
      Array.prototype.remove = function(item) {
        var index = this.findIndex(function(i) {
          return i == item;
        });
        this.splice(index, 1);
      };
    }
    if (!Array.prototype.popIndex) {
      Array.prototype.popIndex = function(index) {
        return this.splice(index, 1);
      };
    }
    if (!Array.prototype.move) {
      Array.prototype.move = function(old_index, new_index) {
        this.splice(new_index, 0, this.splice(old_index, 1)[0]);
      };
    }
    if (!Array.prototype.empty) {
      Array.prototype.empty = function() {
        this.splice(0, this.length);
      };
    }
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("d", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("e", ["d"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('d');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("f", ["e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = $__System._nodeRequire ? process : req('e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("10", ["f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("11", ["10"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    function set(obj, key, val) {
      if (hasOwn(obj, key)) {
        obj[key] = val;
        return;
      }
      if (obj._isVue) {
        set(obj._data, key, val);
        return;
      }
      var ob = obj.__ob__;
      if (!ob) {
        obj[key] = val;
        return;
      }
      ob.convert(key, val);
      ob.dep.notify();
      if (ob.vms) {
        var i = ob.vms.length;
        while (i--) {
          var vm = ob.vms[i];
          vm._proxy(key);
          vm._digest();
        }
      }
      return val;
    }
    function del(obj, key) {
      if (!hasOwn(obj, key)) {
        return;
      }
      delete obj[key];
      var ob = obj.__ob__;
      if (!ob) {
        return;
      }
      ob.dep.notify();
      if (ob.vms) {
        var i = ob.vms.length;
        while (i--) {
          var vm = ob.vms[i];
          vm._unproxy(key);
          vm._digest();
        }
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function hasOwn(obj, key) {
      return hasOwnProperty.call(obj, key);
    }
    var literalValueRE = /^\s?(true|false|[\d\.]+|'[^']*'|"[^"]*")\s?$/;
    function isLiteral(exp) {
      return literalValueRE.test(exp);
    }
    function isReserved(str) {
      var c = (str + '').charCodeAt(0);
      return c === 0x24 || c === 0x5F;
    }
    function _toString(value) {
      return value == null ? '' : value.toString();
    }
    function toNumber(value) {
      if (typeof value !== 'string') {
        return value;
      } else {
        var parsed = Number(value);
        return isNaN(parsed) ? value : parsed;
      }
    }
    function toBoolean(value) {
      return value === 'true' ? true : value === 'false' ? false : value;
    }
    function stripQuotes(str) {
      var a = str.charCodeAt(0);
      var b = str.charCodeAt(str.length - 1);
      return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
    }
    var camelizeRE = /-(\w)/g;
    function camelize(str) {
      return str.replace(camelizeRE, toUpper);
    }
    function toUpper(_, c) {
      return c ? c.toUpperCase() : '';
    }
    var hyphenateRE = /([a-z\d])([A-Z])/g;
    function hyphenate(str) {
      return str.replace(hyphenateRE, '$1-$2').toLowerCase();
    }
    var classifyRE = /(?:^|[-_\/])(\w)/g;
    function classify(str) {
      return str.replace(classifyRE, toUpper);
    }
    function bind$1(fn, ctx) {
      return function(a) {
        var l = arguments.length;
        return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
      };
    }
    function toArray(list, start) {
      start = start || 0;
      var i = list.length - start;
      var ret = new Array(i);
      while (i--) {
        ret[i] = list[i + start];
      }
      return ret;
    }
    function extend(to, from) {
      var keys = Object.keys(from);
      var i = keys.length;
      while (i--) {
        to[keys[i]] = from[keys[i]];
      }
      return to;
    }
    function isObject(obj) {
      return obj !== null && typeof obj === 'object';
    }
    var toString = Object.prototype.toString;
    var OBJECT_STRING = '[object Object]';
    function isPlainObject(obj) {
      return toString.call(obj) === OBJECT_STRING;
    }
    var isArray = Array.isArray;
    function def(obj, key, val, enumerable) {
      Object.defineProperty(obj, key, {
        value: val,
        enumerable: !!enumerable,
        writable: true,
        configurable: true
      });
    }
    function _debounce(func, wait) {
      var timeout,
          args,
          context,
          timestamp,
          result;
      var later = function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          result = func.apply(context, args);
          if (!timeout)
            context = args = null;
        }
      };
      return function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        if (!timeout) {
          timeout = setTimeout(later, wait);
        }
        return result;
      };
    }
    function indexOf(arr, obj) {
      var i = arr.length;
      while (i--) {
        if (arr[i] === obj)
          return i;
      }
      return -1;
    }
    function cancellable(fn) {
      var cb = function cb() {
        if (!cb.cancelled) {
          return fn.apply(this, arguments);
        }
      };
      cb.cancel = function() {
        cb.cancelled = true;
      };
      return cb;
    }
    function looseEqual(a, b) {
      return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
    }
    var hasProto = ('__proto__' in {});
    var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
    var isIE9 = inBrowser && navigator.userAgent.toLowerCase().indexOf('msie 9.0') > 0;
    var isAndroid = inBrowser && navigator.userAgent.toLowerCase().indexOf('android') > 0;
    var transitionProp = undefined;
    var transitionEndEvent = undefined;
    var animationProp = undefined;
    var animationEndEvent = undefined;
    if (inBrowser && !isIE9) {
      var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
      var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
      transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
      transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
      animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
      animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
    }
    var nextTick = (function() {
      var callbacks = [];
      var pending = false;
      var timerFunc;
      function nextTickHandler() {
        pending = false;
        var copies = callbacks.slice(0);
        callbacks = [];
        for (var i = 0; i < copies.length; i++) {
          copies[i]();
        }
      }
      if (typeof MutationObserver !== 'undefined') {
        var counter = 1;
        var observer = new MutationObserver(nextTickHandler);
        var textNode = document.createTextNode(counter);
        observer.observe(textNode, {characterData: true});
        timerFunc = function() {
          counter = (counter + 1) % 2;
          textNode.data = counter;
        };
      } else {
        timerFunc = setTimeout;
      }
      return function(cb, ctx) {
        var func = ctx ? function() {
          cb.call(ctx);
        } : cb;
        callbacks.push(func);
        if (pending)
          return;
        pending = true;
        timerFunc(nextTickHandler, 0);
      };
    })();
    function Cache(limit) {
      this.size = 0;
      this.limit = limit;
      this.head = this.tail = undefined;
      this._keymap = Object.create(null);
    }
    var p = Cache.prototype;
    p.put = function(key, value) {
      var entry = {
        key: key,
        value: value
      };
      this._keymap[key] = entry;
      if (this.tail) {
        this.tail.newer = entry;
        entry.older = this.tail;
      } else {
        this.head = entry;
      }
      this.tail = entry;
      if (this.size === this.limit) {
        return this.shift();
      } else {
        this.size++;
      }
    };
    p.shift = function() {
      var entry = this.head;
      if (entry) {
        this.head = this.head.newer;
        this.head.older = undefined;
        entry.newer = entry.older = undefined;
        this._keymap[entry.key] = undefined;
      }
      return entry;
    };
    p.get = function(key, returnEntry) {
      var entry = this._keymap[key];
      if (entry === undefined)
        return;
      if (entry === this.tail) {
        return returnEntry ? entry : entry.value;
      }
      if (entry.newer) {
        if (entry === this.head) {
          this.head = entry.newer;
        }
        entry.newer.older = entry.older;
      }
      if (entry.older) {
        entry.older.newer = entry.newer;
      }
      entry.newer = undefined;
      entry.older = this.tail;
      if (this.tail) {
        this.tail.newer = entry;
      }
      this.tail = entry;
      return returnEntry ? entry : entry.value;
    };
    var cache$1 = new Cache(1000);
    var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
    var reservedArgRE = /^in$|^-?\d+/;
    var str;
    var dir;
    var c;
    var prev;
    var i;
    var l;
    var lastFilterIndex;
    var inSingle;
    var inDouble;
    var curly;
    var square;
    var paren;
    function pushFilter() {
      var exp = str.slice(lastFilterIndex, i).trim();
      var filter;
      if (exp) {
        filter = {};
        var tokens = exp.match(filterTokenRE);
        filter.name = tokens[0];
        if (tokens.length > 1) {
          filter.args = tokens.slice(1).map(processFilterArg);
        }
      }
      if (filter) {
        (dir.filters = dir.filters || []).push(filter);
      }
      lastFilterIndex = i + 1;
    }
    function processFilterArg(arg) {
      if (reservedArgRE.test(arg)) {
        return {
          value: toNumber(arg),
          dynamic: false
        };
      } else {
        var stripped = stripQuotes(arg);
        var dynamic = stripped === arg;
        return {
          value: dynamic ? arg : stripped,
          dynamic: dynamic
        };
      }
    }
    function parseDirective(s) {
      var hit = cache$1.get(s);
      if (hit) {
        return hit;
      }
      str = s;
      inSingle = inDouble = false;
      curly = square = paren = 0;
      lastFilterIndex = 0;
      dir = {};
      for (i = 0, l = str.length; i < l; i++) {
        prev = c;
        c = str.charCodeAt(i);
        if (inSingle) {
          if (c === 0x27 && prev !== 0x5C)
            inSingle = !inSingle;
        } else if (inDouble) {
          if (c === 0x22 && prev !== 0x5C)
            inDouble = !inDouble;
        } else if (c === 0x7C && str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
          if (dir.expression == null) {
            lastFilterIndex = i + 1;
            dir.expression = str.slice(0, i).trim();
          } else {
            pushFilter();
          }
        } else {
          switch (c) {
            case 0x22:
              inDouble = true;
              break;
            case 0x27:
              inSingle = true;
              break;
            case 0x28:
              paren++;
              break;
            case 0x29:
              paren--;
              break;
            case 0x5B:
              square++;
              break;
            case 0x5D:
              square--;
              break;
            case 0x7B:
              curly++;
              break;
            case 0x7D:
              curly--;
              break;
          }
        }
      }
      if (dir.expression == null) {
        dir.expression = str.slice(0, i).trim();
      } else if (lastFilterIndex !== 0) {
        pushFilter();
      }
      cache$1.put(s, dir);
      return dir;
    }
    var directive = Object.freeze({parseDirective: parseDirective});
    var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
    var cache = undefined;
    var tagRE = undefined;
    var htmlRE = undefined;
    function escapeRegex(str) {
      return str.replace(regexEscapeRE, '\\$&');
    }
    function compileRegex() {
      var open = escapeRegex(config.delimiters[0]);
      var close = escapeRegex(config.delimiters[1]);
      var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
      var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
      tagRE = new RegExp(unsafeOpen + '(.+?)' + unsafeClose + '|' + open + '(.+?)' + close, 'g');
      htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');
      cache = new Cache(1000);
    }
    function parseText(text) {
      if (!cache) {
        compileRegex();
      }
      var hit = cache.get(text);
      if (hit) {
        return hit;
      }
      text = text.replace(/\n/g, '');
      if (!tagRE.test(text)) {
        return null;
      }
      var tokens = [];
      var lastIndex = tagRE.lastIndex = 0;
      var match,
          index,
          html,
          value,
          first,
          oneTime;
      while (match = tagRE.exec(text)) {
        index = match.index;
        if (index > lastIndex) {
          tokens.push({value: text.slice(lastIndex, index)});
        }
        html = htmlRE.test(match[0]);
        value = html ? match[1] : match[2];
        first = value.charCodeAt(0);
        oneTime = first === 42;
        value = oneTime ? value.slice(1) : value;
        tokens.push({
          tag: true,
          value: value.trim(),
          html: html,
          oneTime: oneTime
        });
        lastIndex = index + match[0].length;
      }
      if (lastIndex < text.length) {
        tokens.push({value: text.slice(lastIndex)});
      }
      cache.put(text, tokens);
      return tokens;
    }
    function tokensToExp(tokens) {
      if (tokens.length > 1) {
        return tokens.map(function(token) {
          return formatToken(token);
        }).join('+');
      } else {
        return formatToken(tokens[0], true);
      }
    }
    function formatToken(token, single) {
      return token.tag ? inlineFilters(token.value, single) : '"' + token.value + '"';
    }
    var filterRE$1 = /[^|]\|[^|]/;
    function inlineFilters(exp, single) {
      if (!filterRE$1.test(exp)) {
        return single ? exp : '(' + exp + ')';
      } else {
        var dir = parseDirective(exp);
        if (!dir.filters) {
          return '(' + exp + ')';
        } else {
          return 'this._applyFilters(' + dir.expression + ',null,' + JSON.stringify(dir.filters) + ',false)';
        }
      }
    }
    var text$1 = Object.freeze({
      compileRegex: compileRegex,
      parseText: parseText,
      tokensToExp: tokensToExp
    });
    var delimiters = ['{{', '}}'];
    var unsafeDelimiters = ['{{{', '}}}'];
    var config = Object.defineProperties({
      debug: false,
      silent: false,
      async: true,
      warnExpressionErrors: true,
      convertAllProperties: false,
      _delimitersChanged: true,
      _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
      _propBindingModes: {
        ONE_WAY: 0,
        TWO_WAY: 1,
        ONE_TIME: 2
      },
      _maxUpdateCount: 100
    }, {
      delimiters: {
        get: function get() {
          return delimiters;
        },
        set: function set(val) {
          delimiters = val;
          compileRegex();
        },
        configurable: true,
        enumerable: true
      },
      unsafeDelimiters: {
        get: function get() {
          return unsafeDelimiters;
        },
        set: function set(val) {
          unsafeDelimiters = val;
          compileRegex();
        },
        configurable: true,
        enumerable: true
      }
    });
    var warn = undefined;
    if (process.env.NODE_ENV !== 'production') {
      (function() {
        var hasConsole = typeof console !== 'undefined';
        warn = function(msg, e) {
          if (hasConsole && (!config.silent || config.debug)) {
            console.warn('[Vue warn]: ' + msg);
            if (config.debug) {
              if (e) {
                throw e;
              } else {
                console.warn(new Error('Warning Stack Trace').stack);
              }
            }
          }
        };
      })();
    }
    function appendWithTransition(el, target, vm, cb) {
      applyTransition(el, 1, function() {
        target.appendChild(el);
      }, vm, cb);
    }
    function beforeWithTransition(el, target, vm, cb) {
      applyTransition(el, 1, function() {
        before(el, target);
      }, vm, cb);
    }
    function removeWithTransition(el, vm, cb) {
      applyTransition(el, -1, function() {
        remove(el);
      }, vm, cb);
    }
    function applyTransition(el, direction, op, vm, cb) {
      var transition = el.__v_trans;
      if (!transition || !transition.hooks && !transitionEndEvent || !vm._isCompiled || vm.$parent && !vm.$parent._isCompiled) {
        op();
        if (cb)
          cb();
        return;
      }
      var action = direction > 0 ? 'enter' : 'leave';
      transition[action](op, cb);
    }
    function query(el) {
      if (typeof el === 'string') {
        var selector = el;
        el = document.querySelector(el);
        if (!el) {
          process.env.NODE_ENV !== 'production' && warn('Cannot find element: ' + selector);
        }
      }
      return el;
    }
    function inDoc(node) {
      var doc = document.documentElement;
      var parent = node && node.parentNode;
      return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
    }
    function getAttr(node, _attr) {
      var val = node.getAttribute(_attr);
      if (val !== null) {
        node.removeAttribute(_attr);
      }
      return val;
    }
    function getBindAttr(node, name) {
      var val = getAttr(node, ':' + name);
      if (val === null) {
        val = getAttr(node, 'v-bind:' + name);
      }
      return val;
    }
    function hasBindAttr(node, name) {
      return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
    }
    function before(el, target) {
      target.parentNode.insertBefore(el, target);
    }
    function after(el, target) {
      if (target.nextSibling) {
        before(el, target.nextSibling);
      } else {
        target.parentNode.appendChild(el);
      }
    }
    function remove(el) {
      el.parentNode.removeChild(el);
    }
    function prepend(el, target) {
      if (target.firstChild) {
        before(el, target.firstChild);
      } else {
        target.appendChild(el);
      }
    }
    function replace(target, el) {
      var parent = target.parentNode;
      if (parent) {
        parent.replaceChild(el, target);
      }
    }
    function on$1(el, event, cb) {
      el.addEventListener(event, cb);
    }
    function off(el, event, cb) {
      el.removeEventListener(event, cb);
    }
    function setClass(el, cls) {
      if (isIE9 && !(el instanceof SVGElement)) {
        el.className = cls;
      } else {
        el.setAttribute('class', cls);
      }
    }
    function addClass(el, cls) {
      if (el.classList) {
        el.classList.add(cls);
      } else {
        var cur = ' ' + (el.getAttribute('class') || '') + ' ';
        if (cur.indexOf(' ' + cls + ' ') < 0) {
          setClass(el, (cur + cls).trim());
        }
      }
    }
    function removeClass(el, cls) {
      if (el.classList) {
        el.classList.remove(cls);
      } else {
        var cur = ' ' + (el.getAttribute('class') || '') + ' ';
        var tar = ' ' + cls + ' ';
        while (cur.indexOf(tar) >= 0) {
          cur = cur.replace(tar, ' ');
        }
        setClass(el, cur.trim());
      }
      if (!el.className) {
        el.removeAttribute('class');
      }
    }
    function extractContent(el, asFragment) {
      var child;
      var rawContent;
      if (isTemplate(el) && el.content instanceof DocumentFragment) {
        el = el.content;
      }
      if (el.hasChildNodes()) {
        trimNode(el);
        rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
        while (child = el.firstChild) {
          rawContent.appendChild(child);
        }
      }
      return rawContent;
    }
    function trimNode(node) {
      trim(node, node.firstChild);
      trim(node, node.lastChild);
    }
    function trim(parent, node) {
      if (node && node.nodeType === 3 && !node.data.trim()) {
        parent.removeChild(node);
      }
    }
    function isTemplate(el) {
      return el.tagName && el.tagName.toLowerCase() === 'template';
    }
    function createAnchor(content, persist) {
      var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
      anchor.__vue_anchor = true;
      return anchor;
    }
    var refRE = /^v-ref:/;
    function findRef(node) {
      if (node.hasAttributes()) {
        var attrs = node.attributes;
        for (var i = 0,
            l = attrs.length; i < l; i++) {
          var name = attrs[i].name;
          if (refRE.test(name)) {
            return camelize(name.replace(refRE, ''));
          }
        }
      }
    }
    function mapNodeRange(node, end, op) {
      var next;
      while (node !== end) {
        next = node.nextSibling;
        op(node);
        node = next;
      }
      op(end);
    }
    function removeNodeRange(start, end, vm, frag, cb) {
      var done = false;
      var removed = 0;
      var nodes = [];
      mapNodeRange(start, end, function(node) {
        if (node === end)
          done = true;
        nodes.push(node);
        removeWithTransition(node, vm, onRemoved);
      });
      function onRemoved() {
        removed++;
        if (done && removed >= nodes.length) {
          for (var i = 0; i < nodes.length; i++) {
            frag.appendChild(nodes[i]);
          }
          cb && cb();
        }
      }
    }
    var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/;
    var reservedTagRE = /^(slot|partial|component)$/;
    function checkComponentAttr(el, options) {
      var tag = el.tagName.toLowerCase();
      var hasAttrs = el.hasAttributes();
      if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
        if (resolveAsset(options, 'components', tag)) {
          return {id: tag};
        } else {
          var is = hasAttrs && getIsBinding(el);
          if (is) {
            return is;
          } else if (process.env.NODE_ENV !== 'production') {
            if (tag.indexOf('-') > -1 || /HTMLUnknownElement/.test(el.toString()) && !/^(data|time|rtc|rb)$/.test(tag)) {
              warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly?');
            }
          }
        }
      } else if (hasAttrs) {
        return getIsBinding(el);
      }
    }
    function getIsBinding(el) {
      var exp = getAttr(el, 'is');
      if (exp != null) {
        return {id: exp};
      } else {
        exp = getBindAttr(el, 'is');
        if (exp != null) {
          return {
            id: exp,
            dynamic: true
          };
        }
      }
    }
    function initProp(vm, prop, value) {
      var key = prop.path;
      value = coerceProp(prop, value);
      vm[key] = vm._data[key] = assertProp(prop, value) ? value : undefined;
    }
    function assertProp(prop, value) {
      if (prop.raw === null && !prop.required) {
        return true;
      }
      var options = prop.options;
      var type = options.type;
      var valid = true;
      var expectedType;
      if (type) {
        if (type === String) {
          expectedType = 'string';
          valid = typeof value === expectedType;
        } else if (type === Number) {
          expectedType = 'number';
          valid = typeof value === 'number';
        } else if (type === Boolean) {
          expectedType = 'boolean';
          valid = typeof value === 'boolean';
        } else if (type === Function) {
          expectedType = 'function';
          valid = typeof value === 'function';
        } else if (type === Object) {
          expectedType = 'object';
          valid = isPlainObject(value);
        } else if (type === Array) {
          expectedType = 'array';
          valid = isArray(value);
        } else {
          valid = value instanceof type;
        }
      }
      if (!valid) {
        process.env.NODE_ENV !== 'production' && warn('Invalid prop: type check failed for ' + prop.path + '="' + prop.raw + '".' + ' Expected ' + formatType(expectedType) + ', got ' + formatValue(value) + '.');
        return false;
      }
      var validator = options.validator;
      if (validator) {
        if (!validator.call(null, value)) {
          process.env.NODE_ENV !== 'production' && warn('Invalid prop: custom validator check failed for ' + prop.path + '="' + prop.raw + '"');
          return false;
        }
      }
      return true;
    }
    function coerceProp(prop, value) {
      var coerce = prop.options.coerce;
      if (!coerce) {
        return value;
      }
      return coerce(value);
    }
    function formatType(val) {
      return val ? val.charAt(0).toUpperCase() + val.slice(1) : 'custom type';
    }
    function formatValue(val) {
      return Object.prototype.toString.call(val).slice(8, -1);
    }
    var strats = config.optionMergeStrategies = Object.create(null);
    function mergeData(to, from) {
      var key,
          toVal,
          fromVal;
      for (key in from) {
        toVal = to[key];
        fromVal = from[key];
        if (!hasOwn(to, key)) {
          set(to, key, fromVal);
        } else if (isObject(toVal) && isObject(fromVal)) {
          mergeData(toVal, fromVal);
        }
      }
      return to;
    }
    strats.data = function(parentVal, childVal, vm) {
      if (!vm) {
        if (!childVal) {
          return parentVal;
        }
        if (typeof childVal !== 'function') {
          process.env.NODE_ENV !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
          return parentVal;
        }
        if (!parentVal) {
          return childVal;
        }
        return function mergedDataFn() {
          return mergeData(childVal.call(this), parentVal.call(this));
        };
      } else if (parentVal || childVal) {
        return function mergedInstanceDataFn() {
          var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
          var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
          if (instanceData) {
            return mergeData(instanceData, defaultData);
          } else {
            return defaultData;
          }
        };
      }
    };
    strats.el = function(parentVal, childVal, vm) {
      if (!vm && childVal && typeof childVal !== 'function') {
        process.env.NODE_ENV !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.');
        return;
      }
      var ret = childVal || parentVal;
      return vm && typeof ret === 'function' ? ret.call(vm) : ret;
    };
    strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = function(parentVal, childVal) {
      return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
    };
    strats.paramAttributes = function() {
      process.env.NODE_ENV !== 'production' && warn('"paramAttributes" option has been deprecated in 0.12. ' + 'Use "props" instead.');
    };
    function mergeAssets(parentVal, childVal) {
      var res = Object.create(parentVal);
      return childVal ? extend(res, guardArrayAssets(childVal)) : res;
    }
    config._assetTypes.forEach(function(type) {
      strats[type + 's'] = mergeAssets;
    });
    strats.watch = strats.events = function(parentVal, childVal) {
      if (!childVal)
        return parentVal;
      if (!parentVal)
        return childVal;
      var ret = {};
      extend(ret, parentVal);
      for (var key in childVal) {
        var parent = ret[key];
        var child = childVal[key];
        if (parent && !isArray(parent)) {
          parent = [parent];
        }
        ret[key] = parent ? parent.concat(child) : [child];
      }
      return ret;
    };
    strats.props = strats.methods = strats.computed = function(parentVal, childVal) {
      if (!childVal)
        return parentVal;
      if (!parentVal)
        return childVal;
      var ret = Object.create(null);
      extend(ret, parentVal);
      extend(ret, childVal);
      return ret;
    };
    var defaultStrat = function defaultStrat(parentVal, childVal) {
      return childVal === undefined ? parentVal : childVal;
    };
    function guardComponents(options) {
      if (options.components) {
        var components = options.components = guardArrayAssets(options.components);
        var def;
        var ids = Object.keys(components);
        for (var i = 0,
            l = ids.length; i < l; i++) {
          var key = ids[i];
          if (commonTagRE.test(key) || reservedTagRE.test(key)) {
            process.env.NODE_ENV !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
            continue;
          }
          def = components[key];
          if (isPlainObject(def)) {
            components[key] = Vue.extend(def);
          }
        }
      }
    }
    function guardProps(options) {
      var props = options.props;
      var i,
          val;
      if (isArray(props)) {
        options.props = {};
        i = props.length;
        while (i--) {
          val = props[i];
          if (typeof val === 'string') {
            options.props[val] = null;
          } else if (val.name) {
            options.props[val.name] = val;
          }
        }
      } else if (isPlainObject(props)) {
        var keys = Object.keys(props);
        i = keys.length;
        while (i--) {
          val = props[keys[i]];
          if (typeof val === 'function') {
            props[keys[i]] = {type: val};
          }
        }
      }
    }
    function guardArrayAssets(assets) {
      if (isArray(assets)) {
        var res = {};
        var i = assets.length;
        var asset;
        while (i--) {
          asset = assets[i];
          var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
          if (!id) {
            process.env.NODE_ENV !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
          } else {
            res[id] = asset;
          }
        }
        return res;
      }
      return assets;
    }
    function mergeOptions(parent, child, vm) {
      guardComponents(child);
      guardProps(child);
      var options = {};
      var key;
      if (child.mixins) {
        for (var i = 0,
            l = child.mixins.length; i < l; i++) {
          parent = mergeOptions(parent, child.mixins[i], vm);
        }
      }
      for (key in parent) {
        mergeField(key);
      }
      for (key in child) {
        if (!hasOwn(parent, key)) {
          mergeField(key);
        }
      }
      function mergeField(key) {
        var strat = strats[key] || defaultStrat;
        options[key] = strat(parent[key], child[key], vm, key);
      }
      return options;
    }
    function resolveAsset(options, type, id) {
      var assets = options[type];
      var camelizedId;
      return assets[id] || assets[camelizedId = camelize(id)] || assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
    }
    function assertAsset(val, type, id) {
      if (!val) {
        process.env.NODE_ENV !== 'production' && warn('Failed to resolve ' + type + ': ' + id);
      }
    }
    var arrayProto = Array.prototype;
    var arrayMethods = Object.create(arrayProto);
    ;
    ['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function(method) {
      var original = arrayProto[method];
      def(arrayMethods, method, function mutator() {
        var i = arguments.length;
        var args = new Array(i);
        while (i--) {
          args[i] = arguments[i];
        }
        var result = original.apply(this, args);
        var ob = this.__ob__;
        var inserted;
        switch (method) {
          case 'push':
            inserted = args;
            break;
          case 'unshift':
            inserted = args;
            break;
          case 'splice':
            inserted = args.slice(2);
            break;
        }
        if (inserted)
          ob.observeArray(inserted);
        ob.dep.notify();
        return result;
      });
    });
    def(arrayProto, '$set', function $set(index, val) {
      if (index >= this.length) {
        this.length = Number(index) + 1;
      }
      return this.splice(index, 1, val)[0];
    });
    def(arrayProto, '$remove', function $remove(item) {
      if (!this.length)
        return;
      var index = indexOf(this, item);
      if (index > -1) {
        return this.splice(index, 1);
      }
    });
    var uid$3 = 0;
    function Dep() {
      this.id = uid$3++;
      this.subs = [];
    }
    Dep.target = null;
    Dep.prototype.addSub = function(sub) {
      this.subs.push(sub);
    };
    Dep.prototype.removeSub = function(sub) {
      this.subs.$remove(sub);
    };
    Dep.prototype.depend = function() {
      Dep.target.addDep(this);
    };
    Dep.prototype.notify = function() {
      var subs = toArray(this.subs);
      for (var i = 0,
          l = subs.length; i < l; i++) {
        subs[i].update();
      }
    };
    var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
    function Observer(value) {
      this.value = value;
      this.dep = new Dep();
      def(value, '__ob__', this);
      if (isArray(value)) {
        var augment = hasProto ? protoAugment : copyAugment;
        augment(value, arrayMethods, arrayKeys);
        this.observeArray(value);
      } else {
        this.walk(value);
      }
    }
    Observer.prototype.walk = function(obj) {
      var keys = Object.keys(obj);
      for (var i = 0,
          l = keys.length; i < l; i++) {
        this.convert(keys[i], obj[keys[i]]);
      }
    };
    Observer.prototype.observeArray = function(items) {
      for (var i = 0,
          l = items.length; i < l; i++) {
        observe(items[i]);
      }
    };
    Observer.prototype.convert = function(key, val) {
      defineReactive(this.value, key, val);
    };
    Observer.prototype.addVm = function(vm) {
      (this.vms || (this.vms = [])).push(vm);
    };
    Observer.prototype.removeVm = function(vm) {
      this.vms.$remove(vm);
    };
    function protoAugment(target, src) {
      target.__proto__ = src;
    }
    function copyAugment(target, src, keys) {
      for (var i = 0,
          l = keys.length; i < l; i++) {
        var key = keys[i];
        def(target, key, src[key]);
      }
    }
    function observe(value, vm) {
      if (!value || typeof value !== 'object') {
        return;
      }
      var ob;
      if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
        ob = value.__ob__;
      } else if ((isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
        ob = new Observer(value);
      }
      if (ob && vm) {
        ob.addVm(vm);
      }
      return ob;
    }
    function defineReactive(obj, key, val) {
      var dep = new Dep();
      var getter,
          setter;
      if (config.convertAllProperties) {
        var property = Object.getOwnPropertyDescriptor(obj, key);
        if (property && property.configurable === false) {
          return;
        }
        getter = property && property.get;
        setter = property && property.set;
      }
      var childOb = observe(val);
      Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
          var value = getter ? getter.call(obj) : val;
          if (Dep.target) {
            dep.depend();
            if (childOb) {
              childOb.dep.depend();
            }
            if (isArray(value)) {
              for (var e,
                  i = 0,
                  l = value.length; i < l; i++) {
                e = value[i];
                e && e.__ob__ && e.__ob__.dep.depend();
              }
            }
          }
          return value;
        },
        set: function reactiveSetter(newVal) {
          var value = getter ? getter.call(obj) : val;
          if (newVal === value) {
            return;
          }
          if (setter) {
            setter.call(obj, newVal);
          } else {
            val = newVal;
          }
          childOb = observe(newVal);
          dep.notify();
        }
      });
    }
    var util = Object.freeze({
      defineReactive: defineReactive,
      set: set,
      del: del,
      hasOwn: hasOwn,
      isLiteral: isLiteral,
      isReserved: isReserved,
      _toString: _toString,
      toNumber: toNumber,
      toBoolean: toBoolean,
      stripQuotes: stripQuotes,
      camelize: camelize,
      hyphenate: hyphenate,
      classify: classify,
      bind: bind$1,
      toArray: toArray,
      extend: extend,
      isObject: isObject,
      isPlainObject: isPlainObject,
      def: def,
      debounce: _debounce,
      indexOf: indexOf,
      cancellable: cancellable,
      looseEqual: looseEqual,
      isArray: isArray,
      hasProto: hasProto,
      inBrowser: inBrowser,
      isIE9: isIE9,
      isAndroid: isAndroid,
      get transitionProp() {
        return transitionProp;
      },
      get transitionEndEvent() {
        return transitionEndEvent;
      },
      get animationProp() {
        return animationProp;
      },
      get animationEndEvent() {
        return animationEndEvent;
      },
      nextTick: nextTick,
      query: query,
      inDoc: inDoc,
      getAttr: getAttr,
      getBindAttr: getBindAttr,
      hasBindAttr: hasBindAttr,
      before: before,
      after: after,
      remove: remove,
      prepend: prepend,
      replace: replace,
      on: on$1,
      off: off,
      setClass: setClass,
      addClass: addClass,
      removeClass: removeClass,
      extractContent: extractContent,
      trimNode: trimNode,
      isTemplate: isTemplate,
      createAnchor: createAnchor,
      findRef: findRef,
      mapNodeRange: mapNodeRange,
      removeNodeRange: removeNodeRange,
      mergeOptions: mergeOptions,
      resolveAsset: resolveAsset,
      assertAsset: assertAsset,
      checkComponentAttr: checkComponentAttr,
      initProp: initProp,
      assertProp: assertProp,
      coerceProp: coerceProp,
      commonTagRE: commonTagRE,
      reservedTagRE: reservedTagRE,
      get warn() {
        return warn;
      }
    });
    var uid = 0;
    function initMixin(Vue) {
      Vue.prototype._init = function(options) {
        options = options || {};
        this.$el = null;
        this.$parent = options.parent;
        this.$root = this.$parent ? this.$parent.$root : this;
        this.$children = [];
        this.$refs = {};
        this.$els = {};
        this._watchers = [];
        this._directives = [];
        this._uid = uid++;
        this._isVue = true;
        this._events = {};
        this._eventsCount = {};
        this._isFragment = false;
        this._fragment = this._fragmentStart = this._fragmentEnd = null;
        this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = false;
        this._unlinkFn = null;
        this._context = options._context || this.$parent;
        this._scope = options._scope;
        this._frag = options._frag;
        if (this._frag) {
          this._frag.children.push(this);
        }
        if (this.$parent) {
          this.$parent.$children.push(this);
        }
        options = this.$options = mergeOptions(this.constructor.options, options, this);
        this._updateRef();
        this._data = {};
        this._callHook('init');
        this._initState();
        this._initEvents();
        this._callHook('created');
        if (options.el) {
          this.$mount(options.el);
        }
      };
    }
    var pathCache = new Cache(1000);
    var APPEND = 0;
    var PUSH = 1;
    var INC_SUB_PATH_DEPTH = 2;
    var PUSH_SUB_PATH = 3;
    var BEFORE_PATH = 0;
    var IN_PATH = 1;
    var BEFORE_IDENT = 2;
    var IN_IDENT = 3;
    var IN_SUB_PATH = 4;
    var IN_SINGLE_QUOTE = 5;
    var IN_DOUBLE_QUOTE = 6;
    var AFTER_PATH = 7;
    var ERROR = 8;
    var pathStateMachine = [];
    pathStateMachine[BEFORE_PATH] = {
      'ws': [BEFORE_PATH],
      'ident': [IN_IDENT, APPEND],
      '[': [IN_SUB_PATH],
      'eof': [AFTER_PATH]
    };
    pathStateMachine[IN_PATH] = {
      'ws': [IN_PATH],
      '.': [BEFORE_IDENT],
      '[': [IN_SUB_PATH],
      'eof': [AFTER_PATH]
    };
    pathStateMachine[BEFORE_IDENT] = {
      'ws': [BEFORE_IDENT],
      'ident': [IN_IDENT, APPEND]
    };
    pathStateMachine[IN_IDENT] = {
      'ident': [IN_IDENT, APPEND],
      '0': [IN_IDENT, APPEND],
      'number': [IN_IDENT, APPEND],
      'ws': [IN_PATH, PUSH],
      '.': [BEFORE_IDENT, PUSH],
      '[': [IN_SUB_PATH, PUSH],
      'eof': [AFTER_PATH, PUSH]
    };
    pathStateMachine[IN_SUB_PATH] = {
      "'": [IN_SINGLE_QUOTE, APPEND],
      '"': [IN_DOUBLE_QUOTE, APPEND],
      '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
      ']': [IN_PATH, PUSH_SUB_PATH],
      'eof': ERROR,
      'else': [IN_SUB_PATH, APPEND]
    };
    pathStateMachine[IN_SINGLE_QUOTE] = {
      "'": [IN_SUB_PATH, APPEND],
      'eof': ERROR,
      'else': [IN_SINGLE_QUOTE, APPEND]
    };
    pathStateMachine[IN_DOUBLE_QUOTE] = {
      '"': [IN_SUB_PATH, APPEND],
      'eof': ERROR,
      'else': [IN_DOUBLE_QUOTE, APPEND]
    };
    function getPathCharType(ch) {
      if (ch === undefined) {
        return 'eof';
      }
      var code = ch.charCodeAt(0);
      switch (code) {
        case 0x5B:
        case 0x5D:
        case 0x2E:
        case 0x22:
        case 0x27:
        case 0x30:
          return ch;
        case 0x5F:
        case 0x24:
          return 'ident';
        case 0x20:
        case 0x09:
        case 0x0A:
        case 0x0D:
        case 0xA0:
        case 0xFEFF:
        case 0x2028:
        case 0x2029:
          return 'ws';
      }
      if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
        return 'ident';
      }
      if (code >= 0x31 && code <= 0x39) {
        return 'number';
      }
      return 'else';
    }
    function formatSubPath(path) {
      var trimmed = path.trim();
      if (path.charAt(0) === '0' && isNaN(path)) {
        return false;
      }
      return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
    }
    function parse(path) {
      var keys = [];
      var index = -1;
      var mode = BEFORE_PATH;
      var subPathDepth = 0;
      var c,
          newChar,
          key,
          type,
          transition,
          action,
          typeMap;
      var actions = [];
      actions[PUSH] = function() {
        if (key !== undefined) {
          keys.push(key);
          key = undefined;
        }
      };
      actions[APPEND] = function() {
        if (key === undefined) {
          key = newChar;
        } else {
          key += newChar;
        }
      };
      actions[INC_SUB_PATH_DEPTH] = function() {
        actions[APPEND]();
        subPathDepth++;
      };
      actions[PUSH_SUB_PATH] = function() {
        if (subPathDepth > 0) {
          subPathDepth--;
          mode = IN_SUB_PATH;
          actions[APPEND]();
        } else {
          subPathDepth = 0;
          key = formatSubPath(key);
          if (key === false) {
            return false;
          } else {
            actions[PUSH]();
          }
        }
      };
      function maybeUnescapeQuote() {
        var nextChar = path[index + 1];
        if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
          index++;
          newChar = '\\' + nextChar;
          actions[APPEND]();
          return true;
        }
      }
      while (mode != null) {
        index++;
        c = path[index];
        if (c === '\\' && maybeUnescapeQuote()) {
          continue;
        }
        type = getPathCharType(c);
        typeMap = pathStateMachine[mode];
        transition = typeMap[type] || typeMap['else'] || ERROR;
        if (transition === ERROR) {
          return;
        }
        mode = transition[0];
        action = actions[transition[1]];
        if (action) {
          newChar = transition[2];
          newChar = newChar === undefined ? c : newChar;
          if (action() === false) {
            return;
          }
        }
        if (mode === AFTER_PATH) {
          keys.raw = path;
          return keys;
        }
      }
    }
    function parsePath(path) {
      var hit = pathCache.get(path);
      if (!hit) {
        hit = parse(path);
        if (hit) {
          pathCache.put(path, hit);
        }
      }
      return hit;
    }
    function getPath(obj, path) {
      return parseExpression(path).get(obj);
    }
    var warnNonExistent;
    if (process.env.NODE_ENV !== 'production') {
      warnNonExistent = function(path) {
        warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.');
      };
    }
    function setPath(obj, path, val) {
      var original = obj;
      if (typeof path === 'string') {
        path = parse(path);
      }
      if (!path || !isObject(obj)) {
        return false;
      }
      var last,
          key;
      for (var i = 0,
          l = path.length; i < l; i++) {
        last = obj;
        key = path[i];
        if (key.charAt(0) === '*') {
          key = parseExpression(key.slice(1)).get.call(original, original);
        }
        if (i < l - 1) {
          obj = obj[key];
          if (!isObject(obj)) {
            obj = {};
            if (process.env.NODE_ENV !== 'production' && last._isVue) {
              warnNonExistent(path);
            }
            set(last, key, obj);
          }
        } else {
          if (isArray(obj)) {
            obj.$set(key, val);
          } else if (key in obj) {
            obj[key] = val;
          } else {
            if (process.env.NODE_ENV !== 'production' && obj._isVue) {
              warnNonExistent(path);
            }
            set(obj, key, val);
          }
        }
      }
      return true;
    }
    var path = Object.freeze({
      parsePath: parsePath,
      getPath: getPath,
      setPath: setPath
    });
    var expressionCache = new Cache(1000);
    var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
    var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
    var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'proctected,static,interface,private,public';
    var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
    var wsRE = /\s/g;
    var newlineRE = /\n/g;
    var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*")|new |typeof |void /g;
    var restoreRE = /"(\d+)"/g;
    var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
    var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
    var booleanLiteralRE = /^(?:true|false)$/;
    var saved = [];
    function save(str, isString) {
      var i = saved.length;
      saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
      return '"' + i + '"';
    }
    function rewrite(raw) {
      var c = raw.charAt(0);
      var path = raw.slice(1);
      if (allowedKeywordsRE.test(path)) {
        return raw;
      } else {
        path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
        return c + 'scope.' + path;
      }
    }
    function restore(str, i) {
      return saved[i];
    }
    function compileGetter(exp) {
      if (improperKeywordsRE.test(exp)) {
        process.env.NODE_ENV !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
      }
      saved.length = 0;
      var body = exp.replace(saveRE, save).replace(wsRE, '');
      body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
      return makeGetterFn(body);
    }
    function makeGetterFn(body) {
      try {
        return new Function('scope', 'return ' + body + ';');
      } catch (e) {
        process.env.NODE_ENV !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);
      }
    }
    function compileSetter(exp) {
      var path = parsePath(exp);
      if (path) {
        return function(scope, val) {
          setPath(scope, path, val);
        };
      } else {
        process.env.NODE_ENV !== 'production' && warn('Invalid setter expression: ' + exp);
      }
    }
    function parseExpression(exp, needSet) {
      exp = exp.trim();
      var hit = expressionCache.get(exp);
      if (hit) {
        if (needSet && !hit.set) {
          hit.set = compileSetter(hit.exp);
        }
        return hit;
      }
      var res = {exp: exp};
      res.get = isSimplePath(exp) && exp.indexOf('[') < 0 ? makeGetterFn('scope.' + exp) : compileGetter(exp);
      if (needSet) {
        res.set = compileSetter(exp);
      }
      expressionCache.put(exp, res);
      return res;
    }
    function isSimplePath(exp) {
      return pathTestRE.test(exp) && !booleanLiteralRE.test(exp) && exp.slice(0, 5) !== 'Math.';
    }
    var expression = Object.freeze({
      parseExpression: parseExpression,
      isSimplePath: isSimplePath
    });
    var queue = [];
    var userQueue = [];
    var has = {};
    var circular = {};
    var waiting = false;
    var internalQueueDepleted = false;
    function resetBatcherState() {
      queue = [];
      userQueue = [];
      has = {};
      circular = {};
      waiting = internalQueueDepleted = false;
    }
    function flushBatcherQueue() {
      runBatcherQueue(queue);
      internalQueueDepleted = true;
      runBatcherQueue(userQueue);
      if (process.env.NODE_ENV !== 'production') {
        if (inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
          window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('flush');
        }
      }
      resetBatcherState();
    }
    function runBatcherQueue(queue) {
      for (var i = 0; i < queue.length; i++) {
        var watcher = queue[i];
        var id = watcher.id;
        has[id] = null;
        watcher.run();
        if (process.env.NODE_ENV !== 'production' && has[id] != null) {
          circular[id] = (circular[id] || 0) + 1;
          if (circular[id] > config._maxUpdateCount) {
            queue.splice(has[id], 1);
            warn('You may have an infinite update loop for watcher ' + 'with expression: ' + watcher.expression);
          }
        }
      }
    }
    function pushWatcher(watcher) {
      var id = watcher.id;
      if (has[id] == null) {
        if (internalQueueDepleted && !watcher.user) {
          watcher.run();
          return;
        }
        var q = watcher.user ? userQueue : queue;
        has[id] = q.length;
        q.push(watcher);
        if (!waiting) {
          waiting = true;
          nextTick(flushBatcherQueue);
        }
      }
    }
    var uid$2 = 0;
    function Watcher(vm, expOrFn, cb, options) {
      if (options) {
        extend(this, options);
      }
      var isFn = typeof expOrFn === 'function';
      this.vm = vm;
      vm._watchers.push(this);
      this.expression = isFn ? expOrFn.toString() : expOrFn;
      this.cb = cb;
      this.id = ++uid$2;
      this.active = true;
      this.dirty = this.lazy;
      this.deps = Object.create(null);
      this.newDeps = null;
      this.prevError = null;
      if (isFn) {
        this.getter = expOrFn;
        this.setter = undefined;
      } else {
        var res = parseExpression(expOrFn, this.twoWay);
        this.getter = res.get;
        this.setter = res.set;
      }
      this.value = this.lazy ? undefined : this.get();
      this.queued = this.shallow = false;
    }
    Watcher.prototype.addDep = function(dep) {
      var id = dep.id;
      if (!this.newDeps[id]) {
        this.newDeps[id] = dep;
        if (!this.deps[id]) {
          this.deps[id] = dep;
          dep.addSub(this);
        }
      }
    };
    Watcher.prototype.get = function() {
      this.beforeGet();
      var scope = this.scope || this.vm;
      var value;
      try {
        value = this.getter.call(scope, scope);
      } catch (e) {
        if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
          warn('Error when evaluating expression "' + this.expression + '". ' + (config.debug ? '' : 'Turn on debug mode to see stack trace.'), e);
        }
      }
      if (this.deep) {
        traverse(value);
      }
      if (this.preProcess) {
        value = this.preProcess(value);
      }
      if (this.filters) {
        value = scope._applyFilters(value, null, this.filters, false);
      }
      if (this.postProcess) {
        value = this.postProcess(value);
      }
      this.afterGet();
      return value;
    };
    Watcher.prototype.set = function(value) {
      var scope = this.scope || this.vm;
      if (this.filters) {
        value = scope._applyFilters(value, this.value, this.filters, true);
      }
      try {
        this.setter.call(scope, scope, value);
      } catch (e) {
        if (process.env.NODE_ENV !== 'production' && config.warnExpressionErrors) {
          warn('Error when evaluating setter "' + this.expression + '"', e);
        }
      }
      var forContext = scope.$forContext;
      if (forContext && forContext.alias === this.expression) {
        if (forContext.filters) {
          process.env.NODE_ENV !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.');
          return;
        }
        forContext._withLock(function() {
          if (scope.$key) {
            forContext.rawValue[scope.$key] = value;
          } else {
            forContext.rawValue.$set(scope.$index, value);
          }
        });
      }
    };
    Watcher.prototype.beforeGet = function() {
      Dep.target = this;
      this.newDeps = Object.create(null);
    };
    Watcher.prototype.afterGet = function() {
      Dep.target = null;
      var ids = Object.keys(this.deps);
      var i = ids.length;
      while (i--) {
        var id = ids[i];
        if (!this.newDeps[id]) {
          this.deps[id].removeSub(this);
        }
      }
      this.deps = this.newDeps;
    };
    Watcher.prototype.update = function(shallow) {
      if (this.lazy) {
        this.dirty = true;
      } else if (this.sync || !config.async) {
        this.run();
      } else {
        this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
        this.queued = true;
        if (process.env.NODE_ENV !== 'production' && config.debug) {
          this.prevError = new Error('[vue] async stack trace');
        }
        pushWatcher(this);
      }
    };
    Watcher.prototype.run = function() {
      if (this.active) {
        var value = this.get();
        if (value !== this.value || (isObject(value) || this.deep) && !this.shallow) {
          var oldValue = this.value;
          this.value = value;
          var prevError = this.prevError;
          if (process.env.NODE_ENV !== 'production' && config.debug && prevError) {
            this.prevError = null;
            try {
              this.cb.call(this.vm, value, oldValue);
            } catch (e) {
              nextTick(function() {
                throw prevError;
              }, 0);
              throw e;
            }
          } else {
            this.cb.call(this.vm, value, oldValue);
          }
        }
        this.queued = this.shallow = false;
      }
    };
    Watcher.prototype.evaluate = function() {
      var current = Dep.target;
      this.value = this.get();
      this.dirty = false;
      Dep.target = current;
    };
    Watcher.prototype.depend = function() {
      var depIds = Object.keys(this.deps);
      var i = depIds.length;
      while (i--) {
        this.deps[depIds[i]].depend();
      }
    };
    Watcher.prototype.teardown = function() {
      if (this.active) {
        if (!this.vm._isBeingDestroyed) {
          this.vm._watchers.$remove(this);
        }
        var depIds = Object.keys(this.deps);
        var i = depIds.length;
        while (i--) {
          this.deps[depIds[i]].removeSub(this);
        }
        this.active = false;
        this.vm = this.cb = this.value = null;
      }
    };
    function traverse(val) {
      var i,
          keys;
      if (isArray(val)) {
        i = val.length;
        while (i--)
          traverse(val[i]);
      } else if (isObject(val)) {
        keys = Object.keys(val);
        i = keys.length;
        while (i--)
          traverse(val[keys[i]]);
      }
    }
    var cloak = {bind: function bind() {
        var el = this.el;
        this.vm.$once('pre-hook:compiled', function() {
          el.removeAttribute('v-cloak');
        });
      }};
    var ref = {bind: function bind() {
        process.env.NODE_ENV !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.');
      }};
    var ON = 700;
    var MODEL = 800;
    var BIND = 850;
    var TRANSITION = 1100;
    var EL = 1500;
    var COMPONENT = 1500;
    var PARTIAL = 1750;
    var SLOT = 1750;
    var FOR = 2000;
    var IF = 2000;
    var el = {
      priority: EL,
      bind: function bind() {
        if (!this.arg) {
          return;
        }
        var id = this.id = camelize(this.arg);
        var refs = (this._scope || this.vm).$els;
        if (hasOwn(refs, id)) {
          refs[id] = this.el;
        } else {
          defineReactive(refs, id, this.el);
        }
      },
      unbind: function unbind() {
        var refs = (this._scope || this.vm).$els;
        if (refs[this.id] === this.el) {
          refs[this.id] = null;
        }
      }
    };
    var prefixes = ['-webkit-', '-moz-', '-ms-'];
    var camelPrefixes = ['Webkit', 'Moz', 'ms'];
    var importantRE = /!important;?$/;
    var propCache = Object.create(null);
    var testEl = null;
    var style = {
      deep: true,
      update: function update(value) {
        if (typeof value === 'string') {
          this.el.style.cssText = value;
        } else if (isArray(value)) {
          this.handleObject(value.reduce(extend, {}));
        } else {
          this.handleObject(value || {});
        }
      },
      handleObject: function handleObject(value) {
        var cache = this.cache || (this.cache = {});
        var name,
            val;
        for (name in cache) {
          if (!(name in value)) {
            this.handleSingle(name, null);
            delete cache[name];
          }
        }
        for (name in value) {
          val = value[name];
          if (val !== cache[name]) {
            cache[name] = val;
            this.handleSingle(name, val);
          }
        }
      },
      handleSingle: function handleSingle(prop, value) {
        prop = normalize(prop);
        if (!prop)
          return;
        if (value != null)
          value += '';
        if (value) {
          var isImportant = importantRE.test(value) ? 'important' : '';
          if (isImportant) {
            value = value.replace(importantRE, '').trim();
          }
          this.el.style.setProperty(prop, value, isImportant);
        } else {
          this.el.style.removeProperty(prop);
        }
      }
    };
    function normalize(prop) {
      if (propCache[prop]) {
        return propCache[prop];
      }
      var res = prefix(prop);
      propCache[prop] = propCache[res] = res;
      return res;
    }
    function prefix(prop) {
      prop = hyphenate(prop);
      var camel = camelize(prop);
      var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
      if (!testEl) {
        testEl = document.createElement('div');
      }
      if (camel in testEl.style) {
        return prop;
      }
      var i = prefixes.length;
      var prefixed;
      while (i--) {
        prefixed = camelPrefixes[i] + upper;
        if (prefixed in testEl.style) {
          return prefixes[i] + prop;
        }
      }
    }
    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var xlinkRE = /^xlink:/;
    var disallowedInterpAttrRE = /^v-|^:|^@|^(is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
    var attrWithPropsRE = /^(value|checked|selected|muted)$/;
    var modelProps = {
      value: '_value',
      'true-value': '_trueValue',
      'false-value': '_falseValue'
    };
    var bind = {
      priority: BIND,
      bind: function bind() {
        var attr = this.arg;
        var tag = this.el.tagName;
        if (!attr) {
          this.deep = true;
        }
        if (this.descriptor.interp) {
          if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
            process.env.NODE_ENV !== 'production' && warn(attr + '="' + this.descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.');
            this.el.removeAttribute(attr);
            this.invalid = true;
          }
          if (process.env.NODE_ENV !== 'production') {
            var raw = attr + '="' + this.descriptor.raw + '": ';
            if (attr === 'src') {
              warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.');
            }
            if (attr === 'style') {
              warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.');
            }
          }
        }
      },
      update: function update(value) {
        if (this.invalid) {
          return;
        }
        var attr = this.arg;
        if (this.arg) {
          this.handleSingle(attr, value);
        } else {
          this.handleObject(value || {});
        }
      },
      handleObject: style.handleObject,
      handleSingle: function handleSingle(attr, value) {
        var el = this.el;
        var interp = this.descriptor.interp;
        if (!interp && attrWithPropsRE.test(attr) && attr in el) {
          el[attr] = attr === 'value' ? value == null ? '' : value : value;
        }
        var modelProp = modelProps[attr];
        if (!interp && modelProp) {
          el[modelProp] = value;
          var model = el.__v_model;
          if (model) {
            model.listener();
          }
        }
        if (attr === 'value' && el.tagName === 'TEXTAREA') {
          el.removeAttribute(attr);
          return;
        }
        if (value != null && value !== false) {
          if (attr === 'class') {
            if (el.__v_trans) {
              value += ' ' + el.__v_trans.id + '-transition';
            }
            setClass(el, value);
          } else if (xlinkRE.test(attr)) {
            el.setAttributeNS(xlinkNS, attr, value);
          } else {
            el.setAttribute(attr, value);
          }
        } else {
          el.removeAttribute(attr);
        }
      }
    };
    var keyCodes = {
      esc: 27,
      tab: 9,
      enter: 13,
      space: 32,
      'delete': 46,
      up: 38,
      left: 37,
      right: 39,
      down: 40
    };
    function keyFilter(handler, keys) {
      var codes = keys.map(function(key) {
        var charCode = key.charCodeAt(0);
        if (charCode > 47 && charCode < 58) {
          return parseInt(key, 10);
        }
        if (key.length === 1) {
          charCode = key.toUpperCase().charCodeAt(0);
          if (charCode > 64 && charCode < 91) {
            return charCode;
          }
        }
        return keyCodes[key];
      });
      return function keyHandler(e) {
        if (codes.indexOf(e.keyCode) > -1) {
          return handler.call(this, e);
        }
      };
    }
    function stopFilter(handler) {
      return function stopHandler(e) {
        e.stopPropagation();
        return handler.call(this, e);
      };
    }
    function preventFilter(handler) {
      return function preventHandler(e) {
        e.preventDefault();
        return handler.call(this, e);
      };
    }
    var on = {
      acceptStatement: true,
      priority: ON,
      bind: function bind() {
        if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
          var self = this;
          this.iframeBind = function() {
            on$1(self.el.contentWindow, self.arg, self.handler);
          };
          this.on('load', this.iframeBind);
        }
      },
      update: function update(handler) {
        if (!this.descriptor.raw) {
          handler = function() {};
        }
        if (typeof handler !== 'function') {
          process.env.NODE_ENV !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler);
          return;
        }
        if (this.modifiers.stop) {
          handler = stopFilter(handler);
        }
        if (this.modifiers.prevent) {
          handler = preventFilter(handler);
        }
        var keys = Object.keys(this.modifiers).filter(function(key) {
          return key !== 'stop' && key !== 'prevent';
        });
        if (keys.length) {
          handler = keyFilter(handler, keys);
        }
        this.reset();
        this.handler = handler;
        if (this.iframeBind) {
          this.iframeBind();
        } else {
          on$1(this.el, this.arg, this.handler);
        }
      },
      reset: function reset() {
        var el = this.iframeBind ? this.el.contentWindow : this.el;
        if (this.handler) {
          off(el, this.arg, this.handler);
        }
      },
      unbind: function unbind() {
        this.reset();
      }
    };
    var checkbox = {
      bind: function bind() {
        var self = this;
        var el = this.el;
        this.getValue = function() {
          return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
        };
        function getBooleanValue() {
          var val = el.checked;
          if (val && el.hasOwnProperty('_trueValue')) {
            return el._trueValue;
          }
          if (!val && el.hasOwnProperty('_falseValue')) {
            return el._falseValue;
          }
          return val;
        }
        this.listener = function() {
          var model = self._watcher.value;
          if (isArray(model)) {
            var val = self.getValue();
            if (el.checked) {
              if (indexOf(model, val) < 0) {
                model.push(val);
              }
            } else {
              model.$remove(val);
            }
          } else {
            self.set(getBooleanValue());
          }
        };
        this.on('change', this.listener);
        if (el.hasAttribute('checked')) {
          this.afterBind = this.listener;
        }
      },
      update: function update(value) {
        var el = this.el;
        if (isArray(value)) {
          el.checked = indexOf(value, this.getValue()) > -1;
        } else {
          if (el.hasOwnProperty('_trueValue')) {
            el.checked = looseEqual(value, el._trueValue);
          } else {
            el.checked = !!value;
          }
        }
      }
    };
    var select = {
      bind: function bind() {
        var self = this;
        var el = this.el;
        this.forceUpdate = function() {
          if (self._watcher) {
            self.update(self._watcher.get());
          }
        };
        var multiple = this.multiple = el.hasAttribute('multiple');
        this.listener = function() {
          var value = getValue(el, multiple);
          value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
          self.set(value);
        };
        this.on('change', this.listener);
        var initValue = getValue(el, multiple, true);
        if (multiple && initValue.length || !multiple && initValue !== null) {
          this.afterBind = this.listener;
        }
        this.vm.$on('hook:attached', this.forceUpdate);
      },
      update: function update(value) {
        var el = this.el;
        el.selectedIndex = -1;
        var multi = this.multiple && isArray(value);
        var options = el.options;
        var i = options.length;
        var op,
            val;
        while (i--) {
          op = options[i];
          val = op.hasOwnProperty('_value') ? op._value : op.value;
          op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
        }
      },
      unbind: function unbind() {
        this.vm.$off('hook:attached', this.forceUpdate);
      }
    };
    function getValue(el, multi, init) {
      var res = multi ? [] : null;
      var op,
          val,
          selected;
      for (var i = 0,
          l = el.options.length; i < l; i++) {
        op = el.options[i];
        selected = init ? op.hasAttribute('selected') : op.selected;
        if (selected) {
          val = op.hasOwnProperty('_value') ? op._value : op.value;
          if (multi) {
            res.push(val);
          } else {
            return val;
          }
        }
      }
      return res;
    }
    function indexOf$1(arr, val) {
      var i = arr.length;
      while (i--) {
        if (looseEqual(arr[i], val)) {
          return i;
        }
      }
      return -1;
    }
    var radio = {
      bind: function bind() {
        var self = this;
        var el = this.el;
        this.getValue = function() {
          if (el.hasOwnProperty('_value')) {
            return el._value;
          }
          var val = el.value;
          if (self.params.number) {
            val = toNumber(val);
          }
          return val;
        };
        this.listener = function() {
          self.set(self.getValue());
        };
        this.on('change', this.listener);
        if (el.hasAttribute('checked')) {
          this.afterBind = this.listener;
        }
      },
      update: function update(value) {
        this.el.checked = looseEqual(value, this.getValue());
      }
    };
    var text$2 = {
      bind: function bind() {
        var self = this;
        var el = this.el;
        var isRange = el.type === 'range';
        var lazy = this.params.lazy;
        var number = this.params.number;
        var debounce = this.params.debounce;
        var composing = false;
        if (!isAndroid && !isRange) {
          this.on('compositionstart', function() {
            composing = true;
          });
          this.on('compositionend', function() {
            composing = false;
            if (!lazy) {
              self.listener();
            }
          });
        }
        this.focused = false;
        if (!isRange) {
          this.on('focus', function() {
            self.focused = true;
          });
          this.on('blur', function() {
            self.focused = false;
            if (!self._frag || self._frag.inserted) {
              self.rawListener();
            }
          });
        }
        this.listener = this.rawListener = function() {
          if (composing || !self._bound) {
            return;
          }
          var val = number || isRange ? toNumber(el.value) : el.value;
          self.set(val);
          nextTick(function() {
            if (self._bound && !self.focused) {
              self.update(self._watcher.value);
            }
          });
        };
        if (debounce) {
          this.listener = _debounce(this.listener, debounce);
        }
        this.hasjQuery = typeof jQuery === 'function';
        if (this.hasjQuery) {
          jQuery(el).on('change', this.listener);
          if (!lazy) {
            jQuery(el).on('input', this.listener);
          }
        } else {
          this.on('change', this.listener);
          if (!lazy) {
            this.on('input', this.listener);
          }
        }
        if (!lazy && isIE9) {
          this.on('cut', function() {
            nextTick(self.listener);
          });
          this.on('keyup', function(e) {
            if (e.keyCode === 46 || e.keyCode === 8) {
              self.listener();
            }
          });
        }
        if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
          this.afterBind = this.listener;
        }
      },
      update: function update(value) {
        this.el.value = _toString(value);
      },
      unbind: function unbind() {
        var el = this.el;
        if (this.hasjQuery) {
          jQuery(el).off('change', this.listener);
          jQuery(el).off('input', this.listener);
        }
      }
    };
    var handlers = {
      text: text$2,
      radio: radio,
      select: select,
      checkbox: checkbox
    };
    var model = {
      priority: MODEL,
      twoWay: true,
      handlers: handlers,
      params: ['lazy', 'number', 'debounce'],
      bind: function bind() {
        this.checkFilters();
        if (this.hasRead && !this.hasWrite) {
          process.env.NODE_ENV !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model. You might want to use a two-way filter ' + 'to ensure correct behavior.');
        }
        var el = this.el;
        var tag = el.tagName;
        var handler;
        if (tag === 'INPUT') {
          handler = handlers[el.type] || handlers.text;
        } else if (tag === 'SELECT') {
          handler = handlers.select;
        } else if (tag === 'TEXTAREA') {
          handler = handlers.text;
        } else {
          process.env.NODE_ENV !== 'production' && warn('v-model does not support element type: ' + tag);
          return;
        }
        el.__v_model = this;
        handler.bind.call(this);
        this.update = handler.update;
        this._unbind = handler.unbind;
      },
      checkFilters: function checkFilters() {
        var filters = this.filters;
        if (!filters)
          return;
        var i = filters.length;
        while (i--) {
          var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
          if (typeof filter === 'function' || filter.read) {
            this.hasRead = true;
          }
          if (filter.write) {
            this.hasWrite = true;
          }
        }
      },
      unbind: function unbind() {
        this.el.__v_model = null;
        this._unbind && this._unbind();
      }
    };
    var show = {
      bind: function bind() {
        var next = this.el.nextElementSibling;
        if (next && getAttr(next, 'v-else') !== null) {
          this.elseEl = next;
        }
      },
      update: function update(value) {
        this.apply(this.el, value);
        if (this.elseEl) {
          this.apply(this.elseEl, !value);
        }
      },
      apply: function apply(el, value) {
        if (inDoc(el)) {
          applyTransition(el, value ? 1 : -1, toggle, this.vm);
        } else {
          toggle();
        }
        function toggle() {
          el.style.display = value ? '' : 'none';
        }
      }
    };
    var templateCache = new Cache(1000);
    var idSelectorCache = new Cache(1000);
    var map = {
      efault: [0, '', ''],
      legend: [1, '<fieldset>', '</fieldset>'],
      tr: [2, '<table><tbody>', '</tbody></table>'],
      col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
    };
    map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
    map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
    map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
    map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
    function isRealTemplate(node) {
      return isTemplate(node) && node.content instanceof DocumentFragment;
    }
    var tagRE$1 = /<([\w:]+)/;
    var entityRE = /&#?\w+?;/;
    function stringToFragment(templateString, raw) {
      var hit = templateCache.get(templateString);
      if (hit) {
        return hit;
      }
      var frag = document.createDocumentFragment();
      var tagMatch = templateString.match(tagRE$1);
      var entityMatch = entityRE.test(templateString);
      if (!tagMatch && !entityMatch) {
        frag.appendChild(document.createTextNode(templateString));
      } else {
        var tag = tagMatch && tagMatch[1];
        var wrap = map[tag] || map.efault;
        var depth = wrap[0];
        var prefix = wrap[1];
        var suffix = wrap[2];
        var node = document.createElement('div');
        if (!raw) {
          templateString = templateString.trim();
        }
        node.innerHTML = prefix + templateString + suffix;
        while (depth--) {
          node = node.lastChild;
        }
        var child;
        while (child = node.firstChild) {
          frag.appendChild(child);
        }
      }
      templateCache.put(templateString, frag);
      return frag;
    }
    function nodeToFragment(node) {
      if (isRealTemplate(node)) {
        trimNode(node.content);
        return node.content;
      }
      if (node.tagName === 'SCRIPT') {
        return stringToFragment(node.textContent);
      }
      var clonedNode = cloneNode(node);
      var frag = document.createDocumentFragment();
      var child;
      while (child = clonedNode.firstChild) {
        frag.appendChild(child);
      }
      trimNode(frag);
      return frag;
    }
    var hasBrokenTemplate = (function() {
      if (inBrowser) {
        var a = document.createElement('div');
        a.innerHTML = '<template>1</template>';
        return !a.cloneNode(true).firstChild.innerHTML;
      } else {
        return false;
      }
    })();
    var hasTextareaCloneBug = (function() {
      if (inBrowser) {
        var t = document.createElement('textarea');
        t.placeholder = 't';
        return t.cloneNode(true).value === 't';
      } else {
        return false;
      }
    })();
    function cloneNode(node) {
      if (!node.querySelectorAll) {
        return node.cloneNode();
      }
      var res = node.cloneNode(true);
      var i,
          original,
          cloned;
      if (hasBrokenTemplate) {
        var tempClone = res;
        if (isRealTemplate(node)) {
          node = node.content;
          tempClone = res.content;
        }
        original = node.querySelectorAll('template');
        if (original.length) {
          cloned = tempClone.querySelectorAll('template');
          i = cloned.length;
          while (i--) {
            cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
          }
        }
      }
      if (hasTextareaCloneBug) {
        if (node.tagName === 'TEXTAREA') {
          res.value = node.value;
        } else {
          original = node.querySelectorAll('textarea');
          if (original.length) {
            cloned = res.querySelectorAll('textarea');
            i = cloned.length;
            while (i--) {
              cloned[i].value = original[i].value;
            }
          }
        }
      }
      return res;
    }
    function parseTemplate(template, shouldClone, raw) {
      var node,
          frag;
      if (template instanceof DocumentFragment) {
        trimNode(template);
        return shouldClone ? cloneNode(template) : template;
      }
      if (typeof template === 'string') {
        if (!raw && template.charAt(0) === '#') {
          frag = idSelectorCache.get(template);
          if (!frag) {
            node = document.getElementById(template.slice(1));
            if (node) {
              frag = nodeToFragment(node);
              idSelectorCache.put(template, frag);
            }
          }
        } else {
          frag = stringToFragment(template, raw);
        }
      } else if (template.nodeType) {
        frag = nodeToFragment(template);
      }
      return frag && shouldClone ? cloneNode(frag) : frag;
    }
    var template = Object.freeze({
      cloneNode: cloneNode,
      parseTemplate: parseTemplate
    });
    function Fragment(linker, vm, frag, host, scope, parentFrag) {
      this.children = [];
      this.childFrags = [];
      this.vm = vm;
      this.scope = scope;
      this.inserted = false;
      this.parentFrag = parentFrag;
      if (parentFrag) {
        parentFrag.childFrags.push(this);
      }
      this.unlink = linker(vm, frag, host, scope, this);
      var single = this.single = frag.childNodes.length === 1 && !frag.childNodes[0].__vue_anchor;
      if (single) {
        this.node = frag.childNodes[0];
        this.before = singleBefore;
        this.remove = singleRemove;
      } else {
        this.node = createAnchor('fragment-start');
        this.end = createAnchor('fragment-end');
        this.frag = frag;
        prepend(this.node, frag);
        frag.appendChild(this.end);
        this.before = multiBefore;
        this.remove = multiRemove;
      }
      this.node.__vfrag__ = this;
    }
    Fragment.prototype.callHook = function(hook) {
      var i,
          l;
      for (i = 0, l = this.children.length; i < l; i++) {
        hook(this.children[i]);
      }
      for (i = 0, l = this.childFrags.length; i < l; i++) {
        this.childFrags[i].callHook(hook);
      }
    };
    Fragment.prototype.destroy = function() {
      if (this.parentFrag) {
        this.parentFrag.childFrags.$remove(this);
      }
      this.unlink();
    };
    function singleBefore(target, withTransition) {
      this.inserted = true;
      var method = withTransition !== false ? beforeWithTransition : before;
      method(this.node, target, this.vm);
      if (inDoc(this.node)) {
        this.callHook(attach);
      }
    }
    function singleRemove() {
      this.inserted = false;
      var shouldCallRemove = inDoc(this.node);
      var self = this;
      self.callHook(destroyChild);
      removeWithTransition(this.node, this.vm, function() {
        if (shouldCallRemove) {
          self.callHook(detach);
        }
        self.destroy();
      });
    }
    function multiBefore(target, withTransition) {
      this.inserted = true;
      var vm = this.vm;
      var method = withTransition !== false ? beforeWithTransition : before;
      mapNodeRange(this.node, this.end, function(node) {
        method(node, target, vm);
      });
      if (inDoc(this.node)) {
        this.callHook(attach);
      }
    }
    function multiRemove() {
      this.inserted = false;
      var self = this;
      var shouldCallRemove = inDoc(this.node);
      self.callHook(destroyChild);
      removeNodeRange(this.node, this.end, this.vm, this.frag, function() {
        if (shouldCallRemove) {
          self.callHook(detach);
        }
        self.destroy();
      });
    }
    function attach(child) {
      if (!child._isAttached) {
        child._callHook('attached');
      }
    }
    function destroyChild(child) {
      child.$destroy(false, true);
    }
    function detach(child) {
      if (child._isAttached) {
        child._callHook('detached');
      }
    }
    var linkerCache = new Cache(5000);
    function FragmentFactory(vm, el) {
      this.vm = vm;
      var template;
      var isString = typeof el === 'string';
      if (isString || isTemplate(el)) {
        template = parseTemplate(el, true);
      } else {
        template = document.createDocumentFragment();
        template.appendChild(el);
      }
      this.template = template;
      var linker;
      var cid = vm.constructor.cid;
      if (cid > 0) {
        var cacheId = cid + (isString ? el : el.outerHTML);
        linker = linkerCache.get(cacheId);
        if (!linker) {
          linker = compile(template, vm.$options, true);
          linkerCache.put(cacheId, linker);
        }
      } else {
        linker = compile(template, vm.$options, true);
      }
      this.linker = linker;
    }
    FragmentFactory.prototype.create = function(host, scope, parentFrag) {
      var frag = cloneNode(this.template);
      return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
    };
    var vIf = {
      priority: IF,
      bind: function bind() {
        var el = this.el;
        if (!el.__vue__) {
          var next = el.nextElementSibling;
          if (next && getAttr(next, 'v-else') !== null) {
            remove(next);
            this.elseFactory = new FragmentFactory(this.vm, next);
          }
          this.anchor = createAnchor('v-if');
          replace(el, this.anchor);
          this.factory = new FragmentFactory(this.vm, el);
        } else {
          process.env.NODE_ENV !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.');
          this.invalid = true;
        }
      },
      update: function update(value) {
        if (this.invalid)
          return;
        if (value) {
          if (!this.frag) {
            this.insert();
          }
        } else {
          this.remove();
        }
      },
      insert: function insert() {
        if (this.elseFrag) {
          this.elseFrag.remove();
          this.elseFrag = null;
        }
        this.frag = this.factory.create(this._host, this._scope, this._frag);
        this.frag.before(this.anchor);
      },
      remove: function remove() {
        if (this.frag) {
          this.frag.remove();
          this.frag = null;
        }
        if (this.elseFactory && !this.elseFrag) {
          this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
          this.elseFrag.before(this.anchor);
        }
      },
      unbind: function unbind() {
        if (this.frag) {
          this.frag.destroy();
        }
      }
    };
    var uid$1 = 0;
    var vFor = {
      priority: FOR,
      params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
      bind: function bind() {
        var inMatch = this.expression.match(/(.*) in (.*)/);
        if (inMatch) {
          var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
          if (itMatch) {
            this.iterator = itMatch[1].trim();
            this.alias = itMatch[2].trim();
          } else {
            this.alias = inMatch[1].trim();
          }
          this.expression = inMatch[2];
        }
        if (!this.alias) {
          process.env.NODE_ENV !== 'production' && warn('Alias is required in v-for.');
          return;
        }
        this.id = '__v-for__' + ++uid$1;
        var tag = this.el.tagName;
        this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
        this.start = createAnchor('v-for-start');
        this.end = createAnchor('v-for-end');
        replace(this.el, this.end);
        before(this.start, this.end);
        this.cache = Object.create(null);
        this.factory = new FragmentFactory(this.vm, this.el);
      },
      update: function update(data) {
        this.diff(data);
        this.updateRef();
        this.updateModel();
      },
      diff: function diff(data) {
        var item = data[0];
        var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
        var trackByKey = this.params.trackBy;
        var oldFrags = this.frags;
        var frags = this.frags = new Array(data.length);
        var alias = this.alias;
        var iterator = this.iterator;
        var start = this.start;
        var end = this.end;
        var inDocument = inDoc(start);
        var init = !oldFrags;
        var i,
            l,
            frag,
            key,
            value,
            primitive;
        for (i = 0, l = data.length; i < l; i++) {
          item = data[i];
          key = convertedFromObject ? item.$key : null;
          value = convertedFromObject ? item.$value : item;
          primitive = !isObject(value);
          frag = !init && this.getCachedFrag(value, i, key);
          if (frag) {
            frag.reused = true;
            frag.scope.$index = i;
            if (key) {
              frag.scope.$key = key;
            }
            if (iterator) {
              frag.scope[iterator] = key !== null ? key : i;
            }
            if (trackByKey || convertedFromObject || primitive) {
              frag.scope[alias] = value;
            }
          } else {
            frag = this.create(value, alias, i, key);
            frag.fresh = !init;
          }
          frags[i] = frag;
          if (init) {
            frag.before(end);
          }
        }
        if (init) {
          return;
        }
        var removalIndex = 0;
        var totalRemoved = oldFrags.length - frags.length;
        for (i = 0, l = oldFrags.length; i < l; i++) {
          frag = oldFrags[i];
          if (!frag.reused) {
            this.deleteCachedFrag(frag);
            this.remove(frag, removalIndex++, totalRemoved, inDocument);
          }
        }
        var targetPrev,
            prevEl,
            currentPrev;
        var insertionIndex = 0;
        for (i = 0, l = frags.length; i < l; i++) {
          frag = frags[i];
          targetPrev = frags[i - 1];
          prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
          if (frag.reused && !frag.staggerCb) {
            currentPrev = findPrevFrag(frag, start, this.id);
            if (currentPrev !== targetPrev && (!currentPrev || findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
              this.move(frag, prevEl);
            }
          } else {
            this.insert(frag, insertionIndex++, prevEl, inDocument);
          }
          frag.reused = frag.fresh = false;
        }
      },
      create: function create(value, alias, index, key) {
        var host = this._host;
        var parentScope = this._scope || this.vm;
        var scope = Object.create(parentScope);
        scope.$refs = Object.create(parentScope.$refs);
        scope.$els = Object.create(parentScope.$els);
        scope.$parent = parentScope;
        scope.$forContext = this;
        defineReactive(scope, alias, value);
        defineReactive(scope, '$index', index);
        if (key) {
          defineReactive(scope, '$key', key);
        } else if (scope.$key) {
          def(scope, '$key', null);
        }
        if (this.iterator) {
          defineReactive(scope, this.iterator, key !== null ? key : index);
        }
        var frag = this.factory.create(host, scope, this._frag);
        frag.forId = this.id;
        this.cacheFrag(value, frag, index, key);
        return frag;
      },
      updateRef: function updateRef() {
        var ref = this.descriptor.ref;
        if (!ref)
          return;
        var hash = (this._scope || this.vm).$refs;
        var refs;
        if (!this.fromObject) {
          refs = this.frags.map(findVmFromFrag);
        } else {
          refs = {};
          this.frags.forEach(function(frag) {
            refs[frag.scope.$key] = findVmFromFrag(frag);
          });
        }
        hash[ref] = refs;
      },
      updateModel: function updateModel() {
        if (this.isOption) {
          var parent = this.start.parentNode;
          var model = parent && parent.__v_model;
          if (model) {
            model.forceUpdate();
          }
        }
      },
      insert: function insert(frag, index, prevEl, inDocument) {
        if (frag.staggerCb) {
          frag.staggerCb.cancel();
          frag.staggerCb = null;
        }
        var staggerAmount = this.getStagger(frag, index, null, 'enter');
        if (inDocument && staggerAmount) {
          var anchor = frag.staggerAnchor;
          if (!anchor) {
            anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
            anchor.__vfrag__ = frag;
          }
          after(anchor, prevEl);
          var op = frag.staggerCb = cancellable(function() {
            frag.staggerCb = null;
            frag.before(anchor);
            remove(anchor);
          });
          setTimeout(op, staggerAmount);
        } else {
          frag.before(prevEl.nextSibling);
        }
      },
      remove: function remove(frag, index, total, inDocument) {
        if (frag.staggerCb) {
          frag.staggerCb.cancel();
          frag.staggerCb = null;
          return;
        }
        var staggerAmount = this.getStagger(frag, index, total, 'leave');
        if (inDocument && staggerAmount) {
          var op = frag.staggerCb = cancellable(function() {
            frag.staggerCb = null;
            frag.remove();
          });
          setTimeout(op, staggerAmount);
        } else {
          frag.remove();
        }
      },
      move: function move(frag, prevEl) {
        frag.before(prevEl.nextSibling, false);
      },
      cacheFrag: function cacheFrag(value, frag, index, key) {
        var trackByKey = this.params.trackBy;
        var cache = this.cache;
        var primitive = !isObject(value);
        var id;
        if (key || trackByKey || primitive) {
          id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
          if (!cache[id]) {
            cache[id] = frag;
          } else if (trackByKey !== '$index') {
            process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
          }
        } else {
          id = this.id;
          if (hasOwn(value, id)) {
            if (value[id] === null) {
              value[id] = frag;
            } else {
              process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
            }
          } else {
            def(value, id, frag);
          }
        }
        frag.raw = value;
      },
      getCachedFrag: function getCachedFrag(value, index, key) {
        var trackByKey = this.params.trackBy;
        var primitive = !isObject(value);
        var frag;
        if (key || trackByKey || primitive) {
          var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
          frag = this.cache[id];
        } else {
          frag = value[this.id];
        }
        if (frag && (frag.reused || frag.fresh)) {
          process.env.NODE_ENV !== 'production' && this.warnDuplicate(value);
        }
        return frag;
      },
      deleteCachedFrag: function deleteCachedFrag(frag) {
        var value = frag.raw;
        var trackByKey = this.params.trackBy;
        var scope = frag.scope;
        var index = scope.$index;
        var key = hasOwn(scope, '$key') && scope.$key;
        var primitive = !isObject(value);
        if (trackByKey || key || primitive) {
          var id = trackByKey ? trackByKey === '$index' ? index : value[trackByKey] : key || value;
          this.cache[id] = null;
        } else {
          value[this.id] = null;
          frag.raw = null;
        }
      },
      getStagger: function getStagger(frag, index, total, type) {
        type = type + 'Stagger';
        var trans = frag.node.__v_trans;
        var hooks = trans && trans.hooks;
        var hook = hooks && (hooks[type] || hooks.stagger);
        return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
      },
      _preProcess: function _preProcess(value) {
        this.rawValue = value;
        return value;
      },
      _postProcess: function _postProcess(value) {
        if (isArray(value)) {
          return value;
        } else if (isPlainObject(value)) {
          var keys = Object.keys(value);
          var i = keys.length;
          var res = new Array(i);
          var key;
          while (i--) {
            key = keys[i];
            res[i] = {
              $key: key,
              $value: value[key]
            };
          }
          return res;
        } else {
          if (typeof value === 'number') {
            value = range(value);
          }
          return value || [];
        }
      },
      unbind: function unbind() {
        if (this.descriptor.ref) {
          (this._scope || this.vm).$refs[this.descriptor.ref] = null;
        }
        if (this.frags) {
          var i = this.frags.length;
          var frag;
          while (i--) {
            frag = this.frags[i];
            this.deleteCachedFrag(frag);
            frag.destroy();
          }
        }
      }
    };
    function findPrevFrag(frag, anchor, id) {
      var el = frag.node.previousSibling;
      if (!el)
        return;
      frag = el.__vfrag__;
      while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
        el = el.previousSibling;
        if (!el)
          return;
        frag = el.__vfrag__;
      }
      return frag;
    }
    function findVmFromFrag(frag) {
      var node = frag.node;
      if (frag.end) {
        while (!node.__vue__ && node !== frag.end && node.nextSibling) {
          node = node.nextSibling;
        }
      }
      return node.__vue__;
    }
    function range(n) {
      var i = -1;
      var ret = new Array(n);
      while (++i < n) {
        ret[i] = i;
      }
      return ret;
    }
    if (process.env.NODE_ENV !== 'production') {
      vFor.warnDuplicate = function(value) {
        warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.');
      };
    }
    var html = {
      bind: function bind() {
        if (this.el.nodeType === 8) {
          this.nodes = [];
          this.anchor = createAnchor('v-html');
          replace(this.el, this.anchor);
        }
      },
      update: function update(value) {
        value = _toString(value);
        if (this.nodes) {
          this.swap(value);
        } else {
          this.el.innerHTML = value;
        }
      },
      swap: function swap(value) {
        var i = this.nodes.length;
        while (i--) {
          remove(this.nodes[i]);
        }
        var frag = parseTemplate(value, true, true);
        this.nodes = toArray(frag.childNodes);
        before(frag, this.anchor);
      }
    };
    var text = {
      bind: function bind() {
        this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
      },
      update: function update(value) {
        this.el[this.attr] = _toString(value);
      }
    };
    var publicDirectives = {
      text: text,
      html: html,
      'for': vFor,
      'if': vIf,
      show: show,
      model: model,
      on: on,
      bind: bind,
      el: el,
      ref: ref,
      cloak: cloak
    };
    var queue$1 = [];
    var queued = false;
    function pushJob(job) {
      queue$1.push(job);
      if (!queued) {
        queued = true;
        nextTick(flush);
      }
    }
    function flush() {
      var f = document.documentElement.offsetHeight;
      for (var i = 0; i < queue$1.length; i++) {
        queue$1[i]();
      }
      queue$1 = [];
      queued = false;
      return f;
    }
    var TYPE_TRANSITION = 1;
    var TYPE_ANIMATION = 2;
    var transDurationProp = transitionProp + 'Duration';
    var animDurationProp = animationProp + 'Duration';
    function Transition(el, id, hooks, vm) {
      this.id = id;
      this.el = el;
      this.enterClass = id + '-enter';
      this.leaveClass = id + '-leave';
      this.hooks = hooks;
      this.vm = vm;
      this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
      this.justEntered = false;
      this.entered = this.left = false;
      this.typeCache = {};
      var self = this;
      ['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function(m) {
        self[m] = bind$1(self[m], self);
      });
    }
    var p$1 = Transition.prototype;
    p$1.enter = function(op, cb) {
      this.cancelPending();
      this.callHook('beforeEnter');
      this.cb = cb;
      addClass(this.el, this.enterClass);
      op();
      this.entered = false;
      this.callHookWithCb('enter');
      if (this.entered) {
        return;
      }
      this.cancel = this.hooks && this.hooks.enterCancelled;
      pushJob(this.enterNextTick);
    };
    p$1.enterNextTick = function() {
      this.justEntered = true;
      var self = this;
      setTimeout(function() {
        self.justEntered = false;
      }, 17);
      var enterDone = this.enterDone;
      var type = this.getCssTransitionType(this.enterClass);
      if (!this.pendingJsCb) {
        if (type === TYPE_TRANSITION) {
          removeClass(this.el, this.enterClass);
          this.setupCssCb(transitionEndEvent, enterDone);
        } else if (type === TYPE_ANIMATION) {
          this.setupCssCb(animationEndEvent, enterDone);
        } else {
          enterDone();
        }
      } else if (type === TYPE_TRANSITION) {
        removeClass(this.el, this.enterClass);
      }
    };
    p$1.enterDone = function() {
      this.entered = true;
      this.cancel = this.pendingJsCb = null;
      removeClass(this.el, this.enterClass);
      this.callHook('afterEnter');
      if (this.cb)
        this.cb();
    };
    p$1.leave = function(op, cb) {
      this.cancelPending();
      this.callHook('beforeLeave');
      this.op = op;
      this.cb = cb;
      addClass(this.el, this.leaveClass);
      this.left = false;
      this.callHookWithCb('leave');
      if (this.left) {
        return;
      }
      this.cancel = this.hooks && this.hooks.leaveCancelled;
      if (this.op && !this.pendingJsCb) {
        if (this.justEntered) {
          this.leaveDone();
        } else {
          pushJob(this.leaveNextTick);
        }
      }
    };
    p$1.leaveNextTick = function() {
      var type = this.getCssTransitionType(this.leaveClass);
      if (type) {
        var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
        this.setupCssCb(event, this.leaveDone);
      } else {
        this.leaveDone();
      }
    };
    p$1.leaveDone = function() {
      this.left = true;
      this.cancel = this.pendingJsCb = null;
      this.op();
      removeClass(this.el, this.leaveClass);
      this.callHook('afterLeave');
      if (this.cb)
        this.cb();
      this.op = null;
    };
    p$1.cancelPending = function() {
      this.op = this.cb = null;
      var hasPending = false;
      if (this.pendingCssCb) {
        hasPending = true;
        off(this.el, this.pendingCssEvent, this.pendingCssCb);
        this.pendingCssEvent = this.pendingCssCb = null;
      }
      if (this.pendingJsCb) {
        hasPending = true;
        this.pendingJsCb.cancel();
        this.pendingJsCb = null;
      }
      if (hasPending) {
        removeClass(this.el, this.enterClass);
        removeClass(this.el, this.leaveClass);
      }
      if (this.cancel) {
        this.cancel.call(this.vm, this.el);
        this.cancel = null;
      }
    };
    p$1.callHook = function(type) {
      if (this.hooks && this.hooks[type]) {
        this.hooks[type].call(this.vm, this.el);
      }
    };
    p$1.callHookWithCb = function(type) {
      var hook = this.hooks && this.hooks[type];
      if (hook) {
        if (hook.length > 1) {
          this.pendingJsCb = cancellable(this[type + 'Done']);
        }
        hook.call(this.vm, this.el, this.pendingJsCb);
      }
    };
    p$1.getCssTransitionType = function(className) {
      if (!transitionEndEvent || document.hidden || this.hooks && this.hooks.css === false || isHidden(this.el)) {
        return;
      }
      var type = this.typeCache[className];
      if (type)
        return type;
      var inlineStyles = this.el.style;
      var computedStyles = window.getComputedStyle(this.el);
      var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
      if (transDuration && transDuration !== '0s') {
        type = TYPE_TRANSITION;
      } else {
        var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
        if (animDuration && animDuration !== '0s') {
          type = TYPE_ANIMATION;
        }
      }
      if (type) {
        this.typeCache[className] = type;
      }
      return type;
    };
    p$1.setupCssCb = function(event, cb) {
      this.pendingCssEvent = event;
      var self = this;
      var el = this.el;
      var onEnd = this.pendingCssCb = function(e) {
        if (e.target === el) {
          off(el, event, onEnd);
          self.pendingCssEvent = self.pendingCssCb = null;
          if (!self.pendingJsCb && cb) {
            cb();
          }
        }
      };
      on$1(el, event, onEnd);
    };
    function isHidden(el) {
      return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
    }
    var transition = {
      priority: TRANSITION,
      update: function update(id, oldId) {
        var el = this.el;
        var hooks = resolveAsset(this.vm.$options, 'transitions', id);
        id = id || 'v';
        el.__v_trans = new Transition(el, id, hooks, this.el.__vue__ || this.vm);
        if (oldId) {
          removeClass(el, oldId + '-transition');
        }
        addClass(el, id + '-transition');
      }
    };
    var bindingModes = config._propBindingModes;
    var propDef = {
      bind: function bind() {
        var child = this.vm;
        var parent = child._context;
        var prop = this.descriptor.prop;
        var childKey = prop.path;
        var parentKey = prop.parentPath;
        var twoWay = prop.mode === bindingModes.TWO_WAY;
        var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function(val) {
          val = coerceProp(prop, val);
          if (assertProp(prop, val)) {
            child[childKey] = val;
          }
        }, {
          twoWay: twoWay,
          filters: prop.filters,
          scope: this._scope
        });
        initProp(child, prop, parentWatcher.value);
        if (twoWay) {
          var self = this;
          child.$once('pre-hook:created', function() {
            self.childWatcher = new Watcher(child, childKey, function(val) {
              parentWatcher.set(val);
            }, {sync: true});
          });
        }
      },
      unbind: function unbind() {
        this.parentWatcher.teardown();
        if (this.childWatcher) {
          this.childWatcher.teardown();
        }
      }
    };
    var component = {
      priority: COMPONENT,
      params: ['keep-alive', 'transition-mode', 'inline-template'],
      bind: function bind() {
        if (!this.el.__vue__) {
          this.keepAlive = this.params.keepAlive;
          if (this.keepAlive) {
            this.cache = {};
          }
          if (this.params.inlineTemplate) {
            this.inlineTemplate = extractContent(this.el, true);
          }
          this.pendingComponentCb = this.Component = null;
          this.pendingRemovals = 0;
          this.pendingRemovalCb = null;
          this.anchor = createAnchor('v-component');
          replace(this.el, this.anchor);
          this.el.removeAttribute('is');
          if (this.descriptor.ref) {
            this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
          }
          if (this.literal) {
            this.setComponent(this.expression);
          }
        } else {
          process.env.NODE_ENV !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
        }
      },
      update: function update(value) {
        if (!this.literal) {
          this.setComponent(value);
        }
      },
      setComponent: function setComponent(value, cb) {
        this.invalidatePending();
        if (!value) {
          this.unbuild(true);
          this.remove(this.childVM, cb);
          this.childVM = null;
        } else {
          var self = this;
          this.resolveComponent(value, function() {
            self.mountComponent(cb);
          });
        }
      },
      resolveComponent: function resolveComponent(id, cb) {
        var self = this;
        this.pendingComponentCb = cancellable(function(Component) {
          self.ComponentName = Component.options.name || id;
          self.Component = Component;
          cb();
        });
        this.vm._resolveComponent(id, this.pendingComponentCb);
      },
      mountComponent: function mountComponent(cb) {
        this.unbuild(true);
        var self = this;
        var activateHook = this.Component.options.activate;
        var cached = this.getCached();
        var newComponent = this.build();
        if (activateHook && !cached) {
          this.waitingFor = newComponent;
          activateHook.call(newComponent, function() {
            if (self.waitingFor !== newComponent) {
              return;
            }
            self.waitingFor = null;
            self.transition(newComponent, cb);
          });
        } else {
          if (cached) {
            newComponent._updateRef();
          }
          this.transition(newComponent, cb);
        }
      },
      invalidatePending: function invalidatePending() {
        if (this.pendingComponentCb) {
          this.pendingComponentCb.cancel();
          this.pendingComponentCb = null;
        }
      },
      build: function build(extraOptions) {
        var cached = this.getCached();
        if (cached) {
          return cached;
        }
        if (this.Component) {
          var options = {
            name: this.ComponentName,
            el: cloneNode(this.el),
            template: this.inlineTemplate,
            parent: this._host || this.vm,
            _linkerCachable: !this.inlineTemplate,
            _ref: this.descriptor.ref,
            _asComponent: true,
            _isRouterView: this._isRouterView,
            _context: this.vm,
            _scope: this._scope,
            _frag: this._frag
          };
          if (extraOptions) {
            extend(options, extraOptions);
          }
          var child = new this.Component(options);
          if (this.keepAlive) {
            this.cache[this.Component.cid] = child;
          }
          if (process.env.NODE_ENV !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
            warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template);
          }
          return child;
        }
      },
      getCached: function getCached() {
        return this.keepAlive && this.cache[this.Component.cid];
      },
      unbuild: function unbuild(defer) {
        if (this.waitingFor) {
          this.waitingFor.$destroy();
          this.waitingFor = null;
        }
        var child = this.childVM;
        if (!child || this.keepAlive) {
          if (child) {
            child._updateRef(true);
          }
          return;
        }
        child.$destroy(false, defer);
      },
      remove: function remove(child, cb) {
        var keepAlive = this.keepAlive;
        if (child) {
          this.pendingRemovals++;
          this.pendingRemovalCb = cb;
          var self = this;
          child.$remove(function() {
            self.pendingRemovals--;
            if (!keepAlive)
              child._cleanup();
            if (!self.pendingRemovals && self.pendingRemovalCb) {
              self.pendingRemovalCb();
              self.pendingRemovalCb = null;
            }
          });
        } else if (cb) {
          cb();
        }
      },
      transition: function transition(target, cb) {
        var self = this;
        var current = this.childVM;
        if (process.env.NODE_ENV !== 'production') {
          if (current)
            current._inactive = true;
          target._inactive = false;
        }
        this.childVM = target;
        switch (self.params.transitionMode) {
          case 'in-out':
            target.$before(self.anchor, function() {
              self.remove(current, cb);
            });
            break;
          case 'out-in':
            self.remove(current, function() {
              target.$before(self.anchor, cb);
            });
            break;
          default:
            self.remove(current);
            target.$before(self.anchor, cb);
        }
      },
      unbind: function unbind() {
        this.invalidatePending();
        this.unbuild();
        if (this.cache) {
          for (var key in this.cache) {
            this.cache[key].$destroy();
          }
          this.cache = null;
        }
      }
    };
    var vClass = {
      deep: true,
      update: function update(value) {
        if (value && typeof value === 'string') {
          this.handleObject(stringToObject(value));
        } else if (isPlainObject(value)) {
          this.handleObject(value);
        } else if (isArray(value)) {
          this.handleArray(value);
        } else {
          this.cleanup();
        }
      },
      handleObject: function handleObject(value) {
        this.cleanup(value);
        var keys = this.prevKeys = Object.keys(value);
        for (var i = 0,
            l = keys.length; i < l; i++) {
          var key = keys[i];
          if (value[key]) {
            addClass(this.el, key);
          } else {
            removeClass(this.el, key);
          }
        }
      },
      handleArray: function handleArray(value) {
        this.cleanup(value);
        for (var i = 0,
            l = value.length; i < l; i++) {
          if (value[i]) {
            addClass(this.el, value[i]);
          }
        }
        this.prevKeys = value.slice();
      },
      cleanup: function cleanup(value) {
        if (this.prevKeys) {
          var i = this.prevKeys.length;
          while (i--) {
            var key = this.prevKeys[i];
            if (key && (!value || !contains$1(value, key))) {
              removeClass(this.el, key);
            }
          }
        }
      }
    };
    function stringToObject(value) {
      var res = {};
      var keys = value.trim().split(/\s+/);
      var i = keys.length;
      while (i--) {
        res[keys[i]] = true;
      }
      return res;
    }
    function contains$1(value, key) {
      return isArray(value) ? value.indexOf(key) > -1 : hasOwn(value, key);
    }
    var internalDirectives = {
      style: style,
      'class': vClass,
      component: component,
      prop: propDef,
      transition: transition
    };
    var propBindingModes = config._propBindingModes;
    var empty = {};
    var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
    var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
    function compileProps(el, propOptions) {
      var props = [];
      var names = Object.keys(propOptions);
      var i = names.length;
      var options,
          name,
          attr,
          value,
          path,
          parsed,
          prop;
      while (i--) {
        name = names[i];
        options = propOptions[name] || empty;
        if (process.env.NODE_ENV !== 'production' && name === '$data') {
          warn('Do not use $data as prop.');
          continue;
        }
        path = camelize(name);
        if (!identRE$1.test(path)) {
          process.env.NODE_ENV !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.');
          continue;
        }
        prop = {
          name: name,
          path: path,
          options: options,
          mode: propBindingModes.ONE_WAY,
          raw: null
        };
        attr = hyphenate(name);
        if ((value = getBindAttr(el, attr)) === null) {
          if ((value = getBindAttr(el, attr + '.sync')) !== null) {
            prop.mode = propBindingModes.TWO_WAY;
          } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
            prop.mode = propBindingModes.ONE_TIME;
          }
        }
        if (value !== null) {
          prop.raw = value;
          parsed = parseDirective(value);
          value = parsed.expression;
          prop.filters = parsed.filters;
          if (isLiteral(value)) {
            prop.optimizedLiteral = true;
          } else {
            prop.dynamic = true;
            if (process.env.NODE_ENV !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
              prop.mode = propBindingModes.ONE_WAY;
              warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value);
            }
          }
          prop.parentPath = value;
          if (process.env.NODE_ENV !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
            warn('Prop "' + name + '" expects a two-way binding type.');
          }
        } else if ((value = getAttr(el, attr)) !== null) {
          prop.raw = value;
        } else if (options.required) {
          process.env.NODE_ENV !== 'production' && warn('Missing required prop: ' + name);
        }
        props.push(prop);
      }
      return makePropsLinkFn(props);
    }
    function makePropsLinkFn(props) {
      return function propsLinkFn(vm, scope) {
        vm._props = {};
        var i = props.length;
        var prop,
            path,
            options,
            value,
            raw;
        while (i--) {
          prop = props[i];
          raw = prop.raw;
          path = prop.path;
          options = prop.options;
          vm._props[path] = prop;
          if (raw === null) {
            initProp(vm, prop, getDefault(vm, options));
          } else if (prop.dynamic) {
            if (vm._context) {
              if (prop.mode === propBindingModes.ONE_TIME) {
                value = (scope || vm._context).$get(prop.parentPath);
                initProp(vm, prop, value);
              } else {
                vm._bindDir({
                  name: 'prop',
                  def: propDef,
                  prop: prop
                }, null, null, scope);
              }
            } else {
              process.env.NODE_ENV !== 'production' && warn('Cannot bind dynamic prop on a root instance' + ' with no parent: ' + prop.name + '="' + raw + '"');
            }
          } else if (prop.optimizedLiteral) {
            var stripped = stripQuotes(raw);
            value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
            initProp(vm, prop, value);
          } else {
            value = options.type === Boolean && raw === '' ? true : raw;
            initProp(vm, prop, value);
          }
        }
      };
    }
    function getDefault(vm, options) {
      if (!hasOwn(options, 'default')) {
        return options.type === Boolean ? false : undefined;
      }
      var def = options['default'];
      if (isObject(def)) {
        process.env.NODE_ENV !== 'production' && warn('Object/Array as default prop values will be shared ' + 'across multiple instances. Use a factory function ' + 'to return the default value instead.');
      }
      return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
    }
    var bindRE = /^v-bind:|^:/;
    var onRE = /^v-on:|^@/;
    var argRE = /:(.*)$/;
    var modifierRE = /\.[^\.]+/g;
    var transitionRE = /^(v-bind:|:)?transition$/;
    var terminalDirectives = ['for', 'if'];
    var DEFAULT_PRIORITY = 1000;
    function compile(el, options, partial) {
      var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
      var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && el.tagName !== 'SCRIPT' && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
      return function compositeLinkFn(vm, el, host, scope, frag) {
        var childNodes = toArray(el.childNodes);
        var dirs = linkAndCapture(function compositeLinkCapturer() {
          if (nodeLinkFn)
            nodeLinkFn(vm, el, host, scope, frag);
          if (childLinkFn)
            childLinkFn(vm, childNodes, host, scope, frag);
        }, vm);
        return makeUnlinkFn(vm, dirs);
      };
    }
    function linkAndCapture(linker, vm) {
      var originalDirCount = vm._directives.length;
      linker();
      var dirs = vm._directives.slice(originalDirCount);
      dirs.sort(directiveComparator);
      for (var i = 0,
          l = dirs.length; i < l; i++) {
        dirs[i]._bind();
      }
      return dirs;
    }
    function directiveComparator(a, b) {
      a = a.descriptor.def.priority || DEFAULT_PRIORITY;
      b = b.descriptor.def.priority || DEFAULT_PRIORITY;
      return a > b ? -1 : a === b ? 0 : 1;
    }
    function makeUnlinkFn(vm, dirs, context, contextDirs) {
      return function unlink(destroying) {
        teardownDirs(vm, dirs, destroying);
        if (context && contextDirs) {
          teardownDirs(context, contextDirs);
        }
      };
    }
    function teardownDirs(vm, dirs, destroying) {
      var i = dirs.length;
      while (i--) {
        dirs[i]._teardown();
        if (!destroying) {
          vm._directives.$remove(dirs[i]);
        }
      }
    }
    function compileAndLinkProps(vm, el, props, scope) {
      var propsLinkFn = compileProps(el, props);
      var propDirs = linkAndCapture(function() {
        propsLinkFn(vm, scope);
      }, vm);
      return makeUnlinkFn(vm, propDirs);
    }
    function compileRoot(el, options, contextOptions) {
      var containerAttrs = options._containerAttrs;
      var replacerAttrs = options._replacerAttrs;
      var contextLinkFn,
          replacerLinkFn;
      if (el.nodeType !== 11) {
        if (options._asComponent) {
          if (containerAttrs && contextOptions) {
            contextLinkFn = compileDirectives(containerAttrs, contextOptions);
          }
          if (replacerAttrs) {
            replacerLinkFn = compileDirectives(replacerAttrs, options);
          }
        } else {
          replacerLinkFn = compileDirectives(el.attributes, options);
        }
      } else if (process.env.NODE_ENV !== 'production' && containerAttrs) {
        var names = containerAttrs.filter(function(attr) {
          return attr.name.indexOf('_v-') < 0 && !onRE.test(attr.name) && attr.name !== 'slot';
        }).map(function(attr) {
          return '"' + attr.name + '"';
        });
        if (names.length) {
          var plural = names.length > 1;
          warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment_Instance');
        }
      }
      return function rootLinkFn(vm, el, scope) {
        var context = vm._context;
        var contextDirs;
        if (context && contextLinkFn) {
          contextDirs = linkAndCapture(function() {
            contextLinkFn(context, el, null, scope);
          }, context);
        }
        var selfDirs = linkAndCapture(function() {
          if (replacerLinkFn)
            replacerLinkFn(vm, el);
        }, vm);
        return makeUnlinkFn(vm, selfDirs, context, contextDirs);
      };
    }
    function compileNode(node, options) {
      var type = node.nodeType;
      if (type === 1 && node.tagName !== 'SCRIPT') {
        return compileElement(node, options);
      } else if (type === 3 && node.data.trim()) {
        return compileTextNode(node, options);
      } else {
        return null;
      }
    }
    function compileElement(el, options) {
      if (el.tagName === 'TEXTAREA') {
        var tokens = parseText(el.value);
        if (tokens) {
          el.setAttribute(':value', tokensToExp(tokens));
          el.value = '';
        }
      }
      var linkFn;
      var hasAttrs = el.hasAttributes();
      if (hasAttrs) {
        linkFn = checkTerminalDirectives(el, options);
      }
      if (!linkFn) {
        linkFn = checkElementDirectives(el, options);
      }
      if (!linkFn) {
        linkFn = checkComponent(el, options);
      }
      if (!linkFn && hasAttrs) {
        linkFn = compileDirectives(el.attributes, options);
      }
      return linkFn;
    }
    function compileTextNode(node, options) {
      if (node._skip) {
        return removeText;
      }
      var tokens = parseText(node.wholeText);
      if (!tokens) {
        return null;
      }
      var next = node.nextSibling;
      while (next && next.nodeType === 3) {
        next._skip = true;
        next = next.nextSibling;
      }
      var frag = document.createDocumentFragment();
      var el,
          token;
      for (var i = 0,
          l = tokens.length; i < l; i++) {
        token = tokens[i];
        el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
        frag.appendChild(el);
      }
      return makeTextNodeLinkFn(tokens, frag, options);
    }
    function removeText(vm, node) {
      remove(node);
    }
    function processTextToken(token, options) {
      var el;
      if (token.oneTime) {
        el = document.createTextNode(token.value);
      } else {
        if (token.html) {
          el = document.createComment('v-html');
          setTokenType('html');
        } else {
          el = document.createTextNode(' ');
          setTokenType('text');
        }
      }
      function setTokenType(type) {
        if (token.descriptor)
          return;
        var parsed = parseDirective(token.value);
        token.descriptor = {
          name: type,
          def: publicDirectives[type],
          expression: parsed.expression,
          filters: parsed.filters
        };
      }
      return el;
    }
    function makeTextNodeLinkFn(tokens, frag) {
      return function textNodeLinkFn(vm, el, host, scope) {
        var fragClone = frag.cloneNode(true);
        var childNodes = toArray(fragClone.childNodes);
        var token,
            value,
            node;
        for (var i = 0,
            l = tokens.length; i < l; i++) {
          token = tokens[i];
          value = token.value;
          if (token.tag) {
            node = childNodes[i];
            if (token.oneTime) {
              value = (scope || vm).$eval(value);
              if (token.html) {
                replace(node, parseTemplate(value, true));
              } else {
                node.data = value;
              }
            } else {
              vm._bindDir(token.descriptor, node, host, scope);
            }
          }
        }
        replace(el, fragClone);
      };
    }
    function compileNodeList(nodeList, options) {
      var linkFns = [];
      var nodeLinkFn,
          childLinkFn,
          node;
      for (var i = 0,
          l = nodeList.length; i < l; i++) {
        node = nodeList[i];
        nodeLinkFn = compileNode(node, options);
        childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
        linkFns.push(nodeLinkFn, childLinkFn);
      }
      return linkFns.length ? makeChildLinkFn(linkFns) : null;
    }
    function makeChildLinkFn(linkFns) {
      return function childLinkFn(vm, nodes, host, scope, frag) {
        var node,
            nodeLinkFn,
            childrenLinkFn;
        for (var i = 0,
            n = 0,
            l = linkFns.length; i < l; n++) {
          node = nodes[n];
          nodeLinkFn = linkFns[i++];
          childrenLinkFn = linkFns[i++];
          var childNodes = toArray(node.childNodes);
          if (nodeLinkFn) {
            nodeLinkFn(vm, node, host, scope, frag);
          }
          if (childrenLinkFn) {
            childrenLinkFn(vm, childNodes, host, scope, frag);
          }
        }
      };
    }
    function checkElementDirectives(el, options) {
      var tag = el.tagName.toLowerCase();
      if (commonTagRE.test(tag))
        return;
      if (tag === 'slot' && hasBindAttr(el, 'name')) {
        tag = '_namedSlot';
      }
      var def = resolveAsset(options, 'elementDirectives', tag);
      if (def) {
        return makeTerminalNodeLinkFn(el, tag, '', options, def);
      }
    }
    function checkComponent(el, options) {
      var component = checkComponentAttr(el, options);
      if (component) {
        var ref = findRef(el);
        var descriptor = {
          name: 'component',
          ref: ref,
          expression: component.id,
          def: internalDirectives.component,
          modifiers: {literal: !component.dynamic}
        };
        var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
          if (ref) {
            defineReactive((scope || vm).$refs, ref, null);
          }
          vm._bindDir(descriptor, el, host, scope, frag);
        };
        componentLinkFn.terminal = true;
        return componentLinkFn;
      }
    }
    function checkTerminalDirectives(el, options) {
      if (getAttr(el, 'v-pre') !== null) {
        return skip;
      }
      if (el.hasAttribute('v-else')) {
        var prev = el.previousElementSibling;
        if (prev && prev.hasAttribute('v-if')) {
          return skip;
        }
      }
      var value,
          dirName;
      for (var i = 0,
          l = terminalDirectives.length; i < l; i++) {
        dirName = terminalDirectives[i];
        if (value = el.getAttribute('v-' + dirName)) {
          return makeTerminalNodeLinkFn(el, dirName, value, options);
        }
      }
    }
    function skip() {}
    skip.terminal = true;
    function makeTerminalNodeLinkFn(el, dirName, value, options, def) {
      var parsed = parseDirective(value);
      var descriptor = {
        name: dirName,
        expression: parsed.expression,
        filters: parsed.filters,
        raw: value,
        def: def || publicDirectives[dirName]
      };
      if (dirName === 'for' || dirName === 'router-view') {
        descriptor.ref = findRef(el);
      }
      var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
        if (descriptor.ref) {
          defineReactive((scope || vm).$refs, descriptor.ref, null);
        }
        vm._bindDir(descriptor, el, host, scope, frag);
      };
      fn.terminal = true;
      return fn;
    }
    function compileDirectives(attrs, options) {
      var i = attrs.length;
      var dirs = [];
      var attr,
          name,
          value,
          rawName,
          rawValue,
          dirName,
          arg,
          modifiers,
          dirDef,
          tokens;
      while (i--) {
        attr = attrs[i];
        name = rawName = attr.name;
        value = rawValue = attr.value;
        tokens = parseText(value);
        arg = null;
        modifiers = parseModifiers(name);
        name = name.replace(modifierRE, '');
        if (tokens) {
          value = tokensToExp(tokens);
          arg = name;
          pushDir('bind', publicDirectives.bind, true);
          if (process.env.NODE_ENV !== 'production') {
            if (name === 'class' && Array.prototype.some.call(attrs, function(attr) {
              return attr.name === ':class' || attr.name === 'v-bind:class';
            })) {
              warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.');
            }
          }
        } else if (transitionRE.test(name)) {
          modifiers.literal = !bindRE.test(name);
          pushDir('transition', internalDirectives.transition);
        } else if (onRE.test(name)) {
          arg = name.replace(onRE, '');
          pushDir('on', publicDirectives.on);
        } else if (bindRE.test(name)) {
          dirName = name.replace(bindRE, '');
          if (dirName === 'style' || dirName === 'class') {
            pushDir(dirName, internalDirectives[dirName]);
          } else {
            arg = dirName;
            pushDir('bind', publicDirectives.bind);
          }
        } else if (name.indexOf('v-') === 0) {
          arg = (arg = name.match(argRE)) && arg[1];
          if (arg) {
            name = name.replace(argRE, '');
          }
          dirName = name.slice(2);
          if (dirName === 'else') {
            continue;
          }
          dirDef = resolveAsset(options, 'directives', dirName);
          if (process.env.NODE_ENV !== 'production') {
            assertAsset(dirDef, 'directive', dirName);
          }
          if (dirDef) {
            pushDir(dirName, dirDef);
          }
        }
      }
      function pushDir(dirName, def, interp) {
        var parsed = parseDirective(value);
        dirs.push({
          name: dirName,
          attr: rawName,
          raw: rawValue,
          def: def,
          arg: arg,
          modifiers: modifiers,
          expression: parsed.expression,
          filters: parsed.filters,
          interp: interp
        });
      }
      if (dirs.length) {
        return makeNodeLinkFn(dirs);
      }
    }
    function parseModifiers(name) {
      var res = Object.create(null);
      var match = name.match(modifierRE);
      if (match) {
        var i = match.length;
        while (i--) {
          res[match[i].slice(1)] = true;
        }
      }
      return res;
    }
    function makeNodeLinkFn(directives) {
      return function nodeLinkFn(vm, el, host, scope, frag) {
        var i = directives.length;
        while (i--) {
          vm._bindDir(directives[i], el, host, scope, frag);
        }
      };
    }
    var specialCharRE = /[^\w\-:\.]/;
    function transclude(el, options) {
      if (options) {
        options._containerAttrs = extractAttrs(el);
      }
      if (isTemplate(el)) {
        el = parseTemplate(el);
      }
      if (options) {
        if (options._asComponent && !options.template) {
          options.template = '<slot></slot>';
        }
        if (options.template) {
          options._content = extractContent(el);
          el = transcludeTemplate(el, options);
        }
      }
      if (el instanceof DocumentFragment) {
        prepend(createAnchor('v-start', true), el);
        el.appendChild(createAnchor('v-end', true));
      }
      return el;
    }
    function transcludeTemplate(el, options) {
      var template = options.template;
      var frag = parseTemplate(template, true);
      if (frag) {
        var replacer = frag.firstChild;
        var tag = replacer.tagName && replacer.tagName.toLowerCase();
        if (options.replace) {
          if (el === document.body) {
            process.env.NODE_ENV !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
          }
          if (frag.childNodes.length > 1 || replacer.nodeType !== 1 || tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') || resolveAsset(options, 'elementDirectives', tag) || replacer.hasAttribute('v-for') || replacer.hasAttribute('v-if')) {
            return frag;
          } else {
            options._replacerAttrs = extractAttrs(replacer);
            mergeAttrs(el, replacer);
            return replacer;
          }
        } else {
          el.appendChild(frag);
          return el;
        }
      } else {
        process.env.NODE_ENV !== 'production' && warn('Invalid template option: ' + template);
      }
    }
    function extractAttrs(el) {
      if (el.nodeType === 1 && el.hasAttributes()) {
        return toArray(el.attributes);
      }
    }
    function mergeAttrs(from, to) {
      var attrs = from.attributes;
      var i = attrs.length;
      var name,
          value;
      while (i--) {
        name = attrs[i].name;
        value = attrs[i].value;
        if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
          to.setAttribute(name, value);
        } else if (name === 'class') {
          value.split(/\s+/).forEach(function(cls) {
            addClass(to, cls);
          });
        }
      }
    }
    var compiler = Object.freeze({
      compile: compile,
      compileAndLinkProps: compileAndLinkProps,
      compileRoot: compileRoot,
      transclude: transclude
    });
    function stateMixin(Vue) {
      Object.defineProperty(Vue.prototype, '$data', {
        get: function get() {
          return this._data;
        },
        set: function set(newData) {
          if (newData !== this._data) {
            this._setData(newData);
          }
        }
      });
      Vue.prototype._initState = function() {
        this._initProps();
        this._initMeta();
        this._initMethods();
        this._initData();
        this._initComputed();
      };
      Vue.prototype._initProps = function() {
        var options = this.$options;
        var el = options.el;
        var props = options.props;
        if (props && !el) {
          process.env.NODE_ENV !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.');
        }
        el = options.el = query(el);
        this._propsUnlinkFn = el && el.nodeType === 1 && props ? compileAndLinkProps(this, el, props, this._scope) : null;
      };
      Vue.prototype._initData = function() {
        var propsData = this._data;
        var optionsDataFn = this.$options.data;
        var optionsData = optionsDataFn && optionsDataFn();
        if (optionsData) {
          this._data = optionsData;
          for (var prop in propsData) {
            if (process.env.NODE_ENV !== 'production' && hasOwn(optionsData, prop)) {
              warn('Data field "' + prop + '" is already defined ' + 'as a prop. Use prop default value instead.');
            }
            if (this._props[prop].raw !== null || !hasOwn(optionsData, prop)) {
              set(optionsData, prop, propsData[prop]);
            }
          }
        }
        var data = this._data;
        var keys = Object.keys(data);
        var i,
            key;
        i = keys.length;
        while (i--) {
          key = keys[i];
          this._proxy(key);
        }
        observe(data, this);
      };
      Vue.prototype._setData = function(newData) {
        newData = newData || {};
        var oldData = this._data;
        this._data = newData;
        var keys,
            key,
            i;
        keys = Object.keys(oldData);
        i = keys.length;
        while (i--) {
          key = keys[i];
          if (!(key in newData)) {
            this._unproxy(key);
          }
        }
        keys = Object.keys(newData);
        i = keys.length;
        while (i--) {
          key = keys[i];
          if (!hasOwn(this, key)) {
            this._proxy(key);
          }
        }
        oldData.__ob__.removeVm(this);
        observe(newData, this);
        this._digest();
      };
      Vue.prototype._proxy = function(key) {
        if (!isReserved(key)) {
          var self = this;
          Object.defineProperty(self, key, {
            configurable: true,
            enumerable: true,
            get: function proxyGetter() {
              return self._data[key];
            },
            set: function proxySetter(val) {
              self._data[key] = val;
            }
          });
        }
      };
      Vue.prototype._unproxy = function(key) {
        if (!isReserved(key)) {
          delete this[key];
        }
      };
      Vue.prototype._digest = function() {
        for (var i = 0,
            l = this._watchers.length; i < l; i++) {
          this._watchers[i].update(true);
        }
      };
      function noop() {}
      Vue.prototype._initComputed = function() {
        var computed = this.$options.computed;
        if (computed) {
          for (var key in computed) {
            var userDef = computed[key];
            var def = {
              enumerable: true,
              configurable: true
            };
            if (typeof userDef === 'function') {
              def.get = makeComputedGetter(userDef, this);
              def.set = noop;
            } else {
              def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind$1(userDef.get, this) : noop;
              def.set = userDef.set ? bind$1(userDef.set, this) : noop;
            }
            Object.defineProperty(this, key, def);
          }
        }
      };
      function makeComputedGetter(getter, owner) {
        var watcher = new Watcher(owner, getter, null, {lazy: true});
        return function computedGetter() {
          if (watcher.dirty) {
            watcher.evaluate();
          }
          if (Dep.target) {
            watcher.depend();
          }
          return watcher.value;
        };
      }
      Vue.prototype._initMethods = function() {
        var methods = this.$options.methods;
        if (methods) {
          for (var key in methods) {
            this[key] = bind$1(methods[key], this);
          }
        }
      };
      Vue.prototype._initMeta = function() {
        var metas = this.$options._meta;
        if (metas) {
          for (var key in metas) {
            defineReactive(this, key, metas[key]);
          }
        }
      };
    }
    var eventRE = /^v-on:|^@/;
    function eventsMixin(Vue) {
      Vue.prototype._initEvents = function() {
        var options = this.$options;
        if (options._asComponent) {
          registerComponentEvents(this, options.el);
        }
        registerCallbacks(this, '$on', options.events);
        registerCallbacks(this, '$watch', options.watch);
      };
      function registerComponentEvents(vm, el) {
        var attrs = el.attributes;
        var name,
            handler;
        for (var i = 0,
            l = attrs.length; i < l; i++) {
          name = attrs[i].name;
          if (eventRE.test(name)) {
            name = name.replace(eventRE, '');
            handler = (vm._scope || vm._context).$eval(attrs[i].value, true);
            vm.$on(name.replace(eventRE), handler);
          }
        }
      }
      function registerCallbacks(vm, action, hash) {
        if (!hash)
          return;
        var handlers,
            key,
            i,
            j;
        for (key in hash) {
          handlers = hash[key];
          if (isArray(handlers)) {
            for (i = 0, j = handlers.length; i < j; i++) {
              register(vm, action, key, handlers[i]);
            }
          } else {
            register(vm, action, key, handlers);
          }
        }
      }
      function register(vm, action, key, handler, options) {
        var type = typeof handler;
        if (type === 'function') {
          vm[action](key, handler, options);
        } else if (type === 'string') {
          var methods = vm.$options.methods;
          var method = methods && methods[handler];
          if (method) {
            vm[action](key, method, options);
          } else {
            process.env.NODE_ENV !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".');
          }
        } else if (handler && type === 'object') {
          register(vm, action, key, handler.handler, handler);
        }
      }
      Vue.prototype._initDOMHooks = function() {
        this.$on('hook:attached', onAttached);
        this.$on('hook:detached', onDetached);
      };
      function onAttached() {
        if (!this._isAttached) {
          this._isAttached = true;
          this.$children.forEach(callAttach);
        }
      }
      function callAttach(child) {
        if (!child._isAttached && inDoc(child.$el)) {
          child._callHook('attached');
        }
      }
      function onDetached() {
        if (this._isAttached) {
          this._isAttached = false;
          this.$children.forEach(callDetach);
        }
      }
      function callDetach(child) {
        if (child._isAttached && !inDoc(child.$el)) {
          child._callHook('detached');
        }
      }
      Vue.prototype._callHook = function(hook) {
        this.$emit('pre-hook:' + hook);
        var handlers = this.$options[hook];
        if (handlers) {
          for (var i = 0,
              j = handlers.length; i < j; i++) {
            handlers[i].call(this);
          }
        }
        this.$emit('hook:' + hook);
      };
    }
    function noop() {}
    function Directive(descriptor, vm, el, host, scope, frag) {
      this.vm = vm;
      this.el = el;
      this.descriptor = descriptor;
      this.name = descriptor.name;
      this.expression = descriptor.expression;
      this.arg = descriptor.arg;
      this.modifiers = descriptor.modifiers;
      this.filters = descriptor.filters;
      this.literal = this.modifiers && this.modifiers.literal;
      this._locked = false;
      this._bound = false;
      this._listeners = null;
      this._host = host;
      this._scope = scope;
      this._frag = frag;
      if (process.env.NODE_ENV !== 'production' && this.el) {
        this.el._vue_directives = this.el._vue_directives || [];
        this.el._vue_directives.push(this);
      }
    }
    Directive.prototype._bind = function() {
      var name = this.name;
      var descriptor = this.descriptor;
      if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
        var attr = descriptor.attr || 'v-' + name;
        this.el.removeAttribute(attr);
      }
      var def = descriptor.def;
      if (typeof def === 'function') {
        this.update = def;
      } else {
        extend(this, def);
      }
      this._setupParams();
      if (this.bind) {
        this.bind();
      }
      this._bound = true;
      if (this.literal) {
        this.update && this.update(descriptor.raw);
      } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
        var dir = this;
        if (this.update) {
          this._update = function(val, oldVal) {
            if (!dir._locked) {
              dir.update(val, oldVal);
            }
          };
        } else {
          this._update = noop;
        }
        var preProcess = this._preProcess ? bind$1(this._preProcess, this) : null;
        var postProcess = this._postProcess ? bind$1(this._postProcess, this) : null;
        var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, {
          filters: this.filters,
          twoWay: this.twoWay,
          deep: this.deep,
          preProcess: preProcess,
          postProcess: postProcess,
          scope: this._scope
        });
        if (this.afterBind) {
          this.afterBind();
        } else if (this.update) {
          this.update(watcher.value);
        }
      }
    };
    Directive.prototype._setupParams = function() {
      if (!this.params) {
        return;
      }
      var params = this.params;
      this.params = Object.create(null);
      var i = params.length;
      var key,
          val,
          mappedKey;
      while (i--) {
        key = params[i];
        mappedKey = camelize(key);
        val = getBindAttr(this.el, key);
        if (val != null) {
          this._setupParamWatcher(mappedKey, val);
        } else {
          val = getAttr(this.el, key);
          if (val != null) {
            this.params[mappedKey] = val === '' ? true : val;
          }
        }
      }
    };
    Directive.prototype._setupParamWatcher = function(key, expression) {
      var self = this;
      var called = false;
      var unwatch = (this._scope || this.vm).$watch(expression, function(val, oldVal) {
        self.params[key] = val;
        if (called) {
          var cb = self.paramWatchers && self.paramWatchers[key];
          if (cb) {
            cb.call(self, val, oldVal);
          }
        } else {
          called = true;
        }
      }, {
        immediate: true,
        user: false
      });
      (this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
    };
    Directive.prototype._checkStatement = function() {
      var expression = this.expression;
      if (expression && this.acceptStatement && !isSimplePath(expression)) {
        var fn = parseExpression(expression).get;
        var scope = this._scope || this.vm;
        var handler = function handler(e) {
          scope.$event = e;
          fn.call(scope, scope);
          scope.$event = null;
        };
        if (this.filters) {
          handler = scope._applyFilters(handler, null, this.filters);
        }
        this.update(handler);
        return true;
      }
    };
    Directive.prototype.set = function(value) {
      if (this.twoWay) {
        this._withLock(function() {
          this._watcher.set(value);
        });
      } else if (process.env.NODE_ENV !== 'production') {
        warn('Directive.set() can only be used inside twoWay' + 'directives.');
      }
    };
    Directive.prototype._withLock = function(fn) {
      var self = this;
      self._locked = true;
      fn.call(self);
      nextTick(function() {
        self._locked = false;
      });
    };
    Directive.prototype.on = function(event, handler) {
      on$1(this.el, event, handler);
      (this._listeners || (this._listeners = [])).push([event, handler]);
    };
    Directive.prototype._teardown = function() {
      if (this._bound) {
        this._bound = false;
        if (this.unbind) {
          this.unbind();
        }
        if (this._watcher) {
          this._watcher.teardown();
        }
        var listeners = this._listeners;
        var i;
        if (listeners) {
          i = listeners.length;
          while (i--) {
            off(this.el, listeners[i][0], listeners[i][1]);
          }
        }
        var unwatchFns = this._paramUnwatchFns;
        if (unwatchFns) {
          i = unwatchFns.length;
          while (i--) {
            unwatchFns[i]();
          }
        }
        if (process.env.NODE_ENV !== 'production' && this.el) {
          this.el._vue_directives.$remove(this);
        }
        this.vm = this.el = this._watcher = this._listeners = null;
      }
    };
    function lifecycleMixin(Vue) {
      Vue.prototype._updateRef = function(remove) {
        var ref = this.$options._ref;
        if (ref) {
          var refs = (this._scope || this._context).$refs;
          if (remove) {
            if (refs[ref] === this) {
              refs[ref] = null;
            }
          } else {
            refs[ref] = this;
          }
        }
      };
      Vue.prototype._compile = function(el) {
        var options = this.$options;
        var original = el;
        el = transclude(el, options);
        this._initElement(el);
        if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
          return;
        }
        var contextOptions = this._context && this._context.$options;
        var rootLinker = compileRoot(el, options, contextOptions);
        var contentLinkFn;
        var ctor = this.constructor;
        if (options._linkerCachable) {
          contentLinkFn = ctor.linker;
          if (!contentLinkFn) {
            contentLinkFn = ctor.linker = compile(el, options);
          }
        }
        var rootUnlinkFn = rootLinker(this, el, this._scope);
        var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
        this._unlinkFn = function() {
          rootUnlinkFn();
          contentUnlinkFn(true);
        };
        if (options.replace) {
          replace(original, el);
        }
        this._isCompiled = true;
        this._callHook('compiled');
        return el;
      };
      Vue.prototype._initElement = function(el) {
        if (el instanceof DocumentFragment) {
          this._isFragment = true;
          this.$el = this._fragmentStart = el.firstChild;
          this._fragmentEnd = el.lastChild;
          if (this._fragmentStart.nodeType === 3) {
            this._fragmentStart.data = this._fragmentEnd.data = '';
          }
          this._fragment = el;
        } else {
          this.$el = el;
        }
        this.$el.__vue__ = this;
        this._callHook('beforeCompile');
      };
      Vue.prototype._bindDir = function(descriptor, node, host, scope, frag) {
        this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
      };
      Vue.prototype._destroy = function(remove, deferCleanup) {
        if (this._isBeingDestroyed) {
          if (!deferCleanup) {
            this._cleanup();
          }
          return;
        }
        var destroyReady;
        var pendingRemoval;
        var self = this;
        var cleanupIfPossible = function cleanupIfPossible() {
          if (destroyReady && !pendingRemoval && !deferCleanup) {
            self._cleanup();
          }
        };
        if (remove && this.$el) {
          pendingRemoval = true;
          this.$remove(function() {
            pendingRemoval = false;
            cleanupIfPossible();
          });
        }
        this._callHook('beforeDestroy');
        this._isBeingDestroyed = true;
        var i;
        var parent = this.$parent;
        if (parent && !parent._isBeingDestroyed) {
          parent.$children.$remove(this);
          this._updateRef(true);
        }
        i = this.$children.length;
        while (i--) {
          this.$children[i].$destroy();
        }
        if (this._propsUnlinkFn) {
          this._propsUnlinkFn();
        }
        if (this._unlinkFn) {
          this._unlinkFn();
        }
        i = this._watchers.length;
        while (i--) {
          this._watchers[i].teardown();
        }
        if (this.$el) {
          this.$el.__vue__ = null;
        }
        destroyReady = true;
        cleanupIfPossible();
      };
      Vue.prototype._cleanup = function() {
        if (this._isDestroyed) {
          return;
        }
        if (this._frag) {
          this._frag.children.$remove(this);
        }
        if (this._data.__ob__) {
          this._data.__ob__.removeVm(this);
        }
        this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
        this._isDestroyed = true;
        this._callHook('destroyed');
        this.$off();
      };
    }
    function miscMixin(Vue) {
      Vue.prototype._applyFilters = function(value, oldValue, filters, write) {
        var filter,
            fn,
            args,
            arg,
            offset,
            i,
            l,
            j,
            k;
        for (i = 0, l = filters.length; i < l; i++) {
          filter = filters[i];
          fn = resolveAsset(this.$options, 'filters', filter.name);
          if (process.env.NODE_ENV !== 'production') {
            assertAsset(fn, 'filter', filter.name);
          }
          if (!fn)
            continue;
          fn = write ? fn.write : fn.read || fn;
          if (typeof fn !== 'function')
            continue;
          args = write ? [value, oldValue] : [value];
          offset = write ? 2 : 1;
          if (filter.args) {
            for (j = 0, k = filter.args.length; j < k; j++) {
              arg = filter.args[j];
              args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
            }
          }
          value = fn.apply(this, args);
        }
        return value;
      };
      Vue.prototype._resolveComponent = function(id, cb) {
        var factory = resolveAsset(this.$options, 'components', id);
        if (process.env.NODE_ENV !== 'production') {
          assertAsset(factory, 'component', id);
        }
        if (!factory) {
          return;
        }
        if (!factory.options) {
          if (factory.resolved) {
            cb(factory.resolved);
          } else if (factory.requested) {
            factory.pendingCallbacks.push(cb);
          } else {
            factory.requested = true;
            var cbs = factory.pendingCallbacks = [cb];
            factory(function resolve(res) {
              if (isPlainObject(res)) {
                res = Vue.extend(res);
              }
              factory.resolved = res;
              for (var i = 0,
                  l = cbs.length; i < l; i++) {
                cbs[i](res);
              }
            }, function reject(reason) {
              process.env.NODE_ENV !== 'production' && warn('Failed to resolve async component: ' + id + '. ' + (reason ? '\nReason: ' + reason : ''));
            });
          }
        } else {
          cb(factory);
        }
      };
    }
    function globalAPI(Vue) {
      Vue.util = util;
      Vue.config = config;
      Vue.set = set;
      Vue['delete'] = del;
      Vue.nextTick = nextTick;
      Vue.compiler = compiler;
      Vue.FragmentFactory = FragmentFactory;
      Vue.internalDirectives = internalDirectives;
      Vue.parsers = {
        path: path,
        text: text$1,
        template: template,
        directive: directive,
        expression: expression
      };
      Vue.cid = 0;
      var cid = 1;
      Vue.extend = function(extendOptions) {
        extendOptions = extendOptions || {};
        var Super = this;
        var isFirstExtend = Super.cid === 0;
        if (isFirstExtend && extendOptions._Ctor) {
          return extendOptions._Ctor;
        }
        var name = extendOptions.name || Super.options.name;
        if (process.env.NODE_ENV !== 'production') {
          if (!/^[a-zA-Z][\w-]+$/.test(name)) {
            warn('Invalid component name: ' + name);
            name = null;
          }
        }
        var Sub = createClass(name || 'VueComponent');
        Sub.prototype = Object.create(Super.prototype);
        Sub.prototype.constructor = Sub;
        Sub.cid = cid++;
        Sub.options = mergeOptions(Super.options, extendOptions);
        Sub['super'] = Super;
        Sub.extend = Super.extend;
        config._assetTypes.forEach(function(type) {
          Sub[type] = Super[type];
        });
        if (name) {
          Sub.options.components[name] = Sub;
        }
        if (isFirstExtend) {
          extendOptions._Ctor = Sub;
        }
        return Sub;
      };
      function createClass(name) {
        return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
      }
      Vue.use = function(plugin) {
        if (plugin.installed) {
          return;
        }
        var args = toArray(arguments, 1);
        args.unshift(this);
        if (typeof plugin.install === 'function') {
          plugin.install.apply(plugin, args);
        } else {
          plugin.apply(null, args);
        }
        plugin.installed = true;
        return this;
      };
      Vue.mixin = function(mixin) {
        Vue.options = mergeOptions(Vue.options, mixin);
      };
      config._assetTypes.forEach(function(type) {
        Vue[type] = function(id, definition) {
          if (!definition) {
            return this.options[type + 's'][id];
          } else {
            if (process.env.NODE_ENV !== 'production') {
              if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
                warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
              }
            }
            if (type === 'component' && isPlainObject(definition)) {
              definition.name = id;
              definition = Vue.extend(definition);
            }
            this.options[type + 's'][id] = definition;
            return definition;
          }
        };
      });
    }
    var filterRE = /[^|]\|[^|]/;
    function dataAPI(Vue) {
      Vue.prototype.$get = function(exp, asStatement) {
        var res = parseExpression(exp);
        if (res) {
          if (asStatement && !isSimplePath(exp)) {
            var self = this;
            return function statementHandler() {
              self.$arguments = toArray(arguments);
              res.get.call(self, self);
              self.$arguments = null;
            };
          } else {
            try {
              return res.get.call(this, this);
            } catch (e) {}
          }
        }
      };
      Vue.prototype.$set = function(exp, val) {
        var res = parseExpression(exp, true);
        if (res && res.set) {
          res.set.call(this, this, val);
        }
      };
      Vue.prototype.$delete = function(key) {
        del(this._data, key);
      };
      Vue.prototype.$watch = function(expOrFn, cb, options) {
        var vm = this;
        var parsed;
        if (typeof expOrFn === 'string') {
          parsed = parseDirective(expOrFn);
          expOrFn = parsed.expression;
        }
        var watcher = new Watcher(vm, expOrFn, cb, {
          deep: options && options.deep,
          sync: options && options.sync,
          filters: parsed && parsed.filters,
          user: !options || options.user !== false
        });
        if (options && options.immediate) {
          cb.call(vm, watcher.value);
        }
        return function unwatchFn() {
          watcher.teardown();
        };
      };
      Vue.prototype.$eval = function(text, asStatement) {
        if (filterRE.test(text)) {
          var dir = parseDirective(text);
          var val = this.$get(dir.expression, asStatement);
          return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
        } else {
          return this.$get(text, asStatement);
        }
      };
      Vue.prototype.$interpolate = function(text) {
        var tokens = parseText(text);
        var vm = this;
        if (tokens) {
          if (tokens.length === 1) {
            return vm.$eval(tokens[0].value) + '';
          } else {
            return tokens.map(function(token) {
              return token.tag ? vm.$eval(token.value) : token.value;
            }).join('');
          }
        } else {
          return text;
        }
      };
      Vue.prototype.$log = function(path) {
        var data = path ? getPath(this._data, path) : this._data;
        if (data) {
          data = clean(data);
        }
        if (!path) {
          for (var key in this.$options.computed) {
            data[key] = clean(this[key]);
          }
        }
        console.log(data);
      };
      function clean(obj) {
        return JSON.parse(JSON.stringify(obj));
      }
    }
    function domAPI(Vue) {
      Vue.prototype.$nextTick = function(fn) {
        nextTick(fn, this);
      };
      Vue.prototype.$appendTo = function(target, cb, withTransition) {
        return insert(this, target, cb, withTransition, append, appendWithTransition);
      };
      Vue.prototype.$prependTo = function(target, cb, withTransition) {
        target = query(target);
        if (target.hasChildNodes()) {
          this.$before(target.firstChild, cb, withTransition);
        } else {
          this.$appendTo(target, cb, withTransition);
        }
        return this;
      };
      Vue.prototype.$before = function(target, cb, withTransition) {
        return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
      };
      Vue.prototype.$after = function(target, cb, withTransition) {
        target = query(target);
        if (target.nextSibling) {
          this.$before(target.nextSibling, cb, withTransition);
        } else {
          this.$appendTo(target.parentNode, cb, withTransition);
        }
        return this;
      };
      Vue.prototype.$remove = function(cb, withTransition) {
        if (!this.$el.parentNode) {
          return cb && cb();
        }
        var inDocument = this._isAttached && inDoc(this.$el);
        if (!inDocument)
          withTransition = false;
        var self = this;
        var realCb = function realCb() {
          if (inDocument)
            self._callHook('detached');
          if (cb)
            cb();
        };
        if (this._isFragment) {
          removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
        } else {
          var op = withTransition === false ? removeWithCb : removeWithTransition;
          op(this.$el, this, realCb);
        }
        return this;
      };
      function insert(vm, target, cb, withTransition, op1, op2) {
        target = query(target);
        var targetIsDetached = !inDoc(target);
        var op = withTransition === false || targetIsDetached ? op1 : op2;
        var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
        if (vm._isFragment) {
          mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function(node) {
            op(node, target, vm);
          });
          cb && cb();
        } else {
          op(vm.$el, target, vm, cb);
        }
        if (shouldCallHook) {
          vm._callHook('attached');
        }
        return vm;
      }
      function query(el) {
        return typeof el === 'string' ? document.querySelector(el) : el;
      }
      function append(el, target, vm, cb) {
        target.appendChild(el);
        if (cb)
          cb();
      }
      function beforeWithCb(el, target, vm, cb) {
        before(el, target);
        if (cb)
          cb();
      }
      function removeWithCb(el, vm, cb) {
        remove(el);
        if (cb)
          cb();
      }
    }
    function eventsAPI(Vue) {
      Vue.prototype.$on = function(event, fn) {
        (this._events[event] || (this._events[event] = [])).push(fn);
        modifyListenerCount(this, event, 1);
        return this;
      };
      Vue.prototype.$once = function(event, fn) {
        var self = this;
        function on() {
          self.$off(event, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.$on(event, on);
        return this;
      };
      Vue.prototype.$off = function(event, fn) {
        var cbs;
        if (!arguments.length) {
          if (this.$parent) {
            for (event in this._events) {
              cbs = this._events[event];
              if (cbs) {
                modifyListenerCount(this, event, -cbs.length);
              }
            }
          }
          this._events = {};
          return this;
        }
        cbs = this._events[event];
        if (!cbs) {
          return this;
        }
        if (arguments.length === 1) {
          modifyListenerCount(this, event, -cbs.length);
          this._events[event] = null;
          return this;
        }
        var cb;
        var i = cbs.length;
        while (i--) {
          cb = cbs[i];
          if (cb === fn || cb.fn === fn) {
            modifyListenerCount(this, event, -1);
            cbs.splice(i, 1);
            break;
          }
        }
        return this;
      };
      Vue.prototype.$emit = function(event) {
        var cbs = this._events[event];
        var shouldPropagate = !cbs;
        if (cbs) {
          cbs = cbs.length > 1 ? toArray(cbs) : cbs;
          var args = toArray(arguments, 1);
          for (var i = 0,
              l = cbs.length; i < l; i++) {
            var res = cbs[i].apply(this, args);
            if (res === true) {
              shouldPropagate = true;
            }
          }
        }
        return shouldPropagate;
      };
      Vue.prototype.$broadcast = function(event) {
        if (!this._eventsCount[event])
          return;
        var children = this.$children;
        for (var i = 0,
            l = children.length; i < l; i++) {
          var child = children[i];
          var shouldPropagate = child.$emit.apply(child, arguments);
          if (shouldPropagate) {
            child.$broadcast.apply(child, arguments);
          }
        }
        return this;
      };
      Vue.prototype.$dispatch = function() {
        this.$emit.apply(this, arguments);
        var parent = this.$parent;
        while (parent) {
          var shouldPropagate = parent.$emit.apply(parent, arguments);
          parent = shouldPropagate ? parent.$parent : null;
        }
        return this;
      };
      var hookRE = /^hook:/;
      function modifyListenerCount(vm, event, count) {
        var parent = vm.$parent;
        if (!parent || !count || hookRE.test(event))
          return;
        while (parent) {
          parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
          parent = parent.$parent;
        }
      }
    }
    function lifecycleAPI(Vue) {
      Vue.prototype.$mount = function(el) {
        if (this._isCompiled) {
          process.env.NODE_ENV !== 'production' && warn('$mount() should be called only once.');
          return;
        }
        el = query(el);
        if (!el) {
          el = document.createElement('div');
        }
        this._compile(el);
        this._initDOMHooks();
        if (inDoc(this.$el)) {
          this._callHook('attached');
          ready.call(this);
        } else {
          this.$once('hook:attached', ready);
        }
        return this;
      };
      function ready() {
        this._isAttached = true;
        this._isReady = true;
        this._callHook('ready');
      }
      Vue.prototype.$destroy = function(remove, deferCleanup) {
        this._destroy(remove, deferCleanup);
      };
      Vue.prototype.$compile = function(el, host, scope, frag) {
        return compile(el, this.$options, true)(this, el, host, scope, frag);
      };
    }
    function Vue(options) {
      this._init(options);
    }
    initMixin(Vue);
    stateMixin(Vue);
    eventsMixin(Vue);
    lifecycleMixin(Vue);
    miscMixin(Vue);
    globalAPI(Vue);
    dataAPI(Vue);
    domAPI(Vue);
    eventsAPI(Vue);
    lifecycleAPI(Vue);
    var convertArray = vFor._postProcess;
    function limitBy(arr, n, offset) {
      offset = offset ? parseInt(offset, 10) : 0;
      return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
    }
    function filterBy(arr, search, delimiter) {
      arr = convertArray(arr);
      if (search == null) {
        return arr;
      }
      if (typeof search === 'function') {
        return arr.filter(search);
      }
      search = ('' + search).toLowerCase();
      var n = delimiter === 'in' ? 3 : 2;
      var keys = toArray(arguments, n).reduce(function(prev, cur) {
        return prev.concat(cur);
      }, []);
      var res = [];
      var item,
          key,
          val,
          j;
      for (var i = 0,
          l = arr.length; i < l; i++) {
        item = arr[i];
        val = item && item.$value || item;
        j = keys.length;
        if (j) {
          while (j--) {
            key = keys[j];
            if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
              res.push(item);
              break;
            }
          }
        } else if (contains(item, search)) {
          res.push(item);
        }
      }
      return res;
    }
    function orderBy(arr, sortKey, reverse) {
      arr = convertArray(arr);
      if (!sortKey) {
        return arr;
      }
      var order = reverse && reverse < 0 ? -1 : 1;
      return arr.slice().sort(function(a, b) {
        if (sortKey !== '$key') {
          if (isObject(a) && '$value' in a)
            a = a.$value;
          if (isObject(b) && '$value' in b)
            b = b.$value;
        }
        a = isObject(a) ? getPath(a, sortKey) : a;
        b = isObject(b) ? getPath(b, sortKey) : b;
        return a === b ? 0 : a > b ? order : -order;
      });
    }
    function contains(val, search) {
      var i;
      if (isPlainObject(val)) {
        var keys = Object.keys(val);
        i = keys.length;
        while (i--) {
          if (contains(val[keys[i]], search)) {
            return true;
          }
        }
      } else if (isArray(val)) {
        i = val.length;
        while (i--) {
          if (contains(val[i], search)) {
            return true;
          }
        }
      } else if (val != null) {
        return val.toString().toLowerCase().indexOf(search) > -1;
      }
    }
    var digitsRE = /(\d{3})(?=\d)/g;
    var filters = {
      orderBy: orderBy,
      filterBy: filterBy,
      limitBy: limitBy,
      json: {
        read: function read(value, indent) {
          return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);
        },
        write: function write(value) {
          try {
            return JSON.parse(value);
          } catch (e) {
            return value;
          }
        }
      },
      capitalize: function capitalize(value) {
        if (!value && value !== 0)
          return '';
        value = value.toString();
        return value.charAt(0).toUpperCase() + value.slice(1);
      },
      uppercase: function uppercase(value) {
        return value || value === 0 ? value.toString().toUpperCase() : '';
      },
      lowercase: function lowercase(value) {
        return value || value === 0 ? value.toString().toLowerCase() : '';
      },
      currency: function currency(value, _currency) {
        value = parseFloat(value);
        if (!isFinite(value) || !value && value !== 0)
          return '';
        _currency = _currency != null ? _currency : '$';
        var stringified = Math.abs(value).toFixed(2);
        var _int = stringified.slice(0, -3);
        var i = _int.length % 3;
        var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
        var _float = stringified.slice(-3);
        var sign = value < 0 ? '-' : '';
        return _currency + sign + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
      },
      pluralize: function pluralize(value) {
        var args = toArray(arguments, 1);
        return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');
      },
      debounce: function debounce(handler, delay) {
        if (!handler)
          return;
        if (!delay) {
          delay = 300;
        }
        return _debounce(handler, delay);
      }
    };
    var partial = {
      priority: PARTIAL,
      params: ['name'],
      paramWatchers: {name: function name(value) {
          vIf.remove.call(this);
          if (value) {
            this.insert(value);
          }
        }},
      bind: function bind() {
        this.anchor = createAnchor('v-partial');
        replace(this.el, this.anchor);
        this.insert(this.params.name);
      },
      insert: function insert(id) {
        var partial = resolveAsset(this.vm.$options, 'partials', id);
        if (process.env.NODE_ENV !== 'production') {
          assertAsset(partial, 'partial', id);
        }
        if (partial) {
          this.factory = new FragmentFactory(this.vm, partial);
          vIf.insert.call(this);
        }
      },
      unbind: function unbind() {
        if (this.frag) {
          this.frag.destroy();
        }
      }
    };
    var slot = {
      priority: SLOT,
      bind: function bind() {
        var host = this.vm;
        var raw = host.$options._content;
        if (!raw) {
          this.fallback();
          return;
        }
        var context = host._context;
        var slotName = this.params && this.params.name;
        if (!slotName) {
          this.tryCompile(extractFragment(raw.childNodes, raw, true), context, host);
        } else {
          var selector = '[slot="' + slotName + '"]';
          var nodes = raw.querySelectorAll(selector);
          if (nodes.length) {
            this.tryCompile(extractFragment(nodes, raw), context, host);
          } else {
            this.fallback();
          }
        }
      },
      tryCompile: function tryCompile(content, context, host) {
        if (content.hasChildNodes()) {
          this.compile(content, context, host);
        } else {
          this.fallback();
        }
      },
      compile: function compile(content, context, host) {
        if (content && context) {
          var scope = host ? host._scope : this._scope;
          this.unlink = context.$compile(content, host, scope, this._frag);
        }
        if (content) {
          replace(this.el, content);
        } else {
          remove(this.el);
        }
      },
      fallback: function fallback() {
        this.compile(extractContent(this.el, true), this.vm);
      },
      unbind: function unbind() {
        if (this.unlink) {
          this.unlink();
        }
      }
    };
    var namedSlot = extend(extend({}, slot), {
      priority: slot.priority + 1,
      params: ['name']
    });
    function extractFragment(nodes, parent, main) {
      var frag = document.createDocumentFragment();
      for (var i = 0,
          l = nodes.length; i < l; i++) {
        var node = nodes[i];
        if (main && !node.__v_selected) {
          append(node);
        } else if (!main && node.parentNode === parent) {
          node.__v_selected = true;
          append(node);
        }
      }
      return frag;
      function append(node) {
        if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
          node = parseTemplate(node);
        }
        node = cloneNode(node);
        frag.appendChild(node);
      }
    }
    var elementDirectives = {
      slot: slot,
      _namedSlot: namedSlot,
      partial: partial
    };
    Vue.version = '1.0.13';
    Vue.options = {
      directives: publicDirectives,
      elementDirectives: elementDirectives,
      filters: filters,
      transitions: {},
      components: {},
      partials: {},
      replace: true
    };
    if (process.env.NODE_ENV !== 'production' && inBrowser) {
      if (window.__VUE_DEVTOOLS_GLOBAL_HOOK__) {
        window.__VUE_DEVTOOLS_GLOBAL_HOOK__.emit('init', Vue);
      } else if (/Chrome\/\d+/.test(navigator.userAgent)) {
        console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
      }
    }
    module.exports = Vue;
  })(req('10'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("12", ["11"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('11');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("13", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("14", ["13"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = req('13');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("15", ["14"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('14'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("16", ["15"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$defineProperty = req('15')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("17", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("18", ["13"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = req('13');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("19", ["18"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('18'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.register("1a", [], function (_export) {
  /* */
  "use strict";

  function Target(path, matcher, delegate) {
    this.path = path;
    this.matcher = matcher;
    this.delegate = delegate;
  }

  function Matcher(target) {
    this.routes = {};
    this.children = {};
    this.target = target;
  }

  function generateMatch(startingPath, matcher, delegate) {
    return function (path, nestedCallback) {
      var fullPath = startingPath + path;

      if (nestedCallback) {
        nestedCallback(generateMatch(fullPath, matcher, delegate));
      } else {
        return new Target(startingPath + path, matcher, delegate);
      }
    };
  }

  function addRoute(routeArray, path, handler) {
    var len = 0;
    for (var i = 0, l = routeArray.length; i < l; i++) {
      len += routeArray[i].path.length;
    }

    path = path.substr(len);
    var route = { path: path, handler: handler };
    routeArray.push(route);
  }

  function eachRoute(baseRoute, matcher, callback, binding) {
    var routes = matcher.routes;

    for (var path in routes) {
      if (routes.hasOwnProperty(path)) {
        var routeArray = baseRoute.slice();
        addRoute(routeArray, path, routes[path]);

        if (matcher.children[path]) {
          eachRoute(routeArray, matcher.children[path], callback, binding);
        } else {
          callback.call(binding, routeArray);
        }
      }
    }
  }

  return {
    setters: [],
    execute: function () {
      Target.prototype = {
        to: function to(target, callback) {
          var delegate = this.delegate;

          if (delegate && delegate.willAddRoute) {
            target = delegate.willAddRoute(this.matcher.target, target);
          }

          this.matcher.add(this.path, target);

          if (callback) {
            if (callback.length === 0) {
              throw new Error("You must have an argument in the function passed to `to`");
            }
            this.matcher.addChild(this.path, target, callback, this.delegate);
          }
          return this;
        }
      };Matcher.prototype = {
        add: function add(path, handler) {
          this.routes[path] = handler;
        },

        addChild: function addChild(path, target, callback, delegate) {
          var matcher = new Matcher(target);
          this.children[path] = matcher;

          var match = generateMatch(path, matcher, delegate);

          if (delegate && delegate.contextEntered) {
            delegate.contextEntered(target, match);
          }

          callback(match);
        }
      };
      _export("default", function (callback, addRouteCallback) {
        var matcher = new Matcher();

        callback(generateMatch("", matcher, this.delegate));

        eachRoute([], matcher, function (route) {
          if (addRouteCallback) {
            addRouteCallback(this, route);
          } else {
            this.add(route);
          }
        }, this);
      });
    }
  };
});
$__System.register('1b', ['19', '1a'], function (_export) {
  var _Object$create, map, specials, escapeRegex, oCreate, RouteRecognizer;

  function isArray(test) {
    return Object.prototype.toString.call(test) === "[object Array]";
  }

  // A Segment represents a segment in the original route description.
  // Each Segment type provides an `eachChar` and `regex` method.
  //
  // The `eachChar` method invokes the callback with one or more character
  // specifications. A character specification consumes one or more input
  // characters.
  //
  // The `regex` method returns a regex fragment for the segment. If the
  // segment is a dynamic of star segment, the regex fragment also includes
  // a capture.
  //
  // A character specification contains:
  //
  // * `validChars`: a String with a list of all valid characters, or
  // * `invalidChars`: a String with a list of all invalid characters
  // * `repeat`: true if the character specification can repeat

  function StaticSegment(string) {
    this.string = string;
  }

  function DynamicSegment(name) {
    this.name = name;
  }

  function StarSegment(name) {
    this.name = name;
  }

  function EpsilonSegment() {}

  function parse(route, names, specificity) {
    // normalize route as not starting with a "/". Recognition will
    // also normalize.
    if (route.charAt(0) === "/") {
      route = route.substr(1);
    }

    var segments = route.split("/"),
        results = [];

    // A routes has specificity determined by the order that its different segments
    // appear in. This system mirrors how the magnitude of numbers written as strings
    // works.
    // Consider a number written as: "abc". An example would be "200". Any other number written
    // "xyz" will be smaller than "abc" so long as `a > z`. For instance, "199" is smaller
    // then "200", even though "y" and "z" (which are both 9) are larger than "0" (the value
    // of (`b` and `c`). This is because the leading symbol, "2", is larger than the other
    // leading symbol, "1".
    // The rule is that symbols to the left carry more weight than symbols to the right
    // when a number is written out as a string. In the above strings, the leading digit
    // represents how many 100's are in the number, and it carries more weight than the middle
    // number which represents how many 10's are in the number.
    // This system of number magnitude works well for route specificity, too. A route written as
    // `a/b/c` will be more specific than `x/y/z` as long as `a` is more specific than
    // `x`, irrespective of the other parts.
    // Because of this similarity, we assign each type of segment a number value written as a
    // string. We can find the specificity of compound routes by concatenating these strings
    // together, from left to right. After we have looped through all of the segments,
    // we convert the string to a number.
    specificity.val = '';

    for (var i = 0, l = segments.length; i < l; i++) {
      var segment = segments[i],
          match;

      if (match = segment.match(/^:([^\/]+)$/)) {
        results.push(new DynamicSegment(match[1]));
        names.push(match[1]);
        specificity.val += '3';
      } else if (match = segment.match(/^\*([^\/]+)$/)) {
        results.push(new StarSegment(match[1]));
        specificity.val += '2';
        names.push(match[1]);
      } else if (segment === "") {
        results.push(new EpsilonSegment());
        specificity.val += '1';
      } else {
        results.push(new StaticSegment(segment));
        specificity.val += '4';
      }
    }

    specificity.val = +specificity.val;

    return results;
  }

  // A State has a character specification and (`charSpec`) and a list of possible
  // subsequent states (`nextStates`).
  //
  // If a State is an accepting state, it will also have several additional
  // properties:
  //
  // * `regex`: A regular expression that is used to extract parameters from paths
  //   that reached this accepting state.
  // * `handlers`: Information on how to convert the list of captures into calls
  //   to registered handlers with the specified parameters
  // * `types`: How many static, dynamic or star segments in this route. Used to
  //   decide which route to use if multiple registered routes match a path.
  //
  // Currently, State is implemented naively by looping over `nextStates` and
  // comparing a character specification against a character. A more efficient
  // implementation would use a hash of keys pointing at one or more next states.

  function State(charSpec) {
    this.charSpec = charSpec;
    this.nextStates = [];
  }

  /** IF DEBUG
  , debug: function() {
    var charSpec = this.charSpec,
        debug = "[",
        chars = charSpec.validChars || charSpec.invalidChars;
     if (charSpec.invalidChars) { debug += "^"; }
    debug += chars;
    debug += "]";
     if (charSpec.repeat) { debug += "+"; }
     return debug;
  }
  END IF **/

  /** IF DEBUG
  function debug(log) {
    console.log(log);
  }
  
  function debugState(state) {
    return state.nextStates.map(function(n) {
      if (n.nextStates.length === 0) { return "( " + n.debug() + " [accepting] )"; }
      return "( " + n.debug() + " <then> " + n.nextStates.map(function(s) { return s.debug() }).join(" or ") + " )";
    }).join(", ")
  }
  END IF **/

  // Sort the routes by specificity
  function sortSolutions(states) {
    return states.sort(function (a, b) {
      return b.specificity.val - a.specificity.val;
    });
  }

  function recognizeChar(states, ch) {
    var nextStates = [];

    for (var i = 0, l = states.length; i < l; i++) {
      var state = states[i];

      nextStates = nextStates.concat(state.match(ch));
    }

    return nextStates;
  }

  function RecognizeResults(queryParams) {
    this.queryParams = queryParams || {};
  }

  function findHandler(state, path, queryParams) {
    var handlers = state.handlers,
        regex = state.regex;
    var captures = path.match(regex),
        currentCapture = 1;
    var result = new RecognizeResults(queryParams);

    for (var i = 0, l = handlers.length; i < l; i++) {
      var handler = handlers[i],
          names = handler.names,
          params = {};

      for (var j = 0, m = names.length; j < m; j++) {
        params[names[j]] = captures[currentCapture++];
      }

      result.push({ handler: handler.handler, params: params, isDynamic: !!names.length });
    }

    return result;
  }

  function addSegment(currentState, segment) {
    segment.eachChar(function (ch) {
      var state;

      currentState = currentState.put(ch);
    });

    return currentState;
  }

  function decodeQueryParamPart(part) {
    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1
    part = part.replace(/\+/gm, '%20');
    return decodeURIComponent(part);
  }

  // The main interface

  return {
    setters: [function (_) {
      _Object$create = _['default'];
    }, function (_a) {
      map = _a['default'];
    }],
    execute: function () {
      /* */
      'use strict';

      specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
      escapeRegex = new RegExp('(\\' + specials.join('|\\') + ')', 'g');
      StaticSegment.prototype = {
        eachChar: function eachChar(callback) {
          var string = this.string,
              ch;

          for (var i = 0, l = string.length; i < l; i++) {
            ch = string.charAt(i);
            callback({ validChars: ch });
          }
        },

        regex: function regex() {
          return this.string.replace(escapeRegex, '\\$1');
        },

        generate: function generate() {
          return this.string;
        }
      };DynamicSegment.prototype = {
        eachChar: function eachChar(callback) {
          callback({ invalidChars: "/", repeat: true });
        },

        regex: function regex() {
          return "([^/]+)";
        },

        generate: function generate(params) {
          return params[this.name];
        }
      };StarSegment.prototype = {
        eachChar: function eachChar(callback) {
          callback({ invalidChars: "", repeat: true });
        },

        regex: function regex() {
          return "(.+)";
        },

        generate: function generate(params) {
          return params[this.name];
        }
      };EpsilonSegment.prototype = {
        eachChar: function eachChar() {},
        regex: function regex() {
          return "";
        },
        generate: function generate() {
          return "";
        }
      };State.prototype = {
        get: function get(charSpec) {
          var nextStates = this.nextStates;

          for (var i = 0, l = nextStates.length; i < l; i++) {
            var child = nextStates[i];

            var isEqual = child.charSpec.validChars === charSpec.validChars;
            isEqual = isEqual && child.charSpec.invalidChars === charSpec.invalidChars;

            if (isEqual) {
              return child;
            }
          }
        },

        put: function put(charSpec) {
          var state;

          // If the character specification already exists in a child of the current
          // state, just return that state.
          if (state = this.get(charSpec)) {
            return state;
          }

          // Make a new state for the character spec
          state = new State(charSpec);

          // Insert the new state as a child of the current state
          this.nextStates.push(state);

          // If this character specification repeats, insert the new state as a child
          // of itself. Note that this will not trigger an infinite loop because each
          // transition during recognition consumes a character.
          if (charSpec.repeat) {
            state.nextStates.push(state);
          }

          // Return the new state
          return state;
        },

        // Find a list of child states matching the next character
        match: function match(ch) {
          // DEBUG "Processing `" + ch + "`:"
          var nextStates = this.nextStates,
              child,
              charSpec,
              chars;

          // DEBUG "  " + debugState(this)
          var returned = [];

          for (var i = 0, l = nextStates.length; i < l; i++) {
            child = nextStates[i];

            charSpec = child.charSpec;

            if (typeof (chars = charSpec.validChars) !== 'undefined') {
              if (chars.indexOf(ch) !== -1) {
                returned.push(child);
              }
            } else if (typeof (chars = charSpec.invalidChars) !== 'undefined') {
              if (chars.indexOf(ch) === -1) {
                returned.push(child);
              }
            }
          }

          return returned;
        } };
      oCreate = _Object$create || function (proto) {
        function F() {}
        F.prototype = proto;
        return new F();
      };

      RecognizeResults.prototype = oCreate({
        splice: Array.prototype.splice,
        slice: Array.prototype.slice,
        push: Array.prototype.push,
        length: 0,
        queryParams: null
      });
      RouteRecognizer = function RouteRecognizer() {
        this.rootState = new State();
        this.names = {};
      };

      RouteRecognizer.prototype = {
        add: function add(routes, options) {
          var currentState = this.rootState,
              regex = "^",
              specificity = {},
              handlers = [],
              allSegments = [],
              name;

          var isEmpty = true;

          for (var i = 0, l = routes.length; i < l; i++) {
            var route = routes[i],
                names = [];

            var segments = parse(route.path, names, specificity);

            allSegments = allSegments.concat(segments);

            for (var j = 0, m = segments.length; j < m; j++) {
              var segment = segments[j];

              if (segment instanceof EpsilonSegment) {
                continue;
              }

              isEmpty = false;

              // Add a "/" for the new segment
              currentState = currentState.put({ validChars: "/" });
              regex += "/";

              // Add a representation of the segment to the NFA and regex
              currentState = addSegment(currentState, segment);
              regex += segment.regex();
            }

            var handler = { handler: route.handler, names: names };
            handlers.push(handler);
          }

          if (isEmpty) {
            currentState = currentState.put({ validChars: "/" });
            regex += "/";
          }

          currentState.handlers = handlers;
          currentState.regex = new RegExp(regex + "$");
          currentState.specificity = specificity;

          if (name = options && options.as) {
            this.names[name] = {
              segments: allSegments,
              handlers: handlers
            };
          }
        },

        handlersFor: function handlersFor(name) {
          var route = this.names[name],
              result = [];
          if (!route) {
            throw new Error("There is no route named " + name);
          }

          for (var i = 0, l = route.handlers.length; i < l; i++) {
            result.push(route.handlers[i]);
          }

          return result;
        },

        hasRoute: function hasRoute(name) {
          return !!this.names[name];
        },

        generate: function generate(name, params) {
          var route = this.names[name],
              output = "";
          if (!route) {
            throw new Error("There is no route named " + name);
          }

          var segments = route.segments;

          for (var i = 0, l = segments.length; i < l; i++) {
            var segment = segments[i];

            if (segment instanceof EpsilonSegment) {
              continue;
            }

            output += "/";
            output += segment.generate(params);
          }

          if (output.charAt(0) !== '/') {
            output = '/' + output;
          }

          if (params && params.queryParams) {
            output += this.generateQueryString(params.queryParams);
          }

          return output;
        },

        generateQueryString: function generateQueryString(params) {
          var pairs = [];
          var keys = [];
          for (var key in params) {
            if (params.hasOwnProperty(key)) {
              keys.push(key);
            }
          }
          keys.sort();
          for (var i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            var value = params[key];
            if (value == null) {
              continue;
            }
            var pair = encodeURIComponent(key);
            if (isArray(value)) {
              for (var j = 0, l = value.length; j < l; j++) {
                var arrayPair = key + '[]' + '=' + encodeURIComponent(value[j]);
                pairs.push(arrayPair);
              }
            } else {
              pair += "=" + encodeURIComponent(value);
              pairs.push(pair);
            }
          }

          if (pairs.length === 0) {
            return '';
          }

          return "?" + pairs.join("&");
        },

        parseQueryString: function parseQueryString(queryString) {
          var pairs = queryString.split("&"),
              queryParams = {};
          for (var i = 0; i < pairs.length; i++) {
            var pair = pairs[i].split('='),
                key = decodeQueryParamPart(pair[0]),
                keyLength = key.length,
                isArray = false,
                value;
            if (pair.length === 1) {
              value = 'true';
            } else {
              //Handle arrays
              if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {
                isArray = true;
                key = key.slice(0, keyLength - 2);
                if (!queryParams[key]) {
                  queryParams[key] = [];
                }
              }
              value = pair[1] ? decodeQueryParamPart(pair[1]) : '';
            }
            if (isArray) {
              queryParams[key].push(value);
            } else {
              queryParams[key] = value;
            }
          }
          return queryParams;
        },

        recognize: function recognize(path) {
          var states = [this.rootState],
              pathLen,
              i,
              l,
              queryStart,
              queryParams = {},
              isSlashDropped = false;

          queryStart = path.indexOf('?');
          if (queryStart !== -1) {
            var queryString = path.substr(queryStart + 1, path.length);
            path = path.substr(0, queryStart);
            queryParams = this.parseQueryString(queryString);
          }

          path = decodeURI(path);

          // DEBUG GROUP path

          if (path.charAt(0) !== "/") {
            path = "/" + path;
          }

          pathLen = path.length;
          if (pathLen > 1 && path.charAt(pathLen - 1) === "/") {
            path = path.substr(0, pathLen - 1);
            isSlashDropped = true;
          }

          for (i = 0, l = path.length; i < l; i++) {
            states = recognizeChar(states, path.charAt(i));
            if (!states.length) {
              break;
            }
          }

          // END DEBUG GROUP

          var solutions = [];
          for (i = 0, l = states.length; i < l; i++) {
            if (states[i].handlers) {
              solutions.push(states[i]);
            }
          }

          states = sortSolutions(solutions);

          var state = solutions[0];

          if (state && state.handlers) {
            // if a trailing slash was dropped and a star segment is the last segment
            // specified, put the trailing slash back
            if (isSlashDropped && state.regex.source.slice(-5) === "(.+)$") {
              path = path + "/";
            }
            return findHandler(state, path, queryParams);
          }
        }
      };

      RouteRecognizer.prototype.map = map;

      RouteRecognizer.VERSION = '0.1.9';

      _export('default', RouteRecognizer);
    }
  };
});
$__System.register('1c', ['1b'], function (_export) {
  /* */
  'use strict';

  var RouteRecognizer, genQuery, _exports, resolver;

  /**
   * Resolve a relative path.
   *
   * @param {String} base
   * @param {String} relative
   * @param {Boolean} append
   * @return {String}
   */

  _export('warn', warn);

  /**
   * Forgiving check for a promise
   *
   * @param {Object} p
   * @return {Boolean}
   */

  _export('resolvePath', resolvePath);

  /**
   * Retrive a route config field from a component instance
   * OR a component contructor.
   *
   * @param {Function|Vue} component
   * @param {String} name
   * @return {*}
   */

  _export('isPromise', isPromise);

  /**
   * Resolve an async component factory. Have to do a dirty
   * mock here because of Vue core's internal API depends on
   * an ID check.
   *
   * @param {Object} handler
   * @param {Function} cb
   */

  _export('getRouteConfig', getRouteConfig);

  /**
   * Map the dynamic segments in a path to params.
   *
   * @param {String} path
   * @param {Object} params
   * @param {Object} query
   */

  _export('resolveAsyncComponent', resolveAsyncComponent);

  _export('mapParams', mapParams);

  /**
   * Warn stuff.
   *
   * @param {String} msg
   */

  function warn(msg) {
    /* istanbul ignore next */
    if (window.console) {
      console.warn('[vue-router] ' + msg);
      /* istanbul ignore if */
      if (!_exports.Vue || _exports.Vue.config.debug) {
        console.warn(new Error('warning stack trace:').stack);
      }
    }
  }

  function resolvePath(base, relative, append) {
    var query = base.match(/(\?.*)$/);
    if (query) {
      query = query[1];
      base = base.slice(0, -query.length);
    }
    // a query!
    if (relative.charAt(0) === '?') {
      return base + relative;
    }
    var stack = base.split('/');
    // remove trailing segment if:
    // - not appending
    // - appending to trailing slash (last segment is empty)
    if (!append || !stack[stack.length - 1]) {
      stack.pop();
    }
    // resolve relative path
    var segments = relative.replace(/^\//, '').split('/');
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (segment === '.') {
        continue;
      } else if (segment === '..') {
        stack.pop();
      } else {
        stack.push(segment);
      }
    }
    // ensure leading slash
    if (stack[0] !== '') {
      stack.unshift('');
    }
    return stack.join('/');
  }

  function isPromise(p) {
    return p && typeof p.then === 'function';
  }

  function getRouteConfig(component, name) {
    var options = component && (component.$options || component.options);
    return options && options.route && options.route[name];
  }

  function resolveAsyncComponent(handler, cb) {
    if (!resolver) {
      resolver = {
        resolve: _exports.Vue.prototype._resolveComponent,
        $options: {
          components: {
            _: handler.component
          }
        }
      };
    } else {
      resolver.$options.components._ = handler.component;
    }
    resolver.resolve('_', function (Component) {
      handler.component = Component;
      cb(Component);
    });
  }

  function mapParams(path, params, query) {
    if (params === undefined) params = {};

    path = path.replace(/:([^\/]+)/g, function (_, key) {
      var val = params[key];
      if (!val) {
        warn('param "' + key + '" not found when generating ' + 'path for "' + path + '" with params ' + JSON.stringify(params));
      }
      return val || '';
    });
    if (query) {
      path += genQuery(query);
    }
    return path;
  }

  return {
    setters: [function (_b) {
      RouteRecognizer = _b['default'];
    }],
    execute: function () {
      genQuery = RouteRecognizer.prototype.generateQueryString;

      // export default for holding the Vue reference
      _exports = {};

      _export('default', _exports);

      resolver = undefined;
    }
  };
});
$__System.register('1d', [], function (_export) {
  /* */
  'use strict';

  return {
    setters: [],
    execute: function () {
      _export('default', function (Vue) {

        var _ = Vue.util;

        // override Vue's init and destroy process to keep track of router instances
        var init = Vue.prototype._init;
        Vue.prototype._init = function (options) {
          var root = options._parent || options.parent || this;
          var route = root.$route;
          if (route) {
            route.router._children.push(this);
            if (!this.$route) {
              /* istanbul ignore if */
              if (this._defineMeta) {
                // 0.12
                this._defineMeta('$route', route);
              } else {
                // 1.0
                _.defineReactive(this, '$route', route);
              }
            }
          }
          init.call(this, options);
        };

        var destroy = Vue.prototype._destroy;
        Vue.prototype._destroy = function () {
          if (!this._isBeingDestroyed) {
            var route = this.$root.$route;
            if (route) {
              route.router._children.$remove(this);
            }
            destroy.apply(this, arguments);
          }
        };

        // 1.0 only: enable route mixins
        var strats = Vue.config.optionMergeStrategies;
        var hooksToMergeRE = /^(data|activate|deactivate)$/;

        if (strats) {
          strats.route = function (parentVal, childVal) {
            if (!childVal) return parentVal;
            if (!parentVal) return childVal;
            var ret = {};
            _.extend(ret, parentVal);
            for (var key in childVal) {
              var a = ret[key];
              var b = childVal[key];
              // for data, activate and deactivate, we need to merge them into
              // arrays similar to lifecycle hooks.
              if (a && hooksToMergeRE.test(key)) {
                ret[key] = (_.isArray(a) ? a : [a]).concat(b);
              } else {
                ret[key] = b;
              }
            }
            return ret;
          };
        }
      });
    }
  };
});
$__System.registerDynamic("1e", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("1f", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("20", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("21", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("22", ["21"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var aFunction = req('21');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("23", ["1f", "20", "22"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = req('1f'),
      core = req('20'),
      ctx = req('22'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("24", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("25", ["23", "20", "24"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = req('23'),
      core = req('20'),
      fails = req('24');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("26", ["1e", "25"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = req('1e');
  req('25')('freeze', function($freeze) {
    return function freeze(it) {
      return $freeze && isObject(it) ? $freeze(it) : it;
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("27", ["26", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('26');
  module.exports = req('20').Object.freeze;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("28", ["27"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('27'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.register("29", ["17", "28"], function (_export) {
  var _classCallCheck, _Object$freeze, internalKeysRE, Route;

  return {
    setters: [function (_) {
      _classCallCheck = _["default"];
    }, function (_2) {
      _Object$freeze = _2["default"];
    }],
    execute: function () {
      /* */
      "use strict";

      internalKeysRE = /^(component|subRoutes)$/;

      /**
       * Route Context Object
       *
       * @param {String} path
       * @param {Router} router
       */

      Route = function Route(path, router) {
        var _this = this;

        _classCallCheck(this, Route);

        var matched = router._recognizer.recognize(path);
        if (matched) {
          // copy all custom fields from route configs
          [].forEach.call(matched, function (match) {
            for (var key in match.handler) {
              if (!internalKeysRE.test(key)) {
                _this[key] = match.handler[key];
              }
            }
          });
          // set query and params
          this.query = matched.queryParams;
          this.params = [].reduce.call(matched, function (prev, cur) {
            if (cur.params) {
              for (var key in cur.params) {
                prev[key] = cur.params[key];
              }
            }
            return prev;
          }, {});
        }
        // expose path and router
        this.path = path;
        this.router = router;
        // for internal use
        this.matched = matched || router._notFoundHandler;
        // Important: freeze self to prevent observation
        _Object$freeze(this);
      };

      _export("default", Route);
    }
  };
});
$__System.registerDynamic("2a", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2b", ["2a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var defined = req('2a');
  module.exports = function(it) {
    return Object(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2c", ["2b", "25"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toObject = req('2b');
  req('25')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2d", ["2c", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('2c');
  module.exports = req('20').Object.keys;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("2e", ["2d"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('2d'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.register('2f', ['19', '2e', '1c'], function (_export) {
  var _Object$create, _Object$keys, getRouteConfig, resolveAsyncComponent, isPromise;

  /**
   * Determine the reusability of an existing router view.
   *
   * @param {Directive} view
   * @param {Object} handler
   * @param {Transition} transition
   */

  function canReuse(view, handler, transition) {
    var component = view.childVM;
    if (!component || !handler) {
      return false;
    }
    // important: check view.Component here because it may
    // have been changed in activate hook
    if (view.Component !== handler.component) {
      return false;
    }
    var canReuseFn = getRouteConfig(component, 'canReuse');
    return typeof canReuseFn === 'boolean' ? canReuseFn : canReuseFn ? canReuseFn.call(component, {
      to: transition.to,
      from: transition.from
    }) : true; // defaults to true
  }

  /**
   * Check if a component can deactivate.
   *
   * @param {Directive} view
   * @param {Transition} transition
   * @param {Function} next
   */

  function canDeactivate(view, transition, next) {
    var fromComponent = view.childVM;
    var hook = getRouteConfig(fromComponent, 'canDeactivate');
    if (!hook) {
      next();
    } else {
      transition.callHook(hook, fromComponent, next, {
        expectBoolean: true
      });
    }
  }

  /**
   * Check if a component can activate.
   *
   * @param {Object} handler
   * @param {Transition} transition
   * @param {Function} next
   */

  function canActivate(handler, transition, next) {
    resolveAsyncComponent(handler, function (Component) {
      // have to check due to async-ness
      if (transition.aborted) {
        return;
      }
      // determine if this component can be activated
      var hook = getRouteConfig(Component, 'canActivate');
      if (!hook) {
        next();
      } else {
        transition.callHook(hook, null, next, {
          expectBoolean: true
        });
      }
    });
  }

  /**
   * Call deactivate hooks for existing router-views.
   *
   * @param {Directive} view
   * @param {Transition} transition
   * @param {Function} next
   */

  function deactivate(view, transition, next) {
    var component = view.childVM;
    var hook = getRouteConfig(component, 'deactivate');
    if (!hook) {
      next();
    } else {
      transition.callHooks(hook, component, next);
    }
  }

  /**
   * Activate / switch component for a router-view.
   *
   * @param {Directive} view
   * @param {Transition} transition
   * @param {Number} depth
   * @param {Function} [cb]
   */

  function activate(view, transition, depth, cb, reuse) {
    var handler = transition.activateQueue[depth];
    if (!handler) {
      // fix 1.0.0-alpha.3 compat
      if (view._bound) {
        view.setComponent(null);
      }
      cb && cb();
      return;
    }

    var Component = view.Component = handler.component;
    var activateHook = getRouteConfig(Component, 'activate');
    var dataHook = getRouteConfig(Component, 'data');
    var waitForData = getRouteConfig(Component, 'waitForData');

    view.depth = depth;
    view.activated = false;

    var component = undefined;
    var loading = !!(dataHook && !waitForData);

    // "reuse" is a flag passed down when the parent view is
    // either reused via keep-alive or as a child of a kept-alive view.
    // of course we can only reuse if the current kept-alive instance
    // is of the correct type.
    reuse = reuse && view.childVM && view.childVM.constructor === Component;

    if (reuse) {
      // just reuse
      component = view.childVM;
      component.$loadingRouteData = loading;
    } else {
      // unbuild current component. this step also destroys
      // and removes all nested child views.
      view.unbuild(true);
      // handle keep-alive.
      // if the view has keep-alive, the child vm is not actually
      // destroyed - its nested views will still be in router's
      // view list. We need to removed these child views and
      // cache them on the child vm.
      if (view.keepAlive) {
        var views = transition.router._views;
        var i = views.indexOf(view);
        if (i > 0) {
          transition.router._views = views.slice(i);
          if (view.childVM) {
            view.childVM._routerViews = views.slice(0, i);
          }
        }
      }

      // build the new component. this will also create the
      // direct child view of the current one. it will register
      // itself as view.childView.
      component = view.build({
        _meta: {
          $loadingRouteData: loading
        }
      });
      // handle keep-alive.
      // when a kept-alive child vm is restored, we need to
      // add its cached child views into the router's view list,
      // and also properly update current view's child view.
      if (view.keepAlive) {
        component.$loadingRouteData = loading;
        var cachedViews = component._routerViews;
        if (cachedViews) {
          transition.router._views = cachedViews.concat(transition.router._views);
          view.childView = cachedViews[cachedViews.length - 1];
          component._routerViews = null;
        }
      }
    }

    // cleanup the component in case the transition is aborted
    // before the component is ever inserted.
    var cleanup = function cleanup() {
      component.$destroy();
    };

    // actually insert the component and trigger transition
    var insert = function insert() {
      if (reuse) {
        cb && cb();
        return;
      }
      var router = transition.router;
      if (router._rendered || router._transitionOnLoad) {
        view.transition(component);
      } else {
        // no transition on first render, manual transition
        /* istanbul ignore if */
        if (view.setCurrent) {
          // 0.12 compat
          view.setCurrent(component);
        } else {
          // 1.0
          view.childVM = component;
        }
        component.$before(view.anchor, null, false);
      }
      cb && cb();
    };

    // called after activation hook is resolved
    var afterActivate = function afterActivate() {
      view.activated = true;
      // activate the child view
      if (view.childView) {
        activate(view.childView, transition, depth + 1, null, reuse || view.keepAlive);
      }
      if (dataHook && waitForData) {
        // wait until data loaded to insert
        loadData(component, transition, dataHook, insert, cleanup);
      } else {
        // load data and insert at the same time
        if (dataHook) {
          loadData(component, transition, dataHook);
        }
        insert();
      }
    };

    if (activateHook) {
      transition.callHooks(activateHook, component, afterActivate, {
        cleanup: cleanup
      });
    } else {
      afterActivate();
    }
  }

  /**
   * Reuse a view, just reload data if necessary.
   *
   * @param {Directive} view
   * @param {Transition} transition
   */

  function reuse(view, transition) {
    var component = view.childVM;
    var dataHook = getRouteConfig(component, 'data');
    if (dataHook) {
      loadData(component, transition, dataHook);
    }
  }

  /**
   * Asynchronously load and apply data to component.
   *
   * @param {Vue} component
   * @param {Transition} transition
   * @param {Function} hook
   * @param {Function} cb
   * @param {Function} cleanup
   */

  function loadData(component, transition, hook, cb, cleanup) {
    component.$loadingRouteData = true;
    transition.callHooks(hook, component, function (data, onError) {
      // merge data from multiple data hooks
      if (Array.isArray(data) && data._needMerge) {
        data = data.reduce(function (res, obj) {
          if (isPlainObject(obj)) {
            _Object$keys(obj).forEach(function (key) {
              res[key] = obj[key];
            });
          }
          return res;
        }, _Object$create(null));
      }
      // handle promise sugar syntax
      var promises = [];
      if (isPlainObject(data)) {
        _Object$keys(data).forEach(function (key) {
          var val = data[key];
          if (isPromise(val)) {
            promises.push(val.then(function (resolvedVal) {
              component.$set(key, resolvedVal);
            }));
          } else {
            component.$set(key, val);
          }
        });
      }
      if (!promises.length) {
        component.$loadingRouteData = false;
        cb && cb();
      } else {
        promises[0].constructor.all(promises).then(function (_) {
          component.$loadingRouteData = false;
          cb && cb();
        }, onError);
      }
    }, {
      cleanup: cleanup,
      expectData: true
    });
  }

  function isPlainObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
  }
  return {
    setters: [function (_2) {
      _Object$create = _2['default'];
    }, function (_e) {
      _Object$keys = _e['default'];
    }, function (_c) {
      getRouteConfig = _c.getRouteConfig;
      resolveAsyncComponent = _c.resolveAsyncComponent;
      isPromise = _c.isPromise;
    }],
    execute: function () {
      /* */
      'use strict';

      _export('canReuse', canReuse);

      _export('canDeactivate', canDeactivate);

      _export('canActivate', canActivate);

      _export('deactivate', deactivate);

      _export('activate', activate);

      _export('reuse', reuse);
    }
  };
});
$__System.register('30', ['16', '17', '1c', '2f'], function (_export) {
  var _createClass, _classCallCheck, warn, mapParams, isPromise, activate, deactivate, reuse, canActivate, canDeactivate, canReuse, RouteTransition;

  function isPlainOjbect(val) {
    return Object.prototype.toString.call(val) === '[object Object]';
  }
  return {
    setters: [function (_2) {
      _createClass = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_c) {
      warn = _c.warn;
      mapParams = _c.mapParams;
      isPromise = _c.isPromise;
    }, function (_f) {
      activate = _f.activate;
      deactivate = _f.deactivate;
      reuse = _f.reuse;
      canActivate = _f.canActivate;
      canDeactivate = _f.canDeactivate;
      canReuse = _f.canReuse;
    }],
    execute: function () {
      /* */

      /**
       * A RouteTransition object manages the pipeline of a
       * router-view switching process. This is also the object
       * passed into user route hooks.
       *
       * @param {Router} router
       * @param {Route} to
       * @param {Route} from
       */

      'use strict';

      RouteTransition = (function () {
        function RouteTransition(router, to, from) {
          _classCallCheck(this, RouteTransition);

          this.router = router;
          this.to = to;
          this.from = from;
          this.next = null;
          this.aborted = false;
          this.done = false;

          // start by determine the queues

          // the deactivate queue is an array of router-view
          // directive instances that need to be deactivated,
          // deepest first.
          this.deactivateQueue = router._views;

          // check the default handler of the deepest match
          var matched = to.matched ? Array.prototype.slice.call(to.matched) : [];

          // the activate queue is an array of route handlers
          // that need to be activated
          this.activateQueue = matched.map(function (match) {
            return match.handler;
          });
        }

        /**
         * Abort current transition and return to previous location.
         */

        _createClass(RouteTransition, [{
          key: 'abort',
          value: function abort() {
            if (!this.aborted) {
              this.aborted = true;
              // if the root path throws an error during validation
              // on initial load, it gets caught in an infinite loop.
              var abortingOnLoad = !this.from.path && this.to.path === '/';
              if (!abortingOnLoad) {
                this.router.replace(this.from.path || '/');
              }
            }
          }

          /**
           * Abort current transition and redirect to a new location.
           *
           * @param {String} path
           */

        }, {
          key: 'redirect',
          value: function redirect(path) {
            if (!this.aborted) {
              this.aborted = true;
              if (typeof path === 'string') {
                path = mapParams(path, this.to.params, this.to.query);
              } else {
                path.params = path.params || this.to.params;
                path.query = path.query || this.to.query;
              }
              this.router.replace(path);
            }
          }

          /**
           * A router view transition's pipeline can be described as
           * follows, assuming we are transitioning from an existing
           * <router-view> chain [Component A, Component B] to a new
           * chain [Component A, Component C]:
           *
           *  A    A
           *  | => |
           *  B    C
           *
           * 1. Reusablity phase:
           *   -> canReuse(A, A)
           *   -> canReuse(B, C)
           *   -> determine new queues:
           *      - deactivation: [B]
           *      - activation: [C]
           *
           * 2. Validation phase:
           *   -> canDeactivate(B)
           *   -> canActivate(C)
           *
           * 3. Activation phase:
           *   -> deactivate(B)
           *   -> activate(C)
           *
           * Each of these steps can be asynchronous, and any
           * step can potentially abort the transition.
           *
           * @param {Function} cb
           */

        }, {
          key: 'start',
          value: function start(cb) {
            var transition = this;
            var daq = this.deactivateQueue;
            var aq = this.activateQueue;
            var rdaq = daq.slice().reverse();
            var reuseQueue = undefined;

            // 1. Reusability phase
            var i = undefined;
            for (i = 0; i < rdaq.length; i++) {
              if (!canReuse(rdaq[i], aq[i], transition)) {
                break;
              }
            }
            if (i > 0) {
              reuseQueue = rdaq.slice(0, i);
              daq = rdaq.slice(i).reverse();
              aq = aq.slice(i);
            }

            // 2. Validation phase
            transition.runQueue(daq, canDeactivate, function () {
              transition.runQueue(aq, canActivate, function () {
                transition.runQueue(daq, deactivate, function () {
                  // 3. Activation phase

                  // Update router current route
                  transition.router._onTransitionValidated(transition);

                  // trigger reuse for all reused views
                  reuseQueue && reuseQueue.forEach(function (view) {
                    reuse(view, transition);
                  });

                  // the root of the chain that needs to be replaced
                  // is the top-most non-reusable view.
                  if (daq.length) {
                    var view = daq[daq.length - 1];
                    var depth = reuseQueue ? reuseQueue.length : 0;
                    activate(view, transition, depth, cb);
                  } else {
                    cb();
                  }
                });
              });
            });
          }

          /**
           * Asynchronously and sequentially apply a function to a
           * queue.
           *
           * @param {Array} queue
           * @param {Function} fn
           * @param {Function} cb
           */

        }, {
          key: 'runQueue',
          value: function runQueue(queue, fn, cb) {
            var transition = this;
            step(0);
            function step(index) {
              if (index >= queue.length) {
                cb();
              } else {
                fn(queue[index], transition, function () {
                  step(index + 1);
                });
              }
            }
          }

          /**
           * Call a user provided route transition hook and handle
           * the response (e.g. if the user returns a promise).
           *
           * If the user neither expects an argument nor returns a
           * promise, the hook is assumed to be synchronous.
           *
           * @param {Function} hook
           * @param {*} [context]
           * @param {Function} [cb]
           * @param {Object} [options]
           *                 - {Boolean} expectBoolean
           *                 - {Boolean} expectData
           *                 - {Function} cleanup
           */

        }, {
          key: 'callHook',
          value: function callHook(hook, context, cb) {
            var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

            var _ref$expectBoolean = _ref.expectBoolean;
            var expectBoolean = _ref$expectBoolean === undefined ? false : _ref$expectBoolean;
            var _ref$expectData = _ref.expectData;
            var expectData = _ref$expectData === undefined ? false : _ref$expectData;
            var cleanup = _ref.cleanup;

            var transition = this;
            var nextCalled = false;

            // abort the transition
            var abort = function abort() {
              cleanup && cleanup();
              transition.abort();
            };

            // handle errors
            var onError = function onError(err) {
              // cleanup indicates an after-activation hook,
              // so instead of aborting we just let the transition
              // finish.
              cleanup ? next() : abort();
              if (err && !transition.router._suppress) {
                warn('Uncaught error during transition: ');
                throw err instanceof Error ? err : new Error(err);
              }
            };

            // advance the transition to the next step
            var next = function next(data) {
              if (nextCalled) {
                warn('transition.next() should be called only once.');
                return;
              }
              nextCalled = true;
              if (transition.aborted) {
                cleanup && cleanup();
                return;
              }
              cb && cb(data, onError);
            };

            // expose a clone of the transition object, so that each
            // hook gets a clean copy and prevent the user from
            // messing with the internals.
            var exposed = {
              to: transition.to,
              from: transition.from,
              abort: abort,
              next: next,
              redirect: function redirect() {
                transition.redirect.apply(transition, arguments);
              }
            };

            // actually call the hook
            var res = undefined;
            try {
              res = hook.call(context, exposed);
            } catch (err) {
              return onError(err);
            }

            // handle boolean/promise return values
            var resIsPromise = isPromise(res);
            if (expectBoolean) {
              if (typeof res === 'boolean') {
                res ? next() : abort();
              } else if (resIsPromise) {
                res.then(function (ok) {
                  ok ? next() : abort();
                }, onError);
              } else if (!hook.length) {
                next(res);
              }
            } else if (resIsPromise) {
              res.then(next, onError);
            } else if (expectData && isPlainOjbect(res) || !hook.length) {
              next(res);
            }
          }

          /**
           * Call a single hook or an array of async hooks in series.
           *
           * @param {Array} hooks
           * @param {*} context
           * @param {Function} cb
           * @param {Object} [options]
           */

        }, {
          key: 'callHooks',
          value: function callHooks(hooks, context, cb, options) {
            var _this = this;

            if (Array.isArray(hooks)) {
              (function () {
                var res = [];
                res._needMerge = true;
                var onError = undefined;
                _this.runQueue(hooks, function (hook, _, next) {
                  if (!_this.aborted) {
                    _this.callHook(hook, context, function (r, onError) {
                      if (r) res.push(r);
                      onError = onError;
                      next();
                    }, options);
                  }
                }, function () {
                  cb(res, onError);
                });
              })();
            } else {
              this.callHook(hooks, context, cb, options);
            }
          }
        }]);

        return RouteTransition;
      })();

      _export('default', RouteTransition);
    }
  };
});
$__System.register('31', ['1c', '2f'], function (_export) {
  /* */
  'use strict';

  var warn, activate;
  return {
    setters: [function (_c) {
      warn = _c.warn;
    }, function (_f) {
      activate = _f.activate;
    }],
    execute: function () {
      _export('default', function (Vue) {

        var _ = Vue.util;
        var componentDef =
        // 0.12
        Vue.directive('_component') ||
        // 1.0
        Vue.internalDirectives.component;
        // <router-view> extends the internal component directive
        var viewDef = _.extend({}, componentDef);

        // with some overrides
        _.extend(viewDef, {

          _isRouterView: true,

          bind: function bind() {
            var route = this.vm.$route;
            /* istanbul ignore if */
            if (!route) {
              warn('<router-view> can only be used inside a ' + 'router-enabled app.');
              return;
            }
            // force dynamic directive so v-component doesn't
            // attempt to build right now
            this._isDynamicLiteral = true;
            // finally, init by delegating to v-component
            componentDef.bind.call(this);

            // all we need to do here is registering this view
            // in the router. actual component switching will be
            // managed by the pipeline.
            var router = this.router = route.router;
            router._views.unshift(this);

            // note the views are in reverse order.
            var parentView = router._views[1];
            if (parentView) {
              // register self as a child of the parent view,
              // instead of activating now. This is so that the
              // child's activate hook is called after the
              // parent's has resolved.
              parentView.childView = this;
            }

            // handle late-rendered view
            // two possibilities:
            // 1. root view rendered after transition has been
            //    validated;
            // 2. child view rendered after parent view has been
            //    activated.
            var transition = route.router._currentTransition;
            if (!parentView && transition.done || parentView && parentView.activated) {
              var depth = parentView ? parentView.depth + 1 : 0;
              activate(this, transition, depth);
            }
          },

          unbind: function unbind() {
            this.router._views.$remove(this);
            componentDef.unbind.call(this);
          }
        });

        Vue.elementDirective('router-view', viewDef);
      });
    }
  };
});
$__System.register('32', ['1c'], function (_export) {
  /* */
  'use strict';

  var warn, trailingSlashRE, regexEscapeRE, queryStringRE;
  return {
    setters: [function (_c) {
      warn = _c.warn;
    }],
    execute: function () {
      trailingSlashRE = /\/$/;
      regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
      queryStringRE = /\?.*$/;

      // install v-link, which provides navigation support for
      // HTML5 history mode

      _export('default', function (Vue) {

        var _ = Vue.util;

        Vue.directive('link', {

          bind: function bind() {
            var _this = this;

            var vm = this.vm;
            /* istanbul ignore if */
            if (!vm.$route) {
              warn('v-link can only be used inside a ' + 'router-enabled app.');
              return;
            }
            // no need to handle click if link expects to be opened
            // in a new window/tab.
            /* istanbul ignore if */
            if (this.el.tagName === 'A' && this.el.getAttribute('target') === '_blank') {
              return;
            }
            // handle click
            var router = vm.$route.router;
            this.handler = function (e) {
              // don't redirect with control keys
              if (e.metaKey || e.ctrlKey || e.shiftKey) return;
              // don't redirect when preventDefault called
              if (e.defaultPrevented) return;
              // don't redirect on right click
              if (e.button !== 0) return;

              var target = _this.target;
              var go = function go(target) {
                e.preventDefault();
                if (target != null) {
                  router.go(target);
                }
              };

              if (_this.el.tagName === 'A' || e.target === _this.el) {
                // v-link on <a v-link="'path'">
                go(target);
              } else {
                // v-link delegate on <div v-link>
                var el = e.target;
                while (el && el.tagName !== 'A' && el !== _this.el) {
                  el = el.parentNode;
                }
                if (!el) return;
                if (el.tagName !== 'A' || !el.href) {
                  // allow not anchor
                  go(target);
                } else if (sameOrigin(el)) {
                  go({
                    path: el.pathname,
                    replace: target && target.replace,
                    append: target && target.append
                  });
                }
              }
            };
            this.el.addEventListener('click', this.handler);
            // manage active link class
            this.unwatch = vm.$watch('$route.path', _.bind(this.updateClasses, this));
          },

          update: function update(path) {
            var router = this.vm.$route.router;
            var append = undefined;
            this.target = path;
            if (_.isObject(path)) {
              append = path.append;
              this.exact = path.exact;
              this.prevActiveClass = this.activeClass;
              this.activeClass = path.activeClass;
            }
            path = this.path = router._stringifyPath(path);
            this.activeRE = path && !this.exact ? new RegExp('^' + path.replace(/\/$/, '').replace(regexEscapeRE, '\\$&') + '(\\/|$)') : null;
            this.updateClasses(this.vm.$route.path);
            var isAbsolute = path.charAt(0) === '/';
            // do not format non-hash relative paths
            var href = path && (router.mode === 'hash' || isAbsolute) ? router.history.formatPath(path, append) : path;
            if (this.el.tagName === 'A') {
              if (href) {
                this.el.href = href;
              } else {
                this.el.removeAttribute('href');
              }
            }
          },

          updateClasses: function updateClasses(path) {
            var el = this.el;
            var router = this.vm.$route.router;
            var activeClass = this.activeClass || router._linkActiveClass;
            // clear old class
            if (this.prevActiveClass !== activeClass) {
              _.removeClass(el, this.prevActiveClass);
            }
            // remove query string before matching
            var dest = this.path.replace(queryStringRE, '');
            path = path.replace(queryStringRE, '');
            // add new class
            if (this.exact) {
              if (dest === path ||
              // also allow additional trailing slash
              dest.charAt(dest.length - 1) !== '/' && dest === path.replace(trailingSlashRE, '')) {
                _.addClass(el, activeClass);
              } else {
                _.removeClass(el, activeClass);
              }
            } else {
              if (this.activeRE && this.activeRE.test(path)) {
                _.addClass(el, activeClass);
              } else {
                _.removeClass(el, activeClass);
              }
            }
          },

          unbind: function unbind() {
            this.el.removeEventListener('click', this.handler);
            this.unwatch && this.unwatch();
          }
        });

        function sameOrigin(link) {
          return link.protocol === location.protocol && link.hostname === location.hostname && link.port === location.port;
        }
      });
    }
  };
});
$__System.register('33', ['16', '17', '1c'], function (_export) {
  var _createClass, _classCallCheck, resolvePath, AbstractHistory;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_c) {
      resolvePath = _c.resolvePath;
    }],
    execute: function () {
      /* */
      'use strict';

      AbstractHistory = (function () {
        function AbstractHistory(_ref) {
          var onChange = _ref.onChange;

          _classCallCheck(this, AbstractHistory);

          this.onChange = onChange;
          this.currentPath = '/';
        }

        _createClass(AbstractHistory, [{
          key: 'start',
          value: function start() {
            this.onChange('/');
          }
        }, {
          key: 'stop',
          value: function stop() {
            // noop
          }
        }, {
          key: 'go',
          value: function go(path, replace, append) {
            path = this.currentPath = this.formatPath(path, append);
            this.onChange(path);
          }
        }, {
          key: 'formatPath',
          value: function formatPath(path, append) {
            return path.charAt(0) === '/' ? path : resolvePath(this.currentPath, path, append);
          }
        }]);

        return AbstractHistory;
      })();

      _export('default', AbstractHistory);
    }
  };
});
$__System.register('34', ['16', '17', '1c'], function (_export) {
  var _createClass, _classCallCheck, resolvePath, HashHistory;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_c) {
      resolvePath = _c.resolvePath;
    }],
    execute: function () {
      /* */
      'use strict';

      HashHistory = (function () {
        function HashHistory(_ref) {
          var hashbang = _ref.hashbang;
          var onChange = _ref.onChange;

          _classCallCheck(this, HashHistory);

          this.hashbang = hashbang;
          this.onChange = onChange;
        }

        _createClass(HashHistory, [{
          key: 'start',
          value: function start() {
            var self = this;
            this.listener = function () {
              var path = location.hash;
              var raw = path.replace(/^#!?/, '');
              // always
              if (raw.charAt(0) !== '/') {
                raw = '/' + raw;
              }
              var formattedPath = self.formatPath(raw);
              if (formattedPath !== path) {
                location.replace(formattedPath);
                return;
              }
              // determine query
              // note it's possible to have queries in both the actual URL
              // and the hash fragment itself.
              var query = location.search && path.indexOf('?') > -1 ? '&' + location.search.slice(1) : location.search;
              self.onChange(decodeURI(path.replace(/^#!?/, '') + query));
            };
            window.addEventListener('hashchange', this.listener);
            this.listener();
          }
        }, {
          key: 'stop',
          value: function stop() {
            window.removeEventListener('hashchange', this.listener);
          }
        }, {
          key: 'go',
          value: function go(path, replace, append) {
            path = this.formatPath(path, append);
            if (replace) {
              location.replace(path);
            } else {
              location.hash = path;
            }
          }
        }, {
          key: 'formatPath',
          value: function formatPath(path, append) {
            var isAbsoloute = path.charAt(0) === '/';
            var prefix = '#' + (this.hashbang ? '!' : '');
            return isAbsoloute ? prefix + path : prefix + resolvePath(location.hash.replace(/^#!?/, ''), path, append);
          }
        }]);

        return HashHistory;
      })();

      _export('default', HashHistory);
    }
  };
});
$__System.register('35', ['16', '17', '1c'], function (_export) {
  var _createClass, _classCallCheck, resolvePath, hashRE, HTML5History;

  return {
    setters: [function (_) {
      _createClass = _['default'];
    }, function (_2) {
      _classCallCheck = _2['default'];
    }, function (_c) {
      resolvePath = _c.resolvePath;
    }],
    execute: function () {
      /* */
      'use strict';

      hashRE = /#.*$/;

      HTML5History = (function () {
        function HTML5History(_ref) {
          var root = _ref.root;
          var onChange = _ref.onChange;

          _classCallCheck(this, HTML5History);

          if (root) {
            // make sure there's the starting slash
            if (root.charAt(0) !== '/') {
              root = '/' + root;
            }
            // remove trailing slash
            this.root = root.replace(/\/$/, '');
            this.rootRE = new RegExp('^\\' + this.root);
          } else {
            this.root = null;
          }
          this.onChange = onChange;
          // check base tag
          var baseEl = document.querySelector('base');
          this.base = baseEl && baseEl.getAttribute('href');
        }

        _createClass(HTML5History, [{
          key: 'start',
          value: function start() {
            var _this = this;

            this.listener = function (e) {
              var url = decodeURI(location.pathname + location.search);
              if (_this.root) {
                url = url.replace(_this.rootRE, '');
              }
              _this.onChange(url, e && e.state, location.hash);
            };
            window.addEventListener('popstate', this.listener);
            this.listener();
          }
        }, {
          key: 'stop',
          value: function stop() {
            window.removeEventListener('popstate', this.listener);
          }
        }, {
          key: 'go',
          value: function go(path, replace, append) {
            var url = this.formatPath(path, append);
            if (replace) {
              history.replaceState({}, '', url);
            } else {
              // record scroll position by replacing current state
              history.replaceState({
                pos: {
                  x: window.pageXOffset,
                  y: window.pageYOffset
                }
              }, '');
              // then push new state
              history.pushState({}, '', url);
            }
            var hashMatch = path.match(hashRE);
            var hash = hashMatch && hashMatch[0];
            path = url
            // strip hash so it doesn't mess up params
            .replace(hashRE, '')
            // remove root before matching
            .replace(this.rootRE, '');
            this.onChange(path, null, hash);
          }
        }, {
          key: 'formatPath',
          value: function formatPath(path, append) {
            return path.charAt(0) === '/'
            // absolute path
            ? this.root ? this.root + '/' + path.replace(/^\//, '') : path : resolvePath(this.base || location.pathname, path, append);
          }
        }]);

        return HTML5History;
      })();

      _export('default', HTML5History);
    }
  };
});
$__System.register('36', ['16', '17', '29', '30', '31', '32', '33', '34', '35', '1b', '1c', '1d'], function (_export) {
  var _createClass, _classCallCheck, Route, Transition, View, Link, AbstractHistory, HashHistory, HTML5History, RouteRecognizer, util, warn, mapParams, applyOverride, historyBackends, Vue, Router;

  /**
   * Allow directly passing components to a route
   * definition.
   *
   * @param {String} path
   * @param {Object} handler
   */

  function guardComponent(path, handler) {
    var comp = handler.component;
    if (Vue.util.isPlainObject(comp)) {
      comp = handler.component = Vue.extend(comp);
    }
    /* istanbul ignore if */
    if (typeof comp !== 'function') {
      handler.component = null;
      warn('invalid component for route "' + path + '".');
    }
  }

  /* Installation */

  return {
    setters: [function (_2) {
      _createClass = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      Route = _4['default'];
    }, function (_5) {
      Transition = _5['default'];
    }, function (_6) {
      View = _6['default'];
    }, function (_7) {
      Link = _7['default'];
    }, function (_8) {
      AbstractHistory = _8['default'];
    }, function (_9) {
      HashHistory = _9['default'];
    }, function (_10) {
      HTML5History = _10['default'];
    }, function (_b) {
      RouteRecognizer = _b['default'];
    }, function (_c) {
      util = _c['default'];
      warn = _c.warn;
      mapParams = _c.mapParams;
    }, function (_d) {
      applyOverride = _d['default'];
    }],
    execute: function () {
      /* */
      'use strict';

      historyBackends = {
        abstract: AbstractHistory,
        hash: HashHistory,
        html5: HTML5History
      };

      // late bind during install
      Vue = undefined;

      /**
       * Router constructor
       *
       * @param {Object} [options]
       */

      Router = (function () {
        function Router() {
          var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

          var _ref$hashbang = _ref.hashbang;
          var hashbang = _ref$hashbang === undefined ? true : _ref$hashbang;
          var _ref$abstract = _ref.abstract;
          var abstract = _ref$abstract === undefined ? false : _ref$abstract;
          var _ref$history = _ref.history;
          var history = _ref$history === undefined ? false : _ref$history;
          var _ref$saveScrollPosition = _ref.saveScrollPosition;
          var saveScrollPosition = _ref$saveScrollPosition === undefined ? false : _ref$saveScrollPosition;
          var _ref$transitionOnLoad = _ref.transitionOnLoad;
          var transitionOnLoad = _ref$transitionOnLoad === undefined ? false : _ref$transitionOnLoad;
          var _ref$suppressTransitionError = _ref.suppressTransitionError;
          var suppressTransitionError = _ref$suppressTransitionError === undefined ? false : _ref$suppressTransitionError;
          var _ref$root = _ref.root;
          var root = _ref$root === undefined ? null : _ref$root;
          var _ref$linkActiveClass = _ref.linkActiveClass;
          var linkActiveClass = _ref$linkActiveClass === undefined ? 'v-link-active' : _ref$linkActiveClass;

          _classCallCheck(this, Router);

          /* istanbul ignore if */
          if (!Router.installed) {
            throw new Error('Please install the Router with Vue.use() before ' + 'creating an instance.');
          }

          // Vue instances
          this.app = null;
          this._views = [];
          this._children = [];

          // route recognizer
          this._recognizer = new RouteRecognizer();
          this._guardRecognizer = new RouteRecognizer();

          // state
          this._started = false;
          this._startCb = null;
          this._currentRoute = {};
          this._currentTransition = null;
          this._previousTransition = null;
          this._notFoundHandler = null;
          this._notFoundRedirect = null;
          this._beforeEachHooks = [];
          this._afterEachHooks = [];

          // feature detection
          this._hasPushState = typeof window !== 'undefined' && window.history && window.history.pushState;

          // trigger transition on initial render?
          this._rendered = false;
          this._transitionOnLoad = transitionOnLoad;

          // history mode
          this._abstract = abstract;
          this._hashbang = hashbang;
          this._history = this._hasPushState && history;

          // other options
          this._saveScrollPosition = saveScrollPosition;
          this._linkActiveClass = linkActiveClass;
          this._suppress = suppressTransitionError;

          // create history object
          var inBrowser = Vue.util.inBrowser;
          this.mode = !inBrowser || this._abstract ? 'abstract' : this._history ? 'html5' : 'hash';

          var History = historyBackends[this.mode];
          var self = this;
          this.history = new History({
            root: root,
            hashbang: this._hashbang,
            onChange: function onChange(path, state, anchor) {
              self._match(path, state, anchor);
            }
          });
        }

        // API ===================================================

        /**
        * Register a map of top-level paths.
        *
        * @param {Object} map
        */

        _createClass(Router, [{
          key: 'map',
          value: function map(_map) {
            for (var route in _map) {
              this.on(route, _map[route]);
            }
          }

          /**
           * Register a single root-level path
           *
           * @param {String} rootPath
           * @param {Object} handler
           *                 - {String} component
           *                 - {Object} [subRoutes]
           *                 - {Boolean} [forceRefresh]
           *                 - {Function} [before]
           *                 - {Function} [after]
           */

        }, {
          key: 'on',
          value: function on(rootPath, handler) {
            if (rootPath === '*') {
              this._notFound(handler);
            } else {
              this._addRoute(rootPath, handler, []);
            }
          }

          /**
           * Set redirects.
           *
           * @param {Object} map
           */

        }, {
          key: 'redirect',
          value: function redirect(map) {
            for (var path in map) {
              this._addRedirect(path, map[path]);
            }
          }

          /**
           * Set aliases.
           *
           * @param {Object} map
           */

        }, {
          key: 'alias',
          value: function alias(map) {
            for (var path in map) {
              this._addAlias(path, map[path]);
            }
          }

          /**
           * Set global before hook.
           *
           * @param {Function} fn
           */

        }, {
          key: 'beforeEach',
          value: function beforeEach(fn) {
            this._beforeEachHooks.push(fn);
          }

          /**
           * Set global after hook.
           *
           * @param {Function} fn
           */

        }, {
          key: 'afterEach',
          value: function afterEach(fn) {
            this._afterEachHooks.push(fn);
          }

          /**
           * Navigate to a given path.
           * The path can be an object describing a named path in
           * the format of { name: '...', params: {}, query: {}}
           * The path is assumed to be already decoded, and will
           * be resolved against root (if provided)
           *
           * @param {String|Object} path
           * @param {Boolean} [replace]
           */

        }, {
          key: 'go',
          value: function go(path) {
            var replace = false;
            var append = false;
            if (Vue.util.isObject(path)) {
              replace = path.replace;
              append = path.append;
            }
            path = this._stringifyPath(path);
            if (path) {
              this.history.go(path, replace, append);
            }
          }

          /**
           * Short hand for replacing current path
           *
           * @param {String} path
           */

        }, {
          key: 'replace',
          value: function replace(path) {
            if (typeof path === 'string') {
              path = { path: path };
            }
            path.replace = true;
            this.go(path);
          }

          /**
           * Start the router.
           *
           * @param {VueConstructor} App
           * @param {String|Element} container
           * @param {Function} [cb]
           */

        }, {
          key: 'start',
          value: function start(App, container, cb) {
            /* istanbul ignore if */
            if (this._started) {
              warn('already started.');
              return;
            }
            this._started = true;
            this._startCb = cb;
            if (!this.app) {
              /* istanbul ignore if */
              if (!App || !container) {
                throw new Error('Must start vue-router with a component and a ' + 'root container.');
              }
              this._appContainer = container;
              var Ctor = this._appConstructor = typeof App === 'function' ? App : Vue.extend(App);
              // give it a name for better debugging
              Ctor.options.name = Ctor.options.name || 'RouterApp';
            }
            this.history.start();
          }

          /**
           * Stop listening to route changes.
           */

        }, {
          key: 'stop',
          value: function stop() {
            this.history.stop();
            this._started = false;
          }

          // Internal methods ======================================

          /**
          * Add a route containing a list of segments to the internal
          * route recognizer. Will be called recursively to add all
          * possible sub-routes.
          *
          * @param {String} path
          * @param {Object} handler
          * @param {Array} segments
          */

        }, {
          key: '_addRoute',
          value: function _addRoute(path, handler, segments) {
            guardComponent(path, handler);
            handler.path = path;
            handler.fullPath = (segments.reduce(function (path, segment) {
              return path + segment.path;
            }, '') + path).replace('//', '/');
            segments.push({
              path: path,
              handler: handler
            });
            this._recognizer.add(segments, {
              as: handler.name
            });
            // add sub routes
            if (handler.subRoutes) {
              for (var subPath in handler.subRoutes) {
                // recursively walk all sub routes
                this._addRoute(subPath, handler.subRoutes[subPath],
                // pass a copy in recursion to avoid mutating
                // across branches
                segments.slice());
              }
            }
          }

          /**
           * Set the notFound route handler.
           *
           * @param {Object} handler
           */

        }, {
          key: '_notFound',
          value: function _notFound(handler) {
            guardComponent('*', handler);
            this._notFoundHandler = [{ handler: handler }];
          }

          /**
           * Add a redirect record.
           *
           * @param {String} path
           * @param {String} redirectPath
           */

        }, {
          key: '_addRedirect',
          value: function _addRedirect(path, redirectPath) {
            if (path === '*') {
              this._notFoundRedirect = redirectPath;
            } else {
              this._addGuard(path, redirectPath, this.replace);
            }
          }

          /**
           * Add an alias record.
           *
           * @param {String} path
           * @param {String} aliasPath
           */

        }, {
          key: '_addAlias',
          value: function _addAlias(path, aliasPath) {
            this._addGuard(path, aliasPath, this._match);
          }

          /**
           * Add a path guard.
           *
           * @param {String} path
           * @param {String} mappedPath
           * @param {Function} handler
           */

        }, {
          key: '_addGuard',
          value: function _addGuard(path, mappedPath, _handler) {
            var _this = this;

            this._guardRecognizer.add([{
              path: path,
              handler: function handler(match, query) {
                var realPath = mapParams(mappedPath, match.params, query);
                _handler.call(_this, realPath);
              }
            }]);
          }

          /**
           * Check if a path matches any redirect records.
           *
           * @param {String} path
           * @return {Boolean} - if true, will skip normal match.
           */

        }, {
          key: '_checkGuard',
          value: function _checkGuard(path) {
            var matched = this._guardRecognizer.recognize(path);
            if (matched) {
              matched[0].handler(matched[0], matched.queryParams);
              return true;
            } else if (this._notFoundRedirect) {
              matched = this._recognizer.recognize(path);
              if (!matched) {
                this.replace(this._notFoundRedirect);
                return true;
              }
            }
          }

          /**
           * Match a URL path and set the route context on vm,
           * triggering view updates.
           *
           * @param {String} path
           * @param {Object} [state]
           * @param {String} [anchor]
           */

        }, {
          key: '_match',
          value: function _match(path, state, anchor) {
            var _this2 = this;

            if (this._checkGuard(path)) {
              return;
            }

            var currentRoute = this._currentRoute;
            var currentTransition = this._currentTransition;

            if (currentTransition) {
              if (currentTransition.to.path === path) {
                // do nothing if we have an active transition going to the same path
                return;
              } else if (currentRoute.path === path) {
                // We are going to the same path, but we also have an ongoing but
                // not-yet-validated transition. Abort that transition and reset to
                // prev transition.
                currentTransition.aborted = true;
                this._currentTransition = this._prevTransition;
                return;
              } else {
                // going to a totally different path. abort ongoing transition.
                currentTransition.aborted = true;
              }
            }

            // construct new route and transition context
            var route = new Route(path, this);
            var transition = new Transition(this, route, currentRoute);

            // current transition is updated right now.
            // however, current route will only be updated after the transition has
            // been validated.
            this._prevTransition = currentTransition;
            this._currentTransition = transition;

            if (!this.app) {
              // initial render
              this.app = new this._appConstructor({
                el: this._appContainer,
                _meta: {
                  $route: route
                }
              });
            }

            // check global before hook
            var beforeHooks = this._beforeEachHooks;
            var startTransition = function startTransition() {
              transition.start(function () {
                _this2._postTransition(route, state, anchor);
              });
            };

            if (beforeHooks.length) {
              transition.runQueue(beforeHooks, function (hook, _, next) {
                if (transition === _this2._currentTransition) {
                  transition.callHook(hook, null, next, {
                    expectBoolean: true
                  });
                }
              }, startTransition);
            } else {
              startTransition();
            }

            if (!this._rendered && this._startCb) {
              this._startCb.call(null);
            }

            // HACK:
            // set rendered to true after the transition start, so
            // that components that are acitvated synchronously know
            // whether it is the initial render.
            this._rendered = true;
          }

          /**
           * Set current to the new transition.
           * This is called by the transition object when the
           * validation of a route has succeeded.
           *
           * @param {Transition} transition
           */

        }, {
          key: '_onTransitionValidated',
          value: function _onTransitionValidated(transition) {
            // set current route
            var route = this._currentRoute = transition.to;
            // update route context for all children
            if (this.app.$route !== route) {
              this.app.$route = route;
              this._children.forEach(function (child) {
                child.$route = route;
              });
            }
            // call global after hook
            if (this._afterEachHooks.length) {
              this._afterEachHooks.forEach(function (hook) {
                return hook.call(null, {
                  to: transition.to,
                  from: transition.from
                });
              });
            }
            this._currentTransition.done = true;
          }

          /**
           * Handle stuff after the transition.
           *
           * @param {Route} route
           * @param {Object} [state]
           * @param {String} [anchor]
           */

        }, {
          key: '_postTransition',
          value: function _postTransition(route, state, anchor) {
            // handle scroll positions
            // saved scroll positions take priority
            // then we check if the path has an anchor
            var pos = state && state.pos;
            if (pos && this._saveScrollPosition) {
              Vue.nextTick(function () {
                window.scrollTo(pos.x, pos.y);
              });
            } else if (anchor) {
              Vue.nextTick(function () {
                var el = document.getElementById(anchor.slice(1));
                if (el) {
                  window.scrollTo(window.scrollX, el.offsetTop);
                }
              });
            }
          }

          /**
           * Normalize named route object / string paths into
           * a string.
           *
           * @param {Object|String|Number} path
           * @return {String}
           */

        }, {
          key: '_stringifyPath',
          value: function _stringifyPath(path) {
            if (path && typeof path === 'object') {
              if (path.name) {
                var params = path.params || {};
                if (path.query) {
                  params.queryParams = path.query;
                }
                return this._recognizer.generate(path.name, params);
              } else if (path.path) {
                var fullPath = path.path;
                if (path.query) {
                  var query = this._recognizer.generateQueryString(path.query);
                  if (fullPath.indexOf('?') > -1) {
                    fullPath += '&' + query.slice(1);
                  } else {
                    fullPath += query;
                  }
                }
                return fullPath;
              } else {
                return '';
              }
            } else {
              return path ? path + '' : '';
            }
          }
        }]);

        return Router;
      })();

      Router.installed = false;

      /**
       * Installation interface.
       * Install the necessary directives.
       */

      Router.install = function (externalVue) {
        /* istanbul ignore if */
        if (Router.installed) {
          warn('already installed.');
          return;
        }
        Vue = externalVue;
        applyOverride(Vue);
        View(Vue);
        Link(Vue);
        util.Vue = Vue;
        Router.installed = true;
      };

      // auto install
      /* istanbul ignore if */
      if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(Router);
      }

      _export('default', Router);
    }
  };
});
$__System.register("37", ["36"], function (_export) {
  "use strict";

  return {
    setters: [function (_) {
      var _exportObj = {};

      for (var _key in _) {
        if (_key !== "default") _exportObj[_key] = _[_key];
      }

      _exportObj["default"] = _["default"];

      _export(_exportObj);
    }],
    execute: function () {}
  };
});
$__System.registerDynamic("38", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  function E() {}
  E.prototype = {
    on: function(name, callback, ctx) {
      var e = this.e || (this.e = {});
      (e[name] || (e[name] = [])).push({
        fn: callback,
        ctx: ctx
      });
      return this;
    },
    once: function(name, callback, ctx) {
      var self = this;
      function listener() {
        self.off(name, listener);
        callback.apply(ctx, arguments);
      }
      ;
      listener._ = callback;
      return this.on(name, listener, ctx);
    },
    emit: function(name) {
      var data = [].slice.call(arguments, 1);
      var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
      var i = 0;
      var len = evtArr.length;
      for (i; i < len; i++) {
        evtArr[i].fn.apply(evtArr[i].ctx, data);
      }
      return this;
    },
    off: function(name, callback) {
      var e = this.e || (this.e = {});
      var evts = e[name];
      var liveEvents = [];
      if (evts && callback) {
        for (var i = 0,
            len = evts.length; i < len; i++) {
          if (evts[i].fn !== callback && evts[i].fn._ !== callback)
            liveEvents.push(evts[i]);
        }
      }
      (liveEvents.length) ? e[name] = liveEvents : delete e[name];
      return this;
    }
  };
  module.exports = E;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("39", ["38"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('38');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3a", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Date.now || now;
  function now() {
    return new Date().getTime();
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3b", ["3a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('3a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3c", ["3b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var now = req('3b');
  module.exports = function debounce(func, wait, immediate) {
    var timeout,
        args,
        context,
        timestamp,
        result;
    if (null == wait)
      wait = 100;
    function later() {
      var last = now() - timestamp;
      if (last < wait && last > 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout)
            context = args = null;
        }
      }
    }
    ;
    return function debounced() {
      context = this;
      args = arguments;
      timestamp = now();
      var callNow = immediate && !timeout;
      if (!timeout)
        timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }
      return result;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3d", ["3c"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('3c');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3e", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  module.exports = {
    'scroller': {
      eventName: 'scroll',
      opts: {
        debounce: 1000 / 60,
        props: {
          x: 'pageXOffset',
          y: 'pageYOffset'
        },
        immediate: true
      }
    },
    'resizer': {
      eventName: 'resize',
      opts: {
        debounce: 150,
        props: {
          width: 'innerWidth',
          height: 'innerHeight'
        },
        immediate: true
      }
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("3f", ["39", "3d", "3e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var EventEmitter = req('39'),
      debounce = req('3d'),
      events = req('3e'),
      hasOwnProp = Object.prototype.hasOwnProperty,
      toString = Object.prototype.toString;
  var windowsill = module.exports = function(eventName, opts) {
    var sill = {
      opts: opts,
      eventName: eventName,
      bound: false,
      _emitter: new EventEmitter(),
      addListener: function(listener) {
        this._emitter.on(eventName, listener);
      },
      removeListener: function(listener) {
        if (listener)
          this._emitter.off(eventName, listener);
      },
      onEvent: function(event) {
        if (this.opts.beforeEvent)
          this.opts.beforeEvent(this, event);
        if (opts.props) {
          var props = opts.props;
          for (var prop in props) {
            if (hasOwnProp.call(props, prop)) {
              var inherited = props[prop];
              if (isString(inherited)) {
                this[prop] = window[inherited];
              } else {
                this[prop] = inherited;
              }
            }
          }
        }
        this._emitter.emit(this.eventName, eventName);
        if (this.opts.afterEvent)
          this.opts.afterEvent(this, event);
      },
      debounced: function() {},
      bind: function() {
        if (this.bound)
          return;
        this.bound = true;
        window.addEventListener(this.eventName, this.debounced);
      },
      unbind: function() {
        if (!this.bound)
          return;
        this.bound = false;
        this._emitter.off(eventName);
        window.removeEventListener(this.eventName, this.debounced);
      }
    };
    sill.debounced = debounce(sill.onEvent.bind(sill), opts.debounce);
    if (opts.immediate)
      sill.onEvent();
    return sill;
  };
  windowsill.enable = function(sillName) {
    var sill = windowsill[sillName];
    if (!sill)
      return console.log('[windowsill] has no registered sill with the name "' + sillName + '".');
    if (sill.bound)
      return;
    sill.bind();
  };
  windowsill.disable = function(sillName) {
    var sill = windowsill[sillName];
    if (!sill)
      return console.log('[windowsill] has no registered sill with the name "' + sillName + '".');
    if (!sill.bound)
      return;
    sill.unbind();
  };
  for (var prop in events) {
    if (hasOwnProp.call(events, prop)) {
      var sillEvent = events[prop];
      windowsill[prop] = windowsill(sillEvent.eventName, sillEvent.opts);
    }
  }
  function isString(string) {
    return toString.call(string) === '[object String]';
  }
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("40", ["3f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('3f');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("41", ["40"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var windowsill = req('40');
  var resizer = windowsill.resizer;
  module.exports = {
    ready: function() {
      windowsill.enable('resizer');
      resizer.addListener(this._resize);
      this._resize();
    },
    beforeDestroy: function() {
      resizer.removeListener(this._resize);
    },
    methods: {_resize: function() {
        this.$emit('resize', {
          width: resizer.width,
          height: resizer.height
        });
      }}
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("42", ["41"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('41');
  global.define = __define;
  return module.exports;
});

$__System.register("43", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("44", [], function() {
  return "<div class=\"SchedulerPanel container u-max-full-width\">\n    <div class=\"view-box\">\n\n        <!-- Calendar Panel -->\n        <div class=\"side-left\">\n            <div id=\"calendar-panel\" class=\"main-panel\" v-el:calendar-panel>\n                <calendar-panel v-if=\"!selected_calendar._surrogate\" :calendar=\"selected_calendar\"></calendar-panel>\n            </div>\n        </div>\n\n        <!-- Side Panel -->\n        <div class=\"side-right\">\n\n            <!-- Events Panel -->\n            <div id=\"events-panel\" class=\"side-panel\" v-el:events-panel>\n                <events-panel v-if=\"!selected_calendar._surrogate\" :calendar=\"selected_calendar\"></events-panel>\n            </div>\n\n            <!-- Resource Panel -->\n            <div id=\"resource-panel\" class=\"side-panel\" v-el:resources-panel>\n                <resources-panel v-if=\"!selected_calendar._surrogate\" :calendar=\"selected_calendar\"></resources-panel>\n            </div>\n\n        </div>\n    </div>\n</div>\n";
});

_removeDefine();
})();
$__System.registerDynamic("45", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("46", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ceil = Math.ceil,
      floor = Math.floor;
  module.exports = function(it) {
    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("47", ["46", "2a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = req('46'),
      defined = req('2a');
  module.exports = function(TO_STRING) {
    return function(that, pos) {
      var s = String(defined(that)),
          i = toInteger(pos),
          l = s.length,
          a,
          b;
      if (i < 0 || i >= l)
        return TO_STRING ? '' : undefined;
      a = s.charCodeAt(i);
      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("48", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("49", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(bitmap, value) {
    return {
      enumerable: !(bitmap & 1),
      configurable: !(bitmap & 2),
      writable: !(bitmap & 4),
      value: value
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4a", ["24"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = !req('24')(function() {
    return Object.defineProperty({}, 'a', {get: function() {
        return 7;
      }}).a != 7;
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4b", ["13", "49", "4a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = req('13'),
      createDesc = req('49');
  module.exports = req('4a') ? function(object, key, value) {
    return $.setDesc(object, key, createDesc(1, value));
  } : function(object, key, value) {
    object[key] = value;
    return object;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4c", ["4b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('4b');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4d", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var hasOwnProperty = {}.hasOwnProperty;
  module.exports = function(it, key) {
    return hasOwnProperty.call(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4e", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("4f", ["1f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var global = req('1f'),
      SHARED = '__core-js_shared__',
      store = global[SHARED] || (global[SHARED] = {});
  module.exports = function(key) {
    return store[key] || (store[key] = {});
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("50", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var id = 0,
      px = Math.random();
  module.exports = function(key) {
    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("51", ["4f", "50", "1f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var store = req('4f')('wks'),
      uid = req('50'),
      Symbol = req('1f').Symbol;
  module.exports = function(name) {
    return store[name] || (store[name] = Symbol && Symbol[name] || (Symbol || uid)('Symbol.' + name));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("52", ["13", "4d", "51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var def = req('13').setDesc,
      has = req('4d'),
      TAG = req('51')('toStringTag');
  module.exports = function(it, tag, stat) {
    if (it && !has(it = stat ? it : it.prototype, TAG))
      def(it, TAG, {
        configurable: true,
        value: tag
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("53", ["13", "49", "52", "4b", "51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = req('13'),
      descriptor = req('49'),
      setToStringTag = req('52'),
      IteratorPrototype = {};
  req('4b')(IteratorPrototype, req('51')('iterator'), function() {
    return this;
  });
  module.exports = function(Constructor, NAME, next) {
    Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});
    setToStringTag(Constructor, NAME + ' Iterator');
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("54", ["48", "23", "4c", "4b", "4d", "4e", "53", "52", "13", "51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var LIBRARY = req('48'),
      $export = req('23'),
      redefine = req('4c'),
      hide = req('4b'),
      has = req('4d'),
      Iterators = req('4e'),
      $iterCreate = req('53'),
      setToStringTag = req('52'),
      getProto = req('13').getProto,
      ITERATOR = req('51')('iterator'),
      BUGGY = !([].keys && 'next' in [].keys()),
      FF_ITERATOR = '@@iterator',
      KEYS = 'keys',
      VALUES = 'values';
  var returnThis = function() {
    return this;
  };
  module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
    $iterCreate(Constructor, NAME, next);
    var getMethod = function(kind) {
      if (!BUGGY && kind in proto)
        return proto[kind];
      switch (kind) {
        case KEYS:
          return function keys() {
            return new Constructor(this, kind);
          };
        case VALUES:
          return function values() {
            return new Constructor(this, kind);
          };
      }
      return function entries() {
        return new Constructor(this, kind);
      };
    };
    var TAG = NAME + ' Iterator',
        DEF_VALUES = DEFAULT == VALUES,
        VALUES_BUG = false,
        proto = Base.prototype,
        $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT],
        $default = $native || getMethod(DEFAULT),
        methods,
        key;
    if ($native) {
      var IteratorPrototype = getProto($default.call(new Base));
      setToStringTag(IteratorPrototype, TAG, true);
      if (!LIBRARY && has(proto, FF_ITERATOR))
        hide(IteratorPrototype, ITERATOR, returnThis);
      if (DEF_VALUES && $native.name !== VALUES) {
        VALUES_BUG = true;
        $default = function values() {
          return $native.call(this);
        };
      }
    }
    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
      hide(proto, ITERATOR, $default);
    }
    Iterators[NAME] = $default;
    Iterators[TAG] = returnThis;
    if (DEFAULT) {
      methods = {
        values: DEF_VALUES ? $default : getMethod(VALUES),
        keys: IS_SET ? $default : getMethod(KEYS),
        entries: !DEF_VALUES ? $default : getMethod('entries')
      };
      if (FORCED)
        for (key in methods) {
          if (!(key in proto))
            redefine(proto, key, methods[key]);
        }
      else
        $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
    }
    return methods;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("55", ["47", "54"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $at = req('47')(true);
  req('54')(String, 'String', function(iterated) {
    this._t = String(iterated);
    this._i = 0;
  }, function() {
    var O = this._t,
        index = this._i,
        point;
    if (index >= O.length)
      return {
        value: undefined,
        done: true
      };
    point = $at(O, index);
    this._i += point.length;
    return {
      value: point,
      done: false
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("56", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function() {};
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("57", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(done, value) {
    return {
      value: value,
      done: !!done
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("58", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("59", ["58"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = req('58');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5a", ["59", "2a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var IObject = req('59'),
      defined = req('2a');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5b", ["56", "57", "4e", "5a", "54"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var addToUnscopables = req('56'),
      step = req('57'),
      Iterators = req('4e'),
      toIObject = req('5a');
  module.exports = req('54')(Array, 'Array', function(iterated, kind) {
    this._t = toIObject(iterated);
    this._i = 0;
    this._k = kind;
  }, function() {
    var O = this._t,
        kind = this._k,
        index = this._i++;
    if (!O || index >= O.length) {
      this._t = undefined;
      return step(1);
    }
    if (kind == 'keys')
      return step(0, index);
    if (kind == 'values')
      return step(0, O[index]);
    return step(0, [index, O[index]]);
  }, 'values');
  Iterators.Arguments = Iterators.Array;
  addToUnscopables('keys');
  addToUnscopables('values');
  addToUnscopables('entries');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5c", ["5b", "4e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('5b');
  var Iterators = req('4e');
  Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5d", ["4c"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var redefine = req('4c');
  module.exports = function(target, src) {
    for (var key in src)
      redefine(target, key, src[key]);
    return target;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5e", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(it, Constructor, name) {
    if (!(it instanceof Constructor))
      throw TypeError(name + ": use the 'new' operator!");
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("5f", ["1e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = req('1e');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("60", ["5f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = req('5f');
  module.exports = function(iterator, fn, value, entries) {
    try {
      return entries ? fn(anObject(value)[0], value[1]) : fn(value);
    } catch (e) {
      var ret = iterator['return'];
      if (ret !== undefined)
        anObject(ret.call(iterator));
      throw e;
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("61", ["4e", "51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var Iterators = req('4e'),
      ITERATOR = req('51')('iterator'),
      ArrayProto = Array.prototype;
  module.exports = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("62", ["46"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toInteger = req('46'),
      min = Math.min;
  module.exports = function(it) {
    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("63", ["58", "51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = req('58'),
      TAG = req('51')('toStringTag'),
      ARG = cof(function() {
        return arguments;
      }()) == 'Arguments';
  module.exports = function(it) {
    var O,
        T,
        B;
    return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof(T = (O = Object(it))[TAG]) == 'string' ? T : ARG ? cof(O) : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("64", ["63", "51", "4e", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = req('63'),
      ITERATOR = req('51')('iterator'),
      Iterators = req('4e');
  module.exports = req('20').getIteratorMethod = function(it) {
    if (it != undefined)
      return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("65", ["22", "60", "61", "5f", "62", "64"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ctx = req('22'),
      call = req('60'),
      isArrayIter = req('61'),
      anObject = req('5f'),
      toLength = req('62'),
      getIterFn = req('64');
  module.exports = function(iterable, entries, fn, that) {
    var iterFn = getIterFn(iterable),
        f = ctx(fn, that, entries ? 2 : 1),
        index = 0,
        length,
        step,
        iterator;
    if (typeof iterFn != 'function')
      throw TypeError(iterable + ' is not iterable!');
    if (isArrayIter(iterFn))
      for (length = toLength(iterable.length); length > index; index++) {
        entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
      }
    else
      for (iterator = iterFn.call(iterable); !(step = iterator.next()).done; ) {
        call(iterator, f, step.value, entries);
      }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("66", ["20", "13", "4a", "51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var core = req('20'),
      $ = req('13'),
      DESCRIPTORS = req('4a'),
      SPECIES = req('51')('species');
  module.exports = function(KEY) {
    var C = core[KEY];
    if (DESCRIPTORS && C && !C[SPECIES])
      $.setDesc(C, SPECIES, {
        configurable: true,
        get: function() {
          return this;
        }
      });
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("67", ["13", "4b", "5d", "22", "5e", "2a", "65", "54", "57", "50", "4d", "1e", "66", "4a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = req('13'),
      hide = req('4b'),
      redefineAll = req('5d'),
      ctx = req('22'),
      strictNew = req('5e'),
      defined = req('2a'),
      forOf = req('65'),
      $iterDefine = req('54'),
      step = req('57'),
      ID = req('50')('id'),
      $has = req('4d'),
      isObject = req('1e'),
      setSpecies = req('66'),
      DESCRIPTORS = req('4a'),
      isExtensible = Object.isExtensible || isObject,
      SIZE = DESCRIPTORS ? '_s' : 'size',
      id = 0;
  var fastKey = function(it, create) {
    if (!isObject(it))
      return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
    if (!$has(it, ID)) {
      if (!isExtensible(it))
        return 'F';
      if (!create)
        return 'E';
      hide(it, ID, ++id);
    }
    return 'O' + it[ID];
  };
  var getEntry = function(that, key) {
    var index = fastKey(key),
        entry;
    if (index !== 'F')
      return that._i[index];
    for (entry = that._f; entry; entry = entry.n) {
      if (entry.k == key)
        return entry;
    }
  };
  module.exports = {
    getConstructor: function(wrapper, NAME, IS_MAP, ADDER) {
      var C = wrapper(function(that, iterable) {
        strictNew(that, C, NAME);
        that._i = $.create(null);
        that._f = undefined;
        that._l = undefined;
        that[SIZE] = 0;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, that[ADDER], that);
      });
      redefineAll(C.prototype, {
        clear: function clear() {
          for (var that = this,
              data = that._i,
              entry = that._f; entry; entry = entry.n) {
            entry.r = true;
            if (entry.p)
              entry.p = entry.p.n = undefined;
            delete data[entry.i];
          }
          that._f = that._l = undefined;
          that[SIZE] = 0;
        },
        'delete': function(key) {
          var that = this,
              entry = getEntry(that, key);
          if (entry) {
            var next = entry.n,
                prev = entry.p;
            delete that._i[entry.i];
            entry.r = true;
            if (prev)
              prev.n = next;
            if (next)
              next.p = prev;
            if (that._f == entry)
              that._f = next;
            if (that._l == entry)
              that._l = prev;
            that[SIZE]--;
          }
          return !!entry;
        },
        forEach: function forEach(callbackfn) {
          var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3),
              entry;
          while (entry = entry ? entry.n : this._f) {
            f(entry.v, entry.k, this);
            while (entry && entry.r)
              entry = entry.p;
          }
        },
        has: function has(key) {
          return !!getEntry(this, key);
        }
      });
      if (DESCRIPTORS)
        $.setDesc(C.prototype, 'size', {get: function() {
            return defined(this[SIZE]);
          }});
      return C;
    },
    def: function(that, key, value) {
      var entry = getEntry(that, key),
          prev,
          index;
      if (entry) {
        entry.v = value;
      } else {
        that._l = entry = {
          i: index = fastKey(key, true),
          k: key,
          v: value,
          p: prev = that._l,
          n: undefined,
          r: false
        };
        if (!that._f)
          that._f = entry;
        if (prev)
          prev.n = entry;
        that[SIZE]++;
        if (index !== 'F')
          that._i[index] = entry;
      }
      return that;
    },
    getEntry: getEntry,
    setStrong: function(C, NAME, IS_MAP) {
      $iterDefine(C, NAME, function(iterated, kind) {
        this._t = iterated;
        this._k = kind;
        this._l = undefined;
      }, function() {
        var that = this,
            kind = that._k,
            entry = that._l;
        while (entry && entry.r)
          entry = entry.p;
        if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
          that._t = undefined;
          return step(1);
        }
        if (kind == 'keys')
          return step(0, entry.k);
        if (kind == 'values')
          return step(0, entry.v);
        return step(0, [entry.k, entry.v]);
      }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);
      setSpecies(NAME);
    }
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("68", ["13", "1f", "23", "24", "4b", "5d", "65", "5e", "1e", "52", "4a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = req('13'),
      global = req('1f'),
      $export = req('23'),
      fails = req('24'),
      hide = req('4b'),
      redefineAll = req('5d'),
      forOf = req('65'),
      strictNew = req('5e'),
      isObject = req('1e'),
      setToStringTag = req('52'),
      DESCRIPTORS = req('4a');
  module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
    var Base = global[NAME],
        C = Base,
        ADDER = IS_MAP ? 'set' : 'add',
        proto = C && C.prototype,
        O = {};
    if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function() {
      new C().entries().next();
    }))) {
      C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
      redefineAll(C.prototype, methods);
    } else {
      C = wrapper(function(target, iterable) {
        strictNew(target, C, NAME);
        target._c = new Base;
        if (iterable != undefined)
          forOf(iterable, IS_MAP, target[ADDER], target);
      });
      $.each.call('add,clear,delete,forEach,get,has,set,keys,values,entries'.split(','), function(KEY) {
        var IS_ADDER = KEY == 'add' || KEY == 'set';
        if (KEY in proto && !(IS_WEAK && KEY == 'clear'))
          hide(C.prototype, KEY, function(a, b) {
            if (!IS_ADDER && IS_WEAK && !isObject(a))
              return KEY == 'get' ? undefined : false;
            var result = this._c[KEY](a === 0 ? 0 : a, b);
            return IS_ADDER ? this : result;
          });
      });
      if ('size' in proto)
        $.setDesc(C.prototype, 'size', {get: function() {
            return this._c.size;
          }});
    }
    setToStringTag(C, NAME);
    O[NAME] = C;
    $export($export.G + $export.W + $export.F, O);
    if (!IS_WEAK)
      common.setStrong(C, NAME, IS_MAP);
    return C;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("69", ["67", "68"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var strong = req('67');
  req('68')('Map', function(get) {
    return function Map() {
      return get(this, arguments.length > 0 ? arguments[0] : undefined);
    };
  }, {
    get: function get(key) {
      var entry = strong.getEntry(this, key);
      return entry && entry.v;
    },
    set: function set(key, value) {
      return strong.def(this, key === 0 ? 0 : key, value);
    }
  }, strong, true);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6a", ["65", "63"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var forOf = req('65'),
      classof = req('63');
  module.exports = function(NAME) {
    return function toJSON() {
      if (classof(this) != NAME)
        throw TypeError(NAME + "#toJSON isn't generic");
      var arr = [];
      forOf(this, false, arr.push, arr);
      return arr;
    };
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6b", ["23", "6a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = req('23');
  $export($export.P, 'Map', {toJSON: req('6a')('Map')});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6c", ["45", "55", "5c", "69", "6b", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('45');
  req('55');
  req('5c');
  req('69');
  req('6b');
  module.exports = req('20').Map;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6d", ["6c"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('6c'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6e", ["5f", "64", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = req('5f'),
      get = req('64');
  module.exports = req('20').getIterator = function(it) {
    var iterFn = get(it);
    if (typeof iterFn != 'function')
      throw TypeError(it + ' is not iterable!');
    return anObject(iterFn.call(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("6f", ["5c", "55", "6e"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('5c');
  req('55');
  module.exports = req('6e');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("70", ["6f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('6f'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("71", ["51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var ITERATOR = req('51')('iterator'),
      SAFE_CLOSING = false;
  try {
    var riter = [7][ITERATOR]();
    riter['return'] = function() {
      SAFE_CLOSING = true;
    };
    Array.from(riter, function() {
      throw 2;
    });
  } catch (e) {}
  module.exports = function(exec, skipClosing) {
    if (!skipClosing && !SAFE_CLOSING)
      return false;
    var safe = false;
    try {
      var arr = [7],
          iter = arr[ITERATOR]();
      iter.next = function() {
        safe = true;
      };
      arr[ITERATOR] = function() {
        return iter;
      };
      exec(arr);
    } catch (e) {}
    return safe;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("72", ["22", "23", "2b", "60", "61", "62", "64", "71"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var ctx = req('22'),
      $export = req('23'),
      toObject = req('2b'),
      call = req('60'),
      isArrayIter = req('61'),
      toLength = req('62'),
      getIterFn = req('64');
  $export($export.S + $export.F * !req('71')(function(iter) {
    Array.from(iter);
  }), 'Array', {from: function from(arrayLike) {
      var O = toObject(arrayLike),
          C = typeof this == 'function' ? this : Array,
          $$ = arguments,
          $$len = $$.length,
          mapfn = $$len > 1 ? $$[1] : undefined,
          mapping = mapfn !== undefined,
          index = 0,
          iterFn = getIterFn(O),
          length,
          result,
          step,
          iterator;
      if (mapping)
        mapfn = ctx(mapfn, $$len > 2 ? $$[2] : undefined, 2);
      if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
        for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
          result[index] = mapping ? call(iterator, mapfn, [step.value, index], true) : step.value;
        }
      } else {
        length = toLength(O.length);
        for (result = new C(length); length > index; index++) {
          result[index] = mapping ? mapfn(O[index], index) : O[index];
        }
      }
      result.length = index;
      return result;
    }});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("73", ["55", "72", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('55');
  req('72');
  module.exports = req('20').Array.from;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("74", ["73"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('73'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.register("75", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("76", [], function() {
  return "<!-- TemplateName -->\n<div class=\"CalendarPanel\" v-el:panel>\n    <!-- Content -->\n    <div id=\"calendar-panel-title\" class=\"list-header calendar-header u-full-width\" v-if=\"calendar\" v-el:header>\n        <span class=\"navigation\">\n            <i  class=\"fa fa-fw fa-caret-left no-select cursor-pointer title-caret transition-base\"\n               @click=\"page('prev')\"></i>\n\n            <h4 class=\"calendar-title\"> {{ display_title }} </h4>\n\n            <i class=\"fa fa-fw fa-caret-right no-select cursor-pointer title-caret transition-base\"\n               @click=\"page()\"></i>\n        </span>\n\n        <span class=\"settings pull-right no-select\">\n            <i class=\"fa fa-fw fa-cog cursor-pointer transition-base\"></i>\n        </span>\n\n        <span class=\"view-options pull-right no-select\">\n            <i  class=\"fa fa-fw fa-th cursor-pointer transition-base\"\n               :class=\"{'selected-view': 'month' == view.name}\"\n               @click=\"change_view('month')\"></i>\n\n            <i  class=\"fa fa-fw fa-th-large cursor-pointer transition-base\"\n               :class=\"{'selected-view': 'agendaWeek' == view.name}\"\n               @click=\"change_view('agendaWeek')\"></i>\n\n            <i  class=\"fa fa-fw fa-square cursor-pointer transition-base\"\n               :class=\"{'selected-view': 'agendaDay' == view.name}\"\n               @click=\"change_view('agendaDay')\"></i>\n        </span>\n    </div>\n    <div id=\"calendar\" v-el:calendar></div>\n    <!-- <ul>\n        <li v-for=\"booking in grouped_bookings\">\n            {{booking | json 4}}\n        </li>\n    </ul> -->\n</div>\n";
});

_removeDefine();
})();
$__System.registerDynamic("77", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    ;
    (function(global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
    }(this, function() {
      'use strict';
      var hookCallback;
      function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }
      function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, 'toString')) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, 'valueOf')) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      function valid__isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m);
          m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated;
          if (m._strict) {
            m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
          }
        }
        return m._isValid;
      }
      function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      function isUndefined(input) {
        return input === void 0;
      }
      var momentProperties = utils_hooks__hooks.momentProperties = [];
      function copyConfig(to, from) {
        var i,
            prop,
            val;
        if (!isUndefined(from._isAMomentObject)) {
          to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
          to._i = from._i;
        }
        if (!isUndefined(from._f)) {
          to._f = from._f;
        }
        if (!isUndefined(from._l)) {
          to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
          to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
          to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
          to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
          to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
          to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
          to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
          for (i in momentProperties) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
              to[prop] = val;
            }
          }
        }
        return to;
      }
      var updateInProgress = false;
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (updateInProgress === false) {
          updateInProgress = true;
          utils_hooks__hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number);
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
          if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function Locale() {}
      var locales = {};
      var globalLocale;
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
      }
      function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split('-');
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split('-') : null;
          while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
              return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return null;
      }
      function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && !isUndefined(module) && module && module.exports) {
          try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            locale_locales__getSetGlobalLocale(oldLocale);
          } catch (e) {}
        }
        return locales[name];
      }
      function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = locale_locales__getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, values) {
        if (values !== null) {
          values.abbr = name;
          locales[name] = locales[name] || new Locale();
          locales[name].set(values);
          locale_locales__getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function locale_locales__getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale = loadLocale(key);
          if (locale) {
            return locale;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            get_set__set(this, unit, value);
            utils_hooks__hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get_set__get(this, unit);
          }
        };
      }
      function get_set__get(mom, unit) {
        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }
      function get_set__set(mom, unit, value) {
        if (mom.isValid()) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
      function getSet(units, value) {
        var unit;
        if (typeof units === 'object') {
          for (unit in units) {
            this.set(unit, units[unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
      var formatFunctions = {};
      var formatTokenFunctions = {};
      function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
          func = function() {
            return this[callback]();
          };
        }
        if (token) {
          formatTokenFunctions[token] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal) {
          formatTokenFunctions[ordinal] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
      }
      function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = '';
          for (i = 0; i < length; i++) {
            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
          }
          return output;
        };
      }
      function formatMoment(m, format) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
      }
      function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format;
      }
      var match1 = /\d/;
      var match2 = /\d\d/;
      var match3 = /\d{3}/;
      var match4 = /\d{4}/;
      var match6 = /[+-]?\d{6}/;
      var match1to2 = /\d\d?/;
      var match3to4 = /\d\d\d\d?/;
      var match5to6 = /\d\d\d\d\d\d?/;
      var match1to3 = /\d{1,3}/;
      var match1to4 = /\d{1,4}/;
      var match1to6 = /[+-]?\d{1,6}/;
      var matchUnsigned = /\d+/;
      var matchSigned = /[+-]?\d+/;
      var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
      var matchWord = /[0-9]*(a[mn]\s?)?['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF\-]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
      var regexes = {};
      function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict) {
          return (isStrict && strictRegex) ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }
      var tokens = {};
      function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === 'string') {
          token = [token];
        }
        if (typeof callback === 'number') {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        for (i = 0; i < token.length; i++) {
          tokens[token[i]] = func;
        }
      }
      function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token);
        });
      }
      function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token);
        }
      }
      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;
      function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
      }
      addFormatToken('M', ['MM', 2], 'Mo', function() {
        return this.month() + 1;
      });
      addFormatToken('MMM', 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
      });
      addFormatToken('MMMM', 0, 0, function(format) {
        return this.localeData().months(this, format);
      });
      addUnitAlias('month', 'M');
      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', matchWord);
      addRegexToken('MMMM', matchWord);
      addParseToken(['M', 'MM'], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths(m, format) {
        return isArray(this._months) ? this._months[m.month()] : this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }
      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sept_Oct_Nov_Dec'.split('_');
      function localeMonthsShort(m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }
      function localeMonthsParse(monthName, format, strict) {
        var i,
            mom,
            regex;
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = create_utc__createUTC([2000, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
          }
          if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === 'string') {
          value = mom.localeData().monthsParse(value);
          if (typeof value !== 'number') {
            return mom;
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          utils_hooks__hooks.updateOffset(this, true);
          return this;
        } else {
          return get_set__get(this, 'Month');
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && !isUndefined(console) && console.warn) {
          console.warn('Deprecation warning: ' + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (firstTime) {
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      utils_hooks__hooks.suppressDeprecationWarnings = false;
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
      var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];
      var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
      function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || ' ') + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = 'Z';
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
          utils_hooks__hooks.createFromInputFallback(config);
        }
      }
      utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'https://github.com/moment/moment/issues/1407 for more info.', function(config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
      });
      function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
        return date;
      }
      function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
        return date;
      }
      addFormatToken(0, ['YY', 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
      addUnitAlias('year', 'y');
      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);
      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function(input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function(input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }
      utils_hooks__hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };
      var getSetYear = makeGetSet('FullYear', false);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy,
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
          return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse)) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w,
            weekYear,
            week,
            weekday,
            dow,
            doy,
            temp,
            weekdayOverflow;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
          week = defaults(w.w, 1);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      utils_hooks__hooks.ISO_8601 = function() {};
      function configFromStringAndFormat(config) {
        if (config._f === utils_hooks__hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = undefined;
        }
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
          return hour;
        }
        if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
          isPm = locale.isPM(meridiem);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore;
        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (!valid__isValid(tempConfig)) {
            continue;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, 'd');
          res._nextDay = undefined;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i,
            format = config._f;
        config._locale = config._locale || locale_locales__getLocale(config._l);
        if (input === null || (format === undefined && input === '')) {
          return valid__createInvalid({nullInput: true});
        }
        if (typeof input === 'string') {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
          configFromStringAndArray(config);
        } else if (format) {
          configFromStringAndFormat(config);
        } else if (isDate(input)) {
          config._d = input;
        } else {
          configFromInput(config);
        }
        if (!valid__isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
          config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(+input);
        } else if (typeof input === 'string') {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (typeof(input) === 'object') {
          configFromObject(config);
        } else if (typeof(input) === 'number') {
          config._d = new Date(input);
        } else {
          utils_hooks__hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (typeof(locale) === 'boolean') {
          strict = locale;
          locale = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
      }
      function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
      }
      var prototypeMin = deprecate('moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548', function() {
        var other = local__createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return valid__createInvalid();
        }
      });
      var prototypeMax = deprecate('moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548', function() {
        var other = local__createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return valid__createInvalid();
        }
      });
      function pickBy(fn, moments) {
        var res,
            i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args);
      }
      var now = Date.now || function() {
        return +(new Date());
      };
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = locale_locales__getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
          var offset = this.utcOffset();
          var sign = '+';
          if (offset < 0) {
            offset = -offset;
            sign = '-';
          }
          return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
      }
      offset('Z', ':');
      offset('ZZ', '');
      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === '+' ? minutes : -minutes;
      }
      function cloneWithOffset(input, model) {
        var res,
            diff;
        if (model._isUTC) {
          res = model.clone();
          diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
          res._d.setTime(+res._d + diff);
          utils_hooks__hooks.updateOffset(res, false);
          return res;
        } else {
          return local__createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }
      utils_hooks__hooks.updateOffset = function() {};
      function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
          } else if (Math.abs(input) < 16) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, 'm');
          }
          if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              utils_hooks__hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== 'string') {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm) {
          this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
          this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;
      var isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
      function create__createDuration(input, key) {
        var duration = input,
            match = null,
            sign,
            ret,
            diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (typeof input === 'number') {
          duration = {};
          if (key) {
            duration[key] = input;
          } else {
            duration.milliseconds = input;
          }
        } else if (!!(match = aspNetRegex.exec(input))) {
          sign = (match[1] === '-') ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(match[MILLISECOND]) * sign
          };
        } else if (!!(match = isoRegex.exec(input))) {
          sign = (match[1] === '-') ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            d: parseIso(match[4], sign),
            h: parseIso(match[5], sign),
            m: parseIso(match[6], sign),
            s: parseIso(match[7], sign),
            w: parseIso(match[8], sign)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
          diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
          ret._locale = input._locale;
        }
        return ret;
      }
      create__createDuration.fn = Duration.prototype;
      function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(',', '.'));
        return (isNaN(res) ? 0 : res) * sign;
      }
      function positiveMomentsDifference(base, other) {
        var res = {
          milliseconds: 0,
          months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return {
            milliseconds: 0,
            months: 0
          };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur,
              tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
            tmp = val;
            val = period;
            period = tmp;
          }
          val = typeof val === 'string' ? +val : val;
          dur = create__createDuration(val, period);
          add_subtract__addSubtract(this, dur, direction);
          return this;
        };
      }
      function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
          mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
          get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
          setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
          utils_hooks__hooks.updateOffset(mom, days || months);
        }
      }
      var add_subtract__add = createAdder(1, 'add');
      var add_subtract__subtract = createAdder(-1, 'subtract');
      function moment_calendar__calendar(time, formats) {
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
          return +this > +localInput;
        } else {
          return +localInput < +this.clone().startOf(units);
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
          return +this < +localInput;
        } else {
          return +this.clone().endOf(units) < +localInput;
        }
      }
      function isBetween(from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
          return +this === +localInput;
        } else {
          inputMs = +localInput;
          return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that,
            zoneDelta,
            delta,
            output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        if (units === 'year' || units === 'month' || units === 'quarter') {
          output = monthDiff(this, that);
          if (units === 'quarter') {
            output = output / 3;
          } else if (units === 'year') {
            output = output / 12;
          }
        } else {
          delta = this - that;
          output = units === 'second' ? delta / 1e3 : units === 'minute' ? delta / 6e4 : units === 'hour' ? delta / 36e5 : units === 'day' ? (delta - zoneDelta) / 864e5 : units === 'week' ? (delta - zoneDelta) / 6048e5 : delta;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust);
      }
      utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }
      function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
          if (isFunction(Date.prototype.toISOString)) {
            return this.toDate().toISOString();
          } else {
            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
          }
        } else {
          return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
      }
      function format(inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
          return create__createDuration({
            to: this,
            from: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
          return create__createDuration({
            from: this,
            to: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === undefined) {
          return this._locale._abbr;
        } else {
          newLocaleData = locale_locales__getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
        if (key === undefined) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      function startOf(units) {
        units = normalizeUnits(units);
        switch (units) {
          case 'year':
            this.month(0);
          case 'quarter':
          case 'month':
            this.date(1);
          case 'week':
          case 'isoWeek':
          case 'day':
            this.hours(0);
          case 'hour':
            this.minutes(0);
          case 'minute':
            this.seconds(0);
          case 'second':
            this.milliseconds(0);
        }
        if (units === 'week') {
          this.weekday(0);
        }
        if (units === 'isoWeek') {
          this.isoWeekday(1);
        }
        if (units === 'quarter') {
          this.month(Math.floor(this.month() / 3) * 3);
        }
        return this;
      }
      function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
          return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
      }
      function to_type__valueOf() {
        return +this._d - ((this._offset || 0) * 60000);
      }
      function unix() {
        return Math.floor(+this / 1000);
      }
      function toDate() {
        return this._offset ? new Date(+this) : this._d;
      }
      function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : 'null';
      }
      function moment_valid__isValid() {
        return valid__isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken(0, ['gg', 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ['GG', 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
      }
      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');
      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');
      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);
      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken('Q', 0, 'Qo', 'quarter');
      addUnitAlias('quarter', 'Q');
      addRegexToken('Q', match1);
      addParseToken('Q', function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');
      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);
      addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
      }
      addFormatToken('D', ['DD', 2], 'Do', 'date');
      addUnitAlias('date', 'D');
      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
      });
      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
      });
      var getSetDayOfMonth = makeGetSet('Date', true);
      addFormatToken('d', 0, 'do', 'day');
      addFormatToken('dd', 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
      });
      addFormatToken('ddd', 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
      });
      addFormatToken('dddd', 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
      });
      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');
      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');
      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', matchWord);
      addRegexToken('ddd', matchWord);
      addRegexToken('dddd', matchWord);
      addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
        week[token] = toInt(input);
      });
      function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
          return input;
        }
        return null;
      }
      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays(m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
      }
      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort(m) {
        return this._weekdaysShort[m.day()];
      }
      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin(m) {
        return this._weekdaysMin[m.day()];
      }
      function localeWeekdaysParse(weekdayName, format, strict) {
        var i,
            mom,
            regex;
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = local__createLocal([2000, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
          }
          if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, 'd');
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
      }
      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
      addUnitAlias('dayOfYear', 'DDD');
      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('hmm', 0, 0, function() {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken('hmmss', 0, 0, function() {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken('Hmm', 0, 0, function() {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken('Hmmss', 0, 0, function() {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem('a', true);
      meridiem('A', false);
      addUnitAlias('hour', 'h');
      function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
      }
      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);
      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['a', 'A'], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return ((input + '').toLowerCase().charAt(0) === 'p');
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
          return isLower ? 'pm' : 'PM';
        } else {
          return isLower ? 'am' : 'AM';
        }
      }
      var getSetHour = makeGetSet('Hours', true);
      addFormatToken('m', ['mm', 2], 0, 'minute');
      addUnitAlias('minute', 'm');
      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);
      var getSetMinute = makeGetSet('Minutes', false);
      addFormatToken('s', ['ss', 2], 0, 'second');
      addUnitAlias('second', 's');
      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);
      var getSetSecond = makeGetSet('Seconds', false);
      addFormatToken('S', 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ['SS', 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function() {
        return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function() {
        return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
        return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
        return this.millisecond() * 1000000;
      });
      addUnitAlias('millisecond', 'ms');
      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);
      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }
      for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
      }
      var getSetMillisecond = makeGetSet('Milliseconds', false);
      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');
      function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
      }
      function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
      }
      var momentPrototype__proto = Moment.prototype;
      momentPrototype__proto.add = add_subtract__add;
      momentPrototype__proto.calendar = moment_calendar__calendar;
      momentPrototype__proto.clone = clone;
      momentPrototype__proto.diff = diff;
      momentPrototype__proto.endOf = endOf;
      momentPrototype__proto.format = format;
      momentPrototype__proto.from = from;
      momentPrototype__proto.fromNow = fromNow;
      momentPrototype__proto.to = to;
      momentPrototype__proto.toNow = toNow;
      momentPrototype__proto.get = getSet;
      momentPrototype__proto.invalidAt = invalidAt;
      momentPrototype__proto.isAfter = isAfter;
      momentPrototype__proto.isBefore = isBefore;
      momentPrototype__proto.isBetween = isBetween;
      momentPrototype__proto.isSame = isSame;
      momentPrototype__proto.isSameOrAfter = isSameOrAfter;
      momentPrototype__proto.isSameOrBefore = isSameOrBefore;
      momentPrototype__proto.isValid = moment_valid__isValid;
      momentPrototype__proto.lang = lang;
      momentPrototype__proto.locale = locale;
      momentPrototype__proto.localeData = localeData;
      momentPrototype__proto.max = prototypeMax;
      momentPrototype__proto.min = prototypeMin;
      momentPrototype__proto.parsingFlags = parsingFlags;
      momentPrototype__proto.set = getSet;
      momentPrototype__proto.startOf = startOf;
      momentPrototype__proto.subtract = add_subtract__subtract;
      momentPrototype__proto.toArray = toArray;
      momentPrototype__proto.toObject = toObject;
      momentPrototype__proto.toDate = toDate;
      momentPrototype__proto.toISOString = moment_format__toISOString;
      momentPrototype__proto.toJSON = toJSON;
      momentPrototype__proto.toString = toString;
      momentPrototype__proto.unix = unix;
      momentPrototype__proto.valueOf = to_type__valueOf;
      momentPrototype__proto.creationData = creationData;
      momentPrototype__proto.year = getSetYear;
      momentPrototype__proto.isLeapYear = getIsLeapYear;
      momentPrototype__proto.weekYear = getSetWeekYear;
      momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
      momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
      momentPrototype__proto.month = getSetMonth;
      momentPrototype__proto.daysInMonth = getDaysInMonth;
      momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
      momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
      momentPrototype__proto.weeksInYear = getWeeksInYear;
      momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
      momentPrototype__proto.date = getSetDayOfMonth;
      momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
      momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
      momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
      momentPrototype__proto.dayOfYear = getSetDayOfYear;
      momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
      momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
      momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
      momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
      momentPrototype__proto.utcOffset = getSetOffset;
      momentPrototype__proto.utc = setOffsetToUTC;
      momentPrototype__proto.local = setOffsetToLocal;
      momentPrototype__proto.parseZone = setOffsetToParsedOffset;
      momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
      momentPrototype__proto.isDST = isDaylightSavingTime;
      momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
      momentPrototype__proto.isLocal = isLocal;
      momentPrototype__proto.isUtcOffset = isUtcOffset;
      momentPrototype__proto.isUtc = isUtc;
      momentPrototype__proto.isUTC = isUtc;
      momentPrototype__proto.zoneAbbr = getZoneAbbr;
      momentPrototype__proto.zoneName = getZoneName;
      momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
      var momentPrototype = momentPrototype__proto;
      function moment__createUnix(input) {
        return local__createLocal(input * 1000);
      }
      function moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone();
      }
      var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
      };
      function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key];
        return isFunction(output) ? output.call(mom, now) : output;
      }
      var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
      };
      function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
          return format;
        }
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
          return val.slice(1);
        });
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = 'Invalid date';
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = '%d';
      var defaultOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace('%d', number);
      }
      function preParsePostFormat(string) {
        return string;
      }
      var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
      };
      function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }
      function locale_set__set(config) {
        var prop,
            i;
        for (i in config) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this['_' + i] = prop;
          }
        }
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
      }
      var prototype__proto = Locale.prototype;
      prototype__proto._calendar = defaultCalendar;
      prototype__proto.calendar = locale_calendar__calendar;
      prototype__proto._longDateFormat = defaultLongDateFormat;
      prototype__proto.longDateFormat = longDateFormat;
      prototype__proto._invalidDate = defaultInvalidDate;
      prototype__proto.invalidDate = invalidDate;
      prototype__proto._ordinal = defaultOrdinal;
      prototype__proto.ordinal = ordinal;
      prototype__proto._ordinalParse = defaultOrdinalParse;
      prototype__proto.preparse = preParsePostFormat;
      prototype__proto.postformat = preParsePostFormat;
      prototype__proto._relativeTime = defaultRelativeTime;
      prototype__proto.relativeTime = relative__relativeTime;
      prototype__proto.pastFuture = pastFuture;
      prototype__proto.set = locale_set__set;
      prototype__proto.months = localeMonths;
      prototype__proto._months = defaultLocaleMonths;
      prototype__proto.monthsShort = localeMonthsShort;
      prototype__proto._monthsShort = defaultLocaleMonthsShort;
      prototype__proto.monthsParse = localeMonthsParse;
      prototype__proto.week = localeWeek;
      prototype__proto._week = defaultLocaleWeek;
      prototype__proto.firstDayOfYear = localeFirstDayOfYear;
      prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
      prototype__proto.weekdays = localeWeekdays;
      prototype__proto._weekdays = defaultLocaleWeekdays;
      prototype__proto.weekdaysMin = localeWeekdaysMin;
      prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
      prototype__proto.weekdaysShort = localeWeekdaysShort;
      prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
      prototype__proto.weekdaysParse = localeWeekdaysParse;
      prototype__proto.isPM = localeIsPM;
      prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
      prototype__proto.meridiem = localeMeridiem;
      function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
      }
      function list(format, index, field, count, setter) {
        if (typeof format === 'number') {
          index = format;
          format = undefined;
        }
        format = format || '';
        if (index != null) {
          return lists__get(format, index, field, setter);
        }
        var i;
        var out = [];
        for (i = 0; i < count; i++) {
          out[i] = lists__get(format, i, field, setter);
        }
        return out;
      }
      function lists__listMonths(format, index) {
        return list(format, index, 'months', 12, 'month');
      }
      function lists__listMonthsShort(format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
      }
      function lists__listWeekdays(format, index) {
        return list(format, index, 'weekdays', 7, 'day');
      }
      function lists__listWeekdaysShort(format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
      }
      function lists__listWeekdaysMin(format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
      }
      locale_locales__getSetGlobalLocale('en', {
        monthsParse: [/^jan/i, /^feb/i, /^mar/i, /^apr/i, /^may/i, /^jun/i, /^jul/i, /^aug/i, /^sep/i, /^oct/i, /^nov/i, /^dec/i],
        longMonthsParse: [/^january$/i, /^february$/i, /^march$/i, /^april$/i, /^may$/i, /^june$/i, /^july$/i, /^august$/i, /^september$/i, /^october$/i, /^november$/i, /^december$/i],
        shortMonthsParse: [/^jan$/i, /^feb$/i, /^mar$/i, /^apr$/i, /^may$/i, /^jun$/i, /^jul$/i, /^aug/i, /^sept?$/i, /^oct$/i, /^nov$/i, /^dec$/i],
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10,
              output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
          return number + output;
        }
      });
      utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
      utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
      var mathAbs = Math.abs;
      function duration_abs__abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
      }
      function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds,
            minutes,
            hours,
            years,
            monthsFromDays;
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
          milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
          days = 0;
          months = 0;
        }
        data.milliseconds = milliseconds % 1000;
        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
      }
      function daysToMonths(days) {
        return days * 4800 / 146097;
      }
      function monthsToDays(months) {
        return months * 146097 / 4800;
      }
      function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === 'month' || units === 'year') {
          days = this._days + milliseconds / 864e5;
          months = this._months + daysToMonths(days);
          return units === 'month' ? months : months / 12;
        } else {
          days = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case 'week':
              return days / 7 + milliseconds / 6048e5;
            case 'day':
              return days + milliseconds / 864e5;
            case 'hour':
              return days * 24 + milliseconds / 36e5;
            case 'minute':
              return days * 1440 + milliseconds / 6e4;
            case 'second':
              return days * 86400 + milliseconds / 1000;
            case 'millisecond':
              return Math.floor(days * 864e5) + milliseconds;
            default:
              throw new Error('Unknown unit ' + units);
          }
        }
      }
      function duration_as__valueOf() {
        return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs('ms');
      var asSeconds = makeAs('s');
      var asMinutes = makeAs('m');
      var asHours = makeAs('h');
      var asDays = makeAs('d');
      var asWeeks = makeAs('w');
      var asMonths = makeAs('M');
      var asYears = makeAs('y');
      function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + 's']();
      }
      function makeGetter(name) {
        return function() {
          return this._data[name];
        };
      }
      var milliseconds = makeGetter('milliseconds');
      var seconds = makeGetter('seconds');
      var minutes = makeGetter('minutes');
      var hours = makeGetter('hours');
      var days = makeGetter('days');
      var months = makeGetter('months');
      var years = makeGetter('years');
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round;
      var thresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));
        var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
      }
      function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
          return false;
        }
        if (limit === undefined) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
      }
      function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
        if (withSuffix) {
          output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
      }
      var iso_string__abs = Math.abs;
      function iso_string__toISOString() {
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days = iso_string__abs(this._days);
        var months = iso_string__abs(this._months);
        var minutes,
            hours,
            years;
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();
        if (!total) {
          return 'P0D';
        }
        return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
      }
      var duration_prototype__proto = Duration.prototype;
      duration_prototype__proto.abs = duration_abs__abs;
      duration_prototype__proto.add = duration_add_subtract__add;
      duration_prototype__proto.subtract = duration_add_subtract__subtract;
      duration_prototype__proto.as = as;
      duration_prototype__proto.asMilliseconds = asMilliseconds;
      duration_prototype__proto.asSeconds = asSeconds;
      duration_prototype__proto.asMinutes = asMinutes;
      duration_prototype__proto.asHours = asHours;
      duration_prototype__proto.asDays = asDays;
      duration_prototype__proto.asWeeks = asWeeks;
      duration_prototype__proto.asMonths = asMonths;
      duration_prototype__proto.asYears = asYears;
      duration_prototype__proto.valueOf = duration_as__valueOf;
      duration_prototype__proto._bubble = bubble;
      duration_prototype__proto.get = duration_get__get;
      duration_prototype__proto.milliseconds = milliseconds;
      duration_prototype__proto.seconds = seconds;
      duration_prototype__proto.minutes = minutes;
      duration_prototype__proto.hours = hours;
      duration_prototype__proto.days = days;
      duration_prototype__proto.weeks = weeks;
      duration_prototype__proto.months = months;
      duration_prototype__proto.years = years;
      duration_prototype__proto.humanize = humanize;
      duration_prototype__proto.toISOString = iso_string__toISOString;
      duration_prototype__proto.toString = iso_string__toISOString;
      duration_prototype__proto.toJSON = iso_string__toISOString;
      duration_prototype__proto.locale = locale;
      duration_prototype__proto.localeData = localeData;
      duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
      duration_prototype__proto.lang = lang;
      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');
      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      utils_hooks__hooks.version = '2.11.0';
      setHookCallback(local__createLocal);
      utils_hooks__hooks.fn = momentPrototype;
      utils_hooks__hooks.min = min;
      utils_hooks__hooks.max = max;
      utils_hooks__hooks.now = now;
      utils_hooks__hooks.utc = create_utc__createUTC;
      utils_hooks__hooks.unix = moment__createUnix;
      utils_hooks__hooks.months = lists__listMonths;
      utils_hooks__hooks.isDate = isDate;
      utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
      utils_hooks__hooks.invalid = valid__createInvalid;
      utils_hooks__hooks.duration = create__createDuration;
      utils_hooks__hooks.isMoment = isMoment;
      utils_hooks__hooks.weekdays = lists__listWeekdays;
      utils_hooks__hooks.parseZone = moment__createInZone;
      utils_hooks__hooks.localeData = locale_locales__getLocale;
      utils_hooks__hooks.isDuration = isDuration;
      utils_hooks__hooks.monthsShort = lists__listMonthsShort;
      utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
      utils_hooks__hooks.defineLocale = defineLocale;
      utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
      utils_hooks__hooks.normalizeUnits = normalizeUnits;
      utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
      utils_hooks__hooks.prototype = momentPrototype;
      var _moment = utils_hooks__hooks;
      return _moment;
    }));
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("78", ["77"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('77');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("79", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    (function(global, factory) {
      if (typeof module === "object" && typeof module.exports === "object") {
        module.exports = global.document ? factory(global, true) : function(w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w);
        };
      } else {
        factory(global);
      }
    }(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
      var arr = [];
      var slice = arr.slice;
      var concat = arr.concat;
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var support = {};
      var document = window.document,
          version = "2.1.4",
          jQuery = function(selector, context) {
            return new jQuery.fn.init(selector, context);
          },
          rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
          rmsPrefix = /^-ms-/,
          rdashAlpha = /-([\da-z])/gi,
          fcamelCase = function(all, letter) {
            return letter.toUpperCase();
          };
      jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        selector: "",
        length: 0,
        toArray: function() {
          return slice.call(this);
        },
        get: function(num) {
          return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
        },
        pushStack: function(elems) {
          var ret = jQuery.merge(this.constructor(), elems);
          ret.prevObject = this;
          ret.context = this.context;
          return ret;
        },
        each: function(callback, args) {
          return jQuery.each(this, callback, args);
        },
        map: function(callback) {
          return this.pushStack(jQuery.map(this, function(elem, i) {
            return callback.call(elem, i, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        eq: function(i) {
          var len = this.length,
              j = +i + (i < 0 ? len : 0);
          return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor(null);
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery.extend = jQuery.fn.extend = function() {
        var options,
            name,
            src,
            copy,
            copyIsArray,
            clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i] || {};
          i++;
        }
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
          target = {};
        }
        if (i === length) {
          target = this;
          i--;
        }
        for (; i < length; i++) {
          if ((options = arguments[i]) != null) {
            for (name in options) {
              src = target[name];
              copy = options[name];
              if (target === copy) {
                continue;
              }
              if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && jQuery.isArray(src) ? src : [];
                } else {
                  clone = src && jQuery.isPlainObject(src) ? src : {};
                }
                target[name] = jQuery.extend(deep, clone, copy);
              } else if (copy !== undefined) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
          return jQuery.type(obj) === "function";
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
          return obj != null && obj === obj.window;
        },
        isNumeric: function(obj) {
          return !jQuery.isArray(obj) && (obj - parseFloat(obj) + 1) >= 0;
        },
        isPlainObject: function(obj) {
          if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
            return false;
          }
          if (obj.constructor && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
            return false;
          }
          return true;
        },
        isEmptyObject: function(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        },
        type: function(obj) {
          if (obj == null) {
            return obj + "";
          }
          return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
          var script,
              indirect = eval;
          code = jQuery.trim(code);
          if (code) {
            if (code.indexOf("use strict") === 1) {
              script = document.createElement("script");
              script.text = code;
              document.head.appendChild(script).parentNode.removeChild(script);
            } else {
              indirect(code);
            }
          }
        },
        camelCase: function(string) {
          return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
          return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback, args) {
          var value,
              i = 0,
              length = obj.length,
              isArray = isArraylike(obj);
          if (args) {
            if (isArray) {
              for (; i < length; i++) {
                value = callback.apply(obj[i], args);
                if (value === false) {
                  break;
                }
              }
            } else {
              for (i in obj) {
                value = callback.apply(obj[i], args);
                if (value === false) {
                  break;
                }
              }
            }
          } else {
            if (isArray) {
              for (; i < length; i++) {
                value = callback.call(obj[i], i, obj[i]);
                if (value === false) {
                  break;
                }
              }
            } else {
              for (i in obj) {
                value = callback.call(obj[i], i, obj[i]);
                if (value === false) {
                  break;
                }
              }
            }
          }
          return obj;
        },
        trim: function(text) {
          return text == null ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
          var ret = results || [];
          if (arr != null) {
            if (isArraylike(Object(arr))) {
              jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
            } else {
              push.call(ret, arr);
            }
          }
          return ret;
        },
        inArray: function(elem, arr, i) {
          return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
          var len = +second.length,
              j = 0,
              i = first.length;
          for (; j < len; j++) {
            first[i++] = second[j];
          }
          first.length = i;
          return first;
        },
        grep: function(elems, callback, invert) {
          var callbackInverse,
              matches = [],
              i = 0,
              length = elems.length,
              callbackExpect = !invert;
          for (; i < length; i++) {
            callbackInverse = !callback(elems[i], i);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i]);
            }
          }
          return matches;
        },
        map: function(elems, callback, arg) {
          var value,
              i = 0,
              length = elems.length,
              isArray = isArraylike(elems),
              ret = [];
          if (isArray) {
            for (; i < length; i++) {
              value = callback(elems[i], i, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i in elems) {
              value = callback(elems[i], i, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
          var tmp,
              args,
              proxy;
          if (typeof context === "string") {
            tmp = fn[context];
            context = fn;
            fn = tmp;
          }
          if (!jQuery.isFunction(fn)) {
            return undefined;
          }
          args = slice.call(arguments, 2);
          proxy = function() {
            return fn.apply(context || this, args.concat(slice.call(arguments)));
          };
          proxy.guid = fn.guid = fn.guid || jQuery.guid++;
          return proxy;
        },
        now: Date.now,
        support: support
      });
      jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      });
      function isArraylike(obj) {
        var length = "length" in obj && obj.length,
            type = jQuery.type(obj);
        if (type === "function" || jQuery.isWindow(obj)) {
          return false;
        }
        if (obj.nodeType === 1 && length) {
          return true;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
      }
      var Sizzle = (function(window) {
        var i,
            support,
            Expr,
            getText,
            isXML,
            tokenize,
            compile,
            select,
            outermostContext,
            sortInput,
            hasDuplicate,
            setDocument,
            document,
            docElem,
            documentIsHTML,
            rbuggyQSA,
            rbuggyMatches,
            matches,
            contains,
            expando = "sizzle" + 1 * new Date(),
            preferredDoc = window.document,
            dirruns = 0,
            done = 0,
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            sortOrder = function(a, b) {
              if (a === b) {
                hasDuplicate = true;
              }
              return 0;
            },
            MAX_NEGATIVE = 1 << 31,
            hasOwn = ({}).hasOwnProperty,
            arr = [],
            pop = arr.pop,
            push_native = arr.push,
            push = arr.push,
            slice = arr.slice,
            indexOf = function(list, elem) {
              var i = 0,
                  len = list.length;
              for (; i < len; i++) {
                if (list[i] === elem) {
                  return i;
                }
              }
              return -1;
            },
            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            whitespace = "[\\x20\\t\\r\\n\\f]",
            characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
            identifier = characterEncoding.replace("w", "w#"),
            attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
            pseudos = ":(" + characterEncoding + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
            rwhitespace = new RegExp(whitespace + "+", "g"),
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
            rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
            rpseudo = new RegExp(pseudos),
            ridentifier = new RegExp("^" + identifier + "$"),
            matchExpr = {
              "ID": new RegExp("^#(" + characterEncoding + ")"),
              "CLASS": new RegExp("^\\.(" + characterEncoding + ")"),
              "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"),
              "ATTR": new RegExp("^" + attributes),
              "PSEUDO": new RegExp("^" + pseudos),
              "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
              "bool": new RegExp("^(?:" + booleans + ")$", "i"),
              "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            },
            rinputs = /^(?:input|select|textarea|button)$/i,
            rheader = /^h\d$/i,
            rnative = /^[^{]+\{\s*\[native \w/,
            rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            rsibling = /[+~]/,
            rescape = /'|\\/g,
            runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
            funescape = function(_, escaped, escapedWhitespace) {
              var high = "0x" + escaped - 0x10000;
              return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
            },
            unloadHandler = function() {
              setDocument();
            };
        try {
          push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push = {apply: arr.length ? function(target, els) {
              push_native.apply(target, slice.call(els));
            } : function(target, els) {
              var j = target.length,
                  i = 0;
              while ((target[j++] = els[i++])) {}
              target.length = j - 1;
            }};
        }
        function Sizzle(selector, context, results, seed) {
          var match,
              elem,
              m,
              nodeType,
              i,
              groups,
              old,
              nid,
              newContext,
              newSelector;
          if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
            setDocument(context);
          }
          context = context || document;
          results = results || [];
          nodeType = context.nodeType;
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed && documentIsHTML) {
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
              if ((m = match[1])) {
                if (nodeType === 9) {
                  elem = context.getElementById(m);
                  if (elem && elem.parentNode) {
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  }
                } else {
                  if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                }
              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results;
              } else if ((m = match[3]) && support.getElementsByClassName) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            }
            if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
              nid = old = expando;
              newContext = context;
              newSelector = nodeType !== 1 && selector;
              if (nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                groups = tokenize(selector);
                if ((old = context.getAttribute("id"))) {
                  nid = old.replace(rescape, "\\$&");
                } else {
                  context.setAttribute("id", nid);
                }
                nid = "[id='" + nid + "'] ";
                i = groups.length;
                while (i--) {
                  groups[i] = nid + toSelector(groups[i]);
                }
                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                newSelector = groups.join(",");
              }
              if (newSelector) {
                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {} finally {
                  if (!old) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return (cache[key + " "] = value);
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var div = document.createElement("div");
          try {
            return !!fn(div);
          } catch (e) {
            return false;
          } finally {
            if (div.parentNode) {
              div.parentNode.removeChild(div);
            }
            div = null;
          }
        }
        function addHandle(attrs, handler) {
          var arr = attrs.split("|"),
              i = attrs.length;
          while (i--) {
            Expr.attrHandle[arr[i]] = handler;
          }
        }
        function siblingCheck(a, b) {
          var cur = b && a,
              diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
          if (diff) {
            return diff;
          }
          if (cur) {
            while ((cur = cur.nextSibling)) {
              if (cur === b) {
                return -1;
              }
            }
          }
          return a ? 1 : -1;
        }
        function createInputPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches) {
              var j,
                  matchIndexes = fn([], seed.length, argument),
                  i = matchIndexes.length;
              while (i--) {
                if (seed[(j = matchIndexes[i])]) {
                  seed[j] = !(matches[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support = Sizzle.support = {};
        isXML = Sizzle.isXML = function(elem) {
          var documentElement = elem && (elem.ownerDocument || elem).documentElement;
          return documentElement ? documentElement.nodeName !== "HTML" : false;
        };
        setDocument = Sizzle.setDocument = function(node) {
          var hasCompare,
              parent,
              doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
            return document;
          }
          document = doc;
          docElem = doc.documentElement;
          parent = doc.defaultView;
          if (parent && parent !== parent.top) {
            if (parent.addEventListener) {
              parent.addEventListener("unload", unloadHandler, false);
            } else if (parent.attachEvent) {
              parent.attachEvent("onunload", unloadHandler);
            }
          }
          documentIsHTML = !isXML(doc);
          support.attributes = assert(function(div) {
            div.className = "i";
            return !div.getAttribute("className");
          });
          support.getElementsByTagName = assert(function(div) {
            div.appendChild(doc.createComment(""));
            return !div.getElementsByTagName("*").length;
          });
          support.getElementsByClassName = rnative.test(doc.getElementsByClassName);
          support.getById = assert(function(div) {
            docElem.appendChild(div).id = expando;
            return !doc.getElementsByName || !doc.getElementsByName(expando).length;
          });
          if (support.getById) {
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var m = context.getElementById(id);
                return m && m.parentNode ? [m] : [];
              }
            };
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
          } else {
            delete Expr.find["ID"];
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node && node.value === attrId;
              };
            };
          }
          Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support.qsa) {
              return context.querySelectorAll(tag);
            }
          } : function(tag, context) {
            var elem,
                tmp = [],
                i = 0,
                results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while ((elem = results[i++])) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
            if (documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          if ((support.qsa = rnative.test(doc.querySelectorAll))) {
            assert(function(div) {
              docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\f]' msallowcapture=''>" + "<option selected=''></option></select>";
              if (div.querySelectorAll("[msallowcapture^='']").length) {
                rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
              }
              if (!div.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              }
              if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              if (!div.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              if (!div.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
            });
            assert(function(div) {
              var input = doc.createElement("input");
              input.setAttribute("type", "hidden");
              div.appendChild(input).setAttribute("name", "D");
              if (div.querySelectorAll("[name=d]").length) {
                rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
              }
              if (!div.querySelectorAll(":enabled").length) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              div.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
            });
          }
          if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
            assert(function(div) {
              support.disconnectedMatch = matches.call(div, "div");
              matches.call(div, "[s!='']:x");
              rbuggyMatches.push("!=", pseudos);
            });
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function(a, b) {
            if (b) {
              while ((b = b.parentNode)) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
            if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
              if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                return -1;
              }
              if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                return 1;
              }
              return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur,
                i = 0,
                aup = a.parentNode,
                bup = b.parentNode,
                ap = [a],
                bp = [b];
            if (!aup || !bup) {
              return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while ((cur = cur.parentNode)) {
              ap.unshift(cur);
            }
            cur = b;
            while ((cur = cur.parentNode)) {
              bp.unshift(cur);
            }
            while (ap[i] === bp[i]) {
              i++;
            }
            return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
          };
          return doc;
        };
        Sizzle.matches = function(expr, elements) {
          return Sizzle(expr, null, null, elements);
        };
        Sizzle.matchesSelector = function(elem, expr) {
          if ((elem.ownerDocument || elem) !== document) {
            setDocument(elem);
          }
          expr = expr.replace(rattributeQuotes, "='$1']");
          if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {}
          }
          return Sizzle(expr, document, null, [elem]).length > 0;
        };
        Sizzle.contains = function(context, elem) {
          if ((context.ownerDocument || context) !== document) {
            setDocument(context);
          }
          return contains(context, elem);
        };
        Sizzle.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) !== document) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()],
              val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
          return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle.uniqueSort = function(results) {
          var elem,
              duplicates = [],
              j = 0,
              i = 0;
          hasDuplicate = !support.detectDuplicates;
          sortInput = !support.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while ((elem = results[i++])) {
              if (elem === results[i]) {
                j = duplicates.push(i);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle.getText = function(elem) {
          var node,
              ret = "",
              i = 0,
              nodeType = elem.nodeType;
          if (!nodeType) {
            while ((node = elem[i++])) {
              ret += getText(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle.selectors = {
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": {
              dir: "parentNode",
              first: true
            },
            " ": {dir: "parentNode"},
            "+": {
              dir: "previousSibling",
              first: true
            },
            "~": {dir: "previousSibling"}
          },
          preFilter: {
            "ATTR": function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            "CHILD": function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  Sizzle.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +((match[7] + match[8]) || match[3] === "odd");
              } else if (match[3]) {
                Sizzle.error(match[0]);
              }
              return match;
            },
            "PSEUDO": function(match) {
              var excess,
                  unquoted = !match[6] && match[2];
              if (matchExpr["CHILD"].test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            "TAG": function(nodeNameSelector) {
              var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
            },
            "CLASS": function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
              });
            },
            "ATTR": function(name, operator, check) {
              return function(elem) {
                var result = Sizzle.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            "CHILD": function(type, what, argument, first, last) {
              var simple = type.slice(0, 3) !== "nth",
                  forward = type.slice(-4) !== "last",
                  ofType = what === "of-type";
              return first === 1 && last === 0 ? function(elem) {
                return !!elem.parentNode;
              } : function(elem, context, xml) {
                var cache,
                    outerCache,
                    node,
                    diff,
                    nodeIndex,
                    start,
                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                    parent = elem.parentNode,
                    name = ofType && elem.nodeName.toLowerCase(),
                    useCache = !xml && !ofType;
                if (parent) {
                  if (simple) {
                    while (dir) {
                      node = elem;
                      while ((node = node[dir])) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = cache[0] === dirruns && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                    diff = cache[1];
                  } else {
                    while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                        if (useCache) {
                          (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                        }
                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || (diff % first === 0 && diff / first >= 0);
                }
              };
            },
            "PSEUDO": function(pseudo, argument) {
              var args,
                  fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                  var idx,
                      matched = fn(seed, argument),
                      i = matched.length;
                  while (i--) {
                    idx = indexOf(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            "not": markFunction(function(selector) {
              var input = [],
                  results = [],
                  matcher = compile(selector.replace(rtrim, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                var elem,
                    unmatched = matcher(seed, null, xml, []),
                    i = seed.length;
                while (i--) {
                  if ((elem = unmatched[i])) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) : function(elem, context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            "has": markFunction(function(selector) {
              return function(elem) {
                return Sizzle(selector, elem).length > 0;
              };
            }),
            "contains": markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
              };
            }),
            "lang": markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                Sizzle.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            "target": function(elem) {
              var hash = window.location && window.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            "root": function(elem) {
              return elem === docElem;
            },
            "focus": function(elem) {
              return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            "enabled": function(elem) {
              return elem.disabled === false;
            },
            "disabled": function(elem) {
              return elem.disabled === true;
            },
            "checked": function(elem) {
              var nodeName = elem.nodeName.toLowerCase();
              return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
            },
            "selected": function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            "empty": function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            "parent": function(elem) {
              return !Expr.pseudos["empty"](elem);
            },
            "header": function(elem) {
              return rheader.test(elem.nodeName);
            },
            "input": function(elem) {
              return rinputs.test(elem.nodeName);
            },
            "button": function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === "button" || name === "button";
            },
            "text": function(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            "first": createPositionalPseudo(function() {
              return [0];
            }),
            "last": createPositionalPseudo(function(matchIndexes, length) {
              return [length - 1];
            }),
            "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            "even": createPositionalPseudo(function(matchIndexes, length) {
              var i = 0;
              for (; i < length; i += 2) {
                matchIndexes.push(i);
              }
              return matchIndexes;
            }),
            "odd": createPositionalPseudo(function(matchIndexes, length) {
              var i = 1;
              for (; i < length; i += 2) {
                matchIndexes.push(i);
              }
              return matchIndexes;
            }),
            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i = argument < 0 ? argument + length : argument;
              for (; --i >= 0; ) {
                matchIndexes.push(i);
              }
              return matchIndexes;
            }),
            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i = argument < 0 ? argument + length : argument;
              for (; ++i < length; ) {
                matchIndexes.push(i);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
          submit: true,
          reset: true
        }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
          var matched,
              match,
              tokens,
              type,
              soFar,
              groups,
              preFilters,
              cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push((tokens = []));
            }
            matched = false;
            if ((match = rcombinators.exec(soFar))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: match[0].replace(rtrim, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
          var i = 0,
              len = tokens.length,
              selector = "";
          for (; i < len; i++) {
            selector += tokens[i].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir = combinator.dir,
              checkNonElements = base && dir === "parentNode",
              doneName = done++;
          return combinator.first ? function(elem, context, xml) {
            while ((elem = elem[dir])) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }
          } : function(elem, context, xml) {
            var oldCache,
                outerCache,
                newCache = [dirruns, doneName];
            if (xml) {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while ((elem = elem[dir])) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                    return (newCache[2] = oldCache[2]);
                  } else {
                    outerCache[dir] = newCache;
                    if ((newCache[2] = matcher(elem, context, xml))) {
                      return true;
                    }
                  }
                }
              }
            }
          };
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i = matchers.length;
            while (i--) {
              if (!matchers[i](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i = 0,
              len = contexts.length;
          for (; i < len; i++) {
            Sizzle(selector, contexts[i], results);
          }
          return results;
        }
        function condense(unmatched, map, filter, context, xml) {
          var elem,
              newUnmatched = [],
              i = 0,
              len = unmatched.length,
              mapped = map != null;
          for (; i < len; i++) {
            if ((elem = unmatched[i])) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map.push(i);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp,
                i,
                elem,
                preMap = [],
                postMap = [],
                preexisting = results.length,
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i = temp.length;
              while (i--) {
                if ((elem = temp[i])) {
                  matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i = matcherOut.length;
                  while (i--) {
                    if ((elem = matcherOut[i])) {
                      temp.push((matcherIn[i] = elem));
                    }
                  }
                  postFinder(null, (matcherOut = []), temp, xml);
                }
                i = matcherOut.length;
                while (i--) {
                  if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext,
              matcher,
              j,
              len = tokens.length,
              leadingRelative = Expr.relative[tokens[0].type],
              implicitRelative = leadingRelative || Expr.relative[" "],
              i = leadingRelative ? 1 : 0,
              matchContext = addCombinator(function(elem) {
                return elem === checkContext;
              }, implicitRelative, true),
              matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
              }, implicitRelative, true),
              matchers = [function(elem, context, xml) {
                var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                checkContext = null;
                return ret;
              }];
          for (; i < len; i++) {
            if ((matcher = Expr.relative[tokens[i].type])) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
              if (matcher[expando]) {
                j = ++i;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0,
              byElement = elementMatchers.length > 0,
              superMatcher = function(seed, context, xml, results, outermost) {
                var elem,
                    j,
                    matcher,
                    matchedCount = 0,
                    i = "0",
                    unmatched = seed && [],
                    setMatched = [],
                    contextBackup = outermostContext,
                    elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                    len = elems.length;
                if (outermost) {
                  outermostContext = context !== document && context;
                }
                for (; i !== len && (elem = elems[i]) != null; i++) {
                  if (byElement && elem) {
                    j = 0;
                    while ((matcher = elementMatchers[j++])) {
                      if (matcher(elem, context, xml)) {
                        results.push(elem);
                        break;
                      }
                    }
                    if (outermost) {
                      dirruns = dirrunsUnique;
                    }
                  }
                  if (bySet) {
                    if ((elem = !matcher && elem)) {
                      matchedCount--;
                    }
                    if (seed) {
                      unmatched.push(elem);
                    }
                  }
                }
                matchedCount += i;
                if (bySet && i !== matchedCount) {
                  j = 0;
                  while ((matcher = setMatchers[j++])) {
                    matcher(unmatched, setMatched, context, xml);
                  }
                  if (seed) {
                    if (matchedCount > 0) {
                      while (i--) {
                        if (!(unmatched[i] || setMatched[i])) {
                          setMatched[i] = pop.call(results);
                        }
                      }
                    }
                    setMatched = condense(setMatched);
                  }
                  push.apply(results, setMatched);
                  if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                    Sizzle.uniqueSort(results);
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                  outermostContext = contextBackup;
                }
                return unmatched;
              };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, match) {
          var i,
              setMatchers = [],
              elementMatchers = [],
              cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i = match.length;
            while (i--) {
              cached = matcherFromTokens(match[i]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            cached.selector = selector;
          }
          return cached;
        };
        select = Sizzle.select = function(selector, context, results, seed) {
          var i,
              tokens,
              token,
              type,
              find,
              compiled = typeof selector === "function" && selector,
              match = !seed && tokenize((selector = compiled.selector || selector));
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
            while (i--) {
              token = tokens[i];
              if (Expr.relative[(type = token.type)]) {
                break;
              }
              if ((find = Expr.find[type])) {
                if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                  tokens.splice(i, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
          return results;
        };
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support.detectDuplicates = !!hasDuplicate;
        setDocument();
        support.sortDetached = assert(function(div1) {
          return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });
        if (!assert(function(div) {
          div.innerHTML = "<a href='#'></a>";
          return div.firstChild.getAttribute("href") === "#";
        })) {
          addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) {
              return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
            }
          });
        }
        if (!support.attributes || !assert(function(div) {
          div.innerHTML = "<input/>";
          div.firstChild.setAttribute("value", "");
          return div.firstChild.getAttribute("value") === "";
        })) {
          addHandle("value", function(elem, name, isXML) {
            if (!isXML && elem.nodeName.toLowerCase() === "input") {
              return elem.defaultValue;
            }
          });
        }
        if (!assert(function(div) {
          return div.getAttribute("disabled") == null;
        })) {
          addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) {
              return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }
          });
        }
        return Sizzle;
      })(window);
      jQuery.find = Sizzle;
      jQuery.expr = Sizzle.selectors;
      jQuery.expr[":"] = jQuery.expr.pseudos;
      jQuery.unique = Sizzle.uniqueSort;
      jQuery.text = Sizzle.getText;
      jQuery.isXMLDoc = Sizzle.isXML;
      jQuery.contains = Sizzle.contains;
      var rneedsContext = jQuery.expr.match.needsContext;
      var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);
      var risSimple = /^.[^:#\[\.,]*$/;
      function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
          return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery.grep(elements, function(elem) {
            return (elem === qualifier) !== not;
          });
        }
        if (typeof qualifier === "string") {
          if (risSimple.test(qualifier)) {
            return jQuery.filter(qualifier, elements, not);
          }
          qualifier = jQuery.filter(qualifier, elements);
        }
        return jQuery.grep(elements, function(elem) {
          return (indexOf.call(qualifier, elem) >= 0) !== not;
        });
      }
      jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
          return elem.nodeType === 1;
        }));
      };
      jQuery.fn.extend({
        find: function(selector) {
          var i,
              len = this.length,
              ret = [],
              self = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function() {
              for (i = 0; i < len; i++) {
                if (jQuery.contains(self[i], this)) {
                  return true;
                }
              }
            }));
          }
          for (i = 0; i < len; i++) {
            jQuery.find(selector, self[i], ret);
          }
          ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
          ret.selector = this.selector ? this.selector + " " + selector : selector;
          return ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
      });
      var rootjQuery,
          rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
          init = jQuery.fn.init = function(selector, context) {
            var match,
                elem;
            if (!selector) {
              return this;
            }
            if (typeof selector === "string") {
              if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
                match = [null, selector, null];
              } else {
                match = rquickExpr.exec(selector);
              }
              if (match && (match[1] || !context)) {
                if (match[1]) {
                  context = context instanceof jQuery ? context[0] : context;
                  jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                  if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                    for (match in context) {
                      if (jQuery.isFunction(this[match])) {
                        this[match](context[match]);
                      } else {
                        this.attr(match, context[match]);
                      }
                    }
                  }
                  return this;
                } else {
                  elem = document.getElementById(match[2]);
                  if (elem && elem.parentNode) {
                    this.length = 1;
                    this[0] = elem;
                  }
                  this.context = document;
                  this.selector = selector;
                  return this;
                }
              } else if (!context || context.jquery) {
                return (context || rootjQuery).find(selector);
              } else {
                return this.constructor(context).find(selector);
              }
            } else if (selector.nodeType) {
              this.context = this[0] = selector;
              this.length = 1;
              return this;
            } else if (jQuery.isFunction(selector)) {
              return typeof rootjQuery.ready !== "undefined" ? rootjQuery.ready(selector) : selector(jQuery);
            }
            if (selector.selector !== undefined) {
              this.selector = selector.selector;
              this.context = selector.context;
            }
            return jQuery.makeArray(selector, this);
          };
      init.prototype = jQuery.fn;
      rootjQuery = jQuery(document);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/,
          guaranteedUnique = {
            children: true,
            contents: true,
            next: true,
            prev: true
          };
      jQuery.extend({
        dir: function(elem, dir, until) {
          var matched = [],
              truncate = until !== undefined;
          while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
              if (truncate && jQuery(elem).is(until)) {
                break;
              }
              matched.push(elem);
            }
          }
          return matched;
        },
        sibling: function(n, elem) {
          var matched = [];
          for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
              matched.push(n);
            }
          }
          return matched;
        }
      });
      jQuery.fn.extend({
        has: function(target) {
          var targets = jQuery(target, this),
              l = targets.length;
          return this.filter(function() {
            var i = 0;
            for (; i < l; i++) {
              if (jQuery.contains(this, targets[i])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur,
              i = 0,
              l = this.length,
              matched = [],
              pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
        },
        index: function(elem) {
          if (!elem) {
            return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          }
          return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
          return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
          return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
      });
      function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
      }
      jQuery.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return jQuery.dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
          return jQuery.dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return jQuery.dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return jQuery.dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
          return jQuery.dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
          return jQuery.dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return jQuery.sibling(elem.firstChild);
        },
        contents: function(elem) {
          return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
      }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
          var matched = jQuery.map(this, fn, until);
          if (name.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name]) {
              jQuery.unique(matched);
            }
            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnotwhite = (/\S+/g);
      var optionsCache = {};
      function createOptions(options) {
        var object = optionsCache[options] = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
          object[flag] = true;
        });
        return object;
      }
      jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : jQuery.extend({}, options);
        var memory,
            fired,
            firing,
            firingStart,
            firingLength,
            firingIndex,
            list = [],
            stack = !options.once && [],
            fire = function(data) {
              memory = options.memory && data;
              fired = true;
              firingIndex = firingStart || 0;
              firingStart = 0;
              firingLength = list.length;
              firing = true;
              for (; list && firingIndex < firingLength; firingIndex++) {
                if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
                  memory = false;
                  break;
                }
              }
              firing = false;
              if (list) {
                if (stack) {
                  if (stack.length) {
                    fire(stack.shift());
                  }
                } else if (memory) {
                  list = [];
                } else {
                  self.disable();
                }
              }
            },
            self = {
              add: function() {
                if (list) {
                  var start = list.length;
                  (function add(args) {
                    jQuery.each(args, function(_, arg) {
                      var type = jQuery.type(arg);
                      if (type === "function") {
                        if (!options.unique || !self.has(arg)) {
                          list.push(arg);
                        }
                      } else if (arg && arg.length && type !== "string") {
                        add(arg);
                      }
                    });
                  })(arguments);
                  if (firing) {
                    firingLength = list.length;
                  } else if (memory) {
                    firingStart = start;
                    fire(memory);
                  }
                }
                return this;
              },
              remove: function() {
                if (list) {
                  jQuery.each(arguments, function(_, arg) {
                    var index;
                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                      list.splice(index, 1);
                      if (firing) {
                        if (index <= firingLength) {
                          firingLength--;
                        }
                        if (index <= firingIndex) {
                          firingIndex--;
                        }
                      }
                    }
                  });
                }
                return this;
              },
              has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
              },
              empty: function() {
                list = [];
                firingLength = 0;
                return this;
              },
              disable: function() {
                list = stack = memory = undefined;
                return this;
              },
              disabled: function() {
                return !list;
              },
              lock: function() {
                stack = undefined;
                if (!memory) {
                  self.disable();
                }
                return this;
              },
              locked: function() {
                return !stack;
              },
              fireWith: function(context, args) {
                if (list && (!fired || stack)) {
                  args = args || [];
                  args = [context, args.slice ? args.slice() : args];
                  if (firing) {
                    stack.push(args);
                  } else {
                    fire(args);
                  }
                }
                return this;
              },
              fire: function() {
                self.fireWith(this, arguments);
                return this;
              },
              fired: function() {
                return !!fired;
              }
            };
        return self;
      };
      jQuery.extend({
        Deferred: function(func) {
          var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
              state = "pending",
              promise = {
                state: function() {
                  return state;
                },
                always: function() {
                  deferred.done(arguments).fail(arguments);
                  return this;
                },
                then: function() {
                  var fns = arguments;
                  return jQuery.Deferred(function(newDefer) {
                    jQuery.each(tuples, function(i, tuple) {
                      var fn = jQuery.isFunction(fns[i]) && fns[i];
                      deferred[tuple[1]](function() {
                        var returned = fn && fn.apply(this, arguments);
                        if (returned && jQuery.isFunction(returned.promise)) {
                          returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                        } else {
                          newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                        }
                      });
                    });
                    fns = null;
                  }).promise();
                },
                promise: function(obj) {
                  return obj != null ? jQuery.extend(obj, promise) : promise;
                }
              },
              deferred = {};
          promise.pipe = promise.then;
          jQuery.each(tuples, function(i, tuple) {
            var list = tuple[2],
                stateString = tuple[3];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(function() {
                state = stateString;
              }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
            }
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        when: function(subordinate) {
          var i = 0,
              resolveValues = slice.call(arguments),
              length = resolveValues.length,
              remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
              deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
              updateFunc = function(i, contexts, values) {
                return function(value) {
                  contexts[i] = this;
                  values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                  if (values === progressValues) {
                    deferred.notifyWith(contexts, values);
                  } else if (!(--remaining)) {
                    deferred.resolveWith(contexts, values);
                  }
                };
              },
              progressValues,
              progressContexts,
              resolveContexts;
          if (length > 1) {
            progressValues = new Array(length);
            progressContexts = new Array(length);
            resolveContexts = new Array(length);
            for (; i < length; i++) {
              if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
              } else {
                --remaining;
              }
            }
          }
          if (!remaining) {
            deferred.resolveWith(resolveContexts, resolveValues);
          }
          return deferred.promise();
        }
      });
      var readyList;
      jQuery.fn.ready = function(fn) {
        jQuery.ready.promise().done(fn);
        return this;
      };
      jQuery.extend({
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) {
          if (hold) {
            jQuery.readyWait++;
          } else {
            jQuery.ready(true);
          }
        },
        ready: function(wait) {
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          }
          jQuery.isReady = true;
          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document, [jQuery]);
          if (jQuery.fn.triggerHandler) {
            jQuery(document).triggerHandler("ready");
            jQuery(document).off("ready");
          }
        }
      });
      function completed() {
        document.removeEventListener("DOMContentLoaded", completed, false);
        window.removeEventListener("load", completed, false);
        jQuery.ready();
      }
      jQuery.ready.promise = function(obj) {
        if (!readyList) {
          readyList = jQuery.Deferred();
          if (document.readyState === "complete") {
            setTimeout(jQuery.ready);
          } else {
            document.addEventListener("DOMContentLoaded", completed, false);
            window.addEventListener("load", completed, false);
          }
        }
        return readyList.promise(obj);
      };
      jQuery.ready.promise();
      var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null;
        if (jQuery.type(key) === "object") {
          chainable = true;
          for (i in key) {
            jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
          }
        } else if (value !== undefined) {
          chainable = true;
          if (!jQuery.isFunction(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn.call(elems, value);
              fn = null;
            } else {
              bulk = fn;
              fn = function(elem, key, value) {
                return bulk.call(jQuery(elem), value);
              };
            }
          }
          if (fn) {
            for (; i < len; i++) {
              fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
            }
          }
        }
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
      };
      jQuery.acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
      };
      function Data() {
        Object.defineProperty(this.cache = {}, 0, {get: function() {
            return {};
          }});
        this.expando = jQuery.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.accepts = jQuery.acceptData;
      Data.prototype = {
        key: function(owner) {
          if (!Data.accepts(owner)) {
            return 0;
          }
          var descriptor = {},
              unlock = owner[this.expando];
          if (!unlock) {
            unlock = Data.uid++;
            try {
              descriptor[this.expando] = {value: unlock};
              Object.defineProperties(owner, descriptor);
            } catch (e) {
              descriptor[this.expando] = unlock;
              jQuery.extend(owner, descriptor);
            }
          }
          if (!this.cache[unlock]) {
            this.cache[unlock] = {};
          }
          return unlock;
        },
        set: function(owner, data, value) {
          var prop,
              unlock = this.key(owner),
              cache = this.cache[unlock];
          if (typeof data === "string") {
            cache[data] = value;
          } else {
            if (jQuery.isEmptyObject(cache)) {
              jQuery.extend(this.cache[unlock], data);
            } else {
              for (prop in data) {
                cache[prop] = data[prop];
              }
            }
          }
          return cache;
        },
        get: function(owner, key) {
          var cache = this.cache[this.key(owner)];
          return key === undefined ? cache : cache[key];
        },
        access: function(owner, key, value) {
          var stored;
          if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
            stored = this.get(owner, key);
            return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
          }
          this.set(owner, key, value);
          return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
          var i,
              name,
              camel,
              unlock = this.key(owner),
              cache = this.cache[unlock];
          if (key === undefined) {
            this.cache[unlock] = {};
          } else {
            if (jQuery.isArray(key)) {
              name = key.concat(key.map(jQuery.camelCase));
            } else {
              camel = jQuery.camelCase(key);
              if (key in cache) {
                name = [key, camel];
              } else {
                name = camel;
                name = name in cache ? [name] : (name.match(rnotwhite) || []);
              }
            }
            i = name.length;
            while (i--) {
              delete cache[name[i]];
            }
          }
        },
        hasData: function(owner) {
          return !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});
        },
        discard: function(owner) {
          if (owner[this.expando]) {
            delete this.cache[owner[this.expando]];
          }
        }
      };
      var data_priv = new Data();
      var data_user = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
          rmultiDash = /([A-Z])/g;
      function dataAttr(elem, key, data) {
        var name;
        if (data === undefined && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
          data = elem.getAttribute(name);
          if (typeof data === "string") {
            try {
              data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
            } catch (e) {}
            data_user.set(elem, key, data);
          } else {
            data = undefined;
          }
        }
        return data;
      }
      jQuery.extend({
        hasData: function(elem) {
          return data_user.hasData(elem) || data_priv.hasData(elem);
        },
        data: function(elem, name, data) {
          return data_user.access(elem, name, data);
        },
        removeData: function(elem, name) {
          data_user.remove(elem, name);
        },
        _data: function(elem, name, data) {
          return data_priv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
          data_priv.remove(elem, name);
        }
      });
      jQuery.fn.extend({
        data: function(key, value) {
          var i,
              name,
              data,
              elem = this[0],
              attrs = elem && elem.attributes;
          if (key === undefined) {
            if (this.length) {
              data = data_user.get(elem);
              if (elem.nodeType === 1 && !data_priv.get(elem, "hasDataAttrs")) {
                i = attrs.length;
                while (i--) {
                  if (attrs[i]) {
                    name = attrs[i].name;
                    if (name.indexOf("data-") === 0) {
                      name = jQuery.camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }
                data_priv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              data_user.set(this, key);
            });
          }
          return access(this, function(value) {
            var data,
                camelKey = jQuery.camelCase(key);
            if (elem && value === undefined) {
              data = data_user.get(elem, key);
              if (data !== undefined) {
                return data;
              }
              data = data_user.get(elem, camelKey);
              if (data !== undefined) {
                return data;
              }
              data = dataAttr(elem, camelKey, undefined);
              if (data !== undefined) {
                return data;
              }
              return;
            }
            this.each(function() {
              var data = data_user.get(this, camelKey);
              data_user.set(this, camelKey, value);
              if (key.indexOf("-") !== -1 && data !== undefined) {
                data_user.set(this, key, value);
              }
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            data_user.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function(elem, type, data) {
          var queue;
          if (elem) {
            type = (type || "fx") + "queue";
            queue = data_priv.get(elem, type);
            if (data) {
              if (!queue || jQuery.isArray(data)) {
                queue = data_priv.access(elem, type, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue = jQuery.queue(elem, type),
              startLength = queue.length,
              fn = queue.shift(),
              hooks = jQuery._queueHooks(elem, type),
              next = function() {
                jQuery.dequeue(elem, type);
              };
          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }
          if (fn) {
            if (type === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return data_priv.get(elem, key) || data_priv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
              data_priv.remove(elem, [type + "queue", key]);
            })});
        }
      });
      jQuery.fn.extend({
        queue: function(type, data) {
          var setter = 2;
          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery.queue(this[0], type);
          }
          return data === undefined ? this : this.each(function() {
            var queue = jQuery.queue(this, type, data);
            jQuery._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
          var tmp,
              count = 1,
              defer = jQuery.Deferred(),
              elements = this,
              i = this.length,
              resolve = function() {
                if (!(--count)) {
                  defer.resolveWith(elements, [elements]);
                }
              };
          if (typeof type !== "string") {
            obj = type;
            type = undefined;
          }
          type = type || "fx";
          while (i--) {
            tmp = data_priv.get(elements[i], type + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var isHidden = function(elem, el) {
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
      };
      var rcheckableType = (/^(?:checkbox|radio)$/i);
      (function() {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      })();
      var strundefined = typeof undefined;
      support.focusinBubbles = "onfocusin" in window;
      var rkeyEvent = /^key/,
          rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
          rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
          rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function safeActiveElement() {
        try {
          return document.activeElement;
        } catch (err) {}
      }
      jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
          var handleObjIn,
              eventHandle,
              tmp,
              events,
              t,
              handleObj,
              special,
              handlers,
              type,
              namespaces,
              origType,
              elemData = data_priv.get(elem);
          if (!elemData) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          }
          if (!(events = elemData.events)) {
            events = elemData.events = {};
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e) {
              return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
            };
          }
          types = (types || "").match(rnotwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery.event.special[type] || {};
            handleObj = jQuery.extend({
              type: type,
              origType: origType,
              data: data,
              handler: handler,
              guid: handler.guid,
              selector: selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle, false);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery.event.global[type] = true;
          }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j,
              origCount,
              tmp,
              events,
              t,
              handleObj,
              special,
              handlers,
              type,
              namespaces,
              origType,
              elemData = data_priv.hasData(elem) && data_priv.get(elem);
          if (!elemData || !(events = elemData.events)) {
            return;
          }
          types = (types || "").match(rnotwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events) {
                jQuery.event.remove(elem, type + types[t], handler, selector, true);
              }
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j = handlers.length;
            while (j--) {
              handleObj = handlers[j];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type, elemData.handle);
              }
              delete events[type];
            }
          }
          if (jQuery.isEmptyObject(events)) {
            delete elemData.handle;
            data_priv.remove(elem, "events");
          }
        },
        trigger: function(event, data, elem, onlyHandlers) {
          var i,
              cur,
              tmp,
              bubbleType,
              ontype,
              handle,
              special,
              eventPath = [elem || document],
              type = hasOwn.call(event, "type") ? event.type : event,
              namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = tmp = elem = elem || document;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery.event.triggered)) {
            return;
          }
          if (type.indexOf(".") >= 0) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = undefined;
          if (!event.target) {
            event.target = elem;
          }
          data = data == null ? [event] : jQuery.makeArray(data, [event]);
          special = jQuery.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window);
            }
          }
          i = 0;
          while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
            event.type = i > 1 ? bubbleType : special.bindType || type;
            handle = (data_priv.get(cur, "events") || {})[event.type] && data_priv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && jQuery.acceptData(cur)) {
              event.result = handle.apply(cur, data);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
              if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery.event.triggered = type;
                elem[type]();
                jQuery.event.triggered = undefined;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        dispatch: function(event) {
          event = jQuery.event.fix(event);
          var i,
              j,
              ret,
              matched,
              handleObj,
              handlerQueue = [],
              args = slice.call(arguments),
              handlers = (data_priv.get(this, "events") || {})[event.type] || [],
              special = jQuery.event.special[event.type] || {};
          args[0] = event;
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery.event.handlers.call(this, event, handlers);
          i = 0;
          while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j = 0;
            while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
              if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== undefined) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i,
              matches,
              sel,
              handleObj,
              handlerQueue = [],
              delegateCount = handlers.delegateCount,
              cur = event.target;
          if (delegateCount && cur.nodeType && (!event.button || event.type !== "click")) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.disabled !== true || event.type !== "click") {
                matches = [];
                for (i = 0; i < delegateCount; i++) {
                  handleObj = handlers[i];
                  sel = handleObj.selector + " ";
                  if (matches[sel] === undefined) {
                    matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
                  }
                  if (matches[sel]) {
                    matches.push(handleObj);
                  }
                }
                if (matches.length) {
                  handlerQueue.push({
                    elem: cur,
                    handlers: matches
                  });
                }
              }
            }
          }
          if (delegateCount < handlers.length) {
            handlerQueue.push({
              elem: this,
              handlers: handlers.slice(delegateCount)
            });
          }
          return handlerQueue;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
          props: "char charCode key keyCode".split(" "),
          filter: function(event, original) {
            if (event.which == null) {
              event.which = original.charCode != null ? original.charCode : original.keyCode;
            }
            return event;
          }
        },
        mouseHooks: {
          props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
          filter: function(event, original) {
            var eventDoc,
                doc,
                body,
                button = original.button;
            if (event.pageX == null && original.clientX != null) {
              eventDoc = event.target.ownerDocument || document;
              doc = eventDoc.documentElement;
              body = eventDoc.body;
              event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
              event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
            }
            if (!event.which && button !== undefined) {
              event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
            }
            return event;
          }
        },
        fix: function(event) {
          if (event[jQuery.expando]) {
            return event;
          }
          var i,
              prop,
              copy,
              type = event.type,
              originalEvent = event,
              fixHook = this.fixHooks[type];
          if (!fixHook) {
            this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
          }
          copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
          event = new jQuery.Event(originalEvent);
          i = copy.length;
          while (i--) {
            prop = copy[i];
            event[prop] = originalEvent[prop];
          }
          if (!event.target) {
            event.target = document;
          }
          if (event.target.nodeType === 3) {
            event.target = event.target.parentNode;
          }
          return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: {
          load: {noBubble: true},
          focus: {
            trigger: function() {
              if (this !== safeActiveElement() && this.focus) {
                this.focus();
                return false;
              }
            },
            delegateType: "focusin"
          },
          blur: {
            trigger: function() {
              if (this === safeActiveElement() && this.blur) {
                this.blur();
                return false;
              }
            },
            delegateType: "focusout"
          },
          click: {
            trigger: function() {
              if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                this.click();
                return false;
              }
            },
            _default: function(event) {
              return jQuery.nodeName(event.target, "a");
            }
          },
          beforeunload: {postDispatch: function(event) {
              if (event.result !== undefined && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }}
        },
        simulate: function(type, elem, event, bubble) {
          var e = jQuery.extend(new jQuery.Event(), event, {
            type: type,
            isSimulated: true,
            originalEvent: {}
          });
          if (bubble) {
            jQuery.event.trigger(e, null, elem);
          } else {
            jQuery.event.dispatch.call(elem, e);
          }
          if (e.isDefaultPrevented()) {
            event.preventDefault();
          }
        }
      };
      jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle, false);
        }
      };
      jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
      };
      jQuery.Event.prototype = {
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        preventDefault: function() {
          var e = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e && e.preventDefault) {
            e.preventDefault();
          }
        },
        stopPropagation: function() {
          var e = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e && e.stopPropagation) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e && e.stopImmediatePropagation) {
            e.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj;
            if (!related || (related !== target && !jQuery.contains(target, related))) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      if (!support.focusinBubbles) {
        jQuery.each({
          focus: "focusin",
          blur: "focusout"
        }, function(orig, fix) {
          var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
          };
          jQuery.event.special[fix] = {
            setup: function() {
              var doc = this.ownerDocument || this,
                  attaches = data_priv.access(doc, fix);
              if (!attaches) {
                doc.addEventListener(orig, handler, true);
              }
              data_priv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc = this.ownerDocument || this,
                  attaches = data_priv.access(doc, fix) - 1;
              if (!attaches) {
                doc.removeEventListener(orig, handler, true);
                data_priv.remove(doc, fix);
              } else {
                data_priv.access(doc, fix, attaches);
              }
            }
          };
        });
      }
      jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
          var origFn,
              type;
          if (typeof types === "object") {
            if (typeof selector !== "string") {
              data = data || selector;
              selector = undefined;
            }
            for (type in types) {
              this.on(type, selector, data, types[type], one);
            }
            return this;
          }
          if (data == null && fn == null) {
            fn = selector;
            data = selector = undefined;
          } else if (fn == null) {
            if (typeof selector === "string") {
              fn = data;
              data = undefined;
            } else {
              fn = data;
              data = selector;
              selector = undefined;
            }
          }
          if (fn === false) {
            fn = returnFalse;
          } else if (!fn) {
            return this;
          }
          if (one === 1) {
            origFn = fn;
            fn = function(event) {
              jQuery().off(event);
              return origFn.apply(this, arguments);
            };
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
          }
          return this.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
          });
        },
        one: function(types, selector, data, fn) {
          return this.on(types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
          var handleObj,
              type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn = selector;
            selector = undefined;
          }
          if (fn === false) {
            fn = returnFalse;
          }
          return this.each(function() {
            jQuery.event.remove(this, types, fn, selector);
          });
        },
        trigger: function(type, data) {
          return this.each(function() {
            jQuery.event.trigger(type, data, this);
          });
        },
        triggerHandler: function(type, data) {
          var elem = this[0];
          if (elem) {
            return jQuery.event.trigger(type, data, elem, true);
          }
        }
      });
      var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
          rtagName = /<([\w:]+)/,
          rhtml = /<|&#?\w+;/,
          rnoInnerhtml = /<(?:script|style|link)/i,
          rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
          rscriptType = /^$|\/(?:java|ecma)script/i,
          rscriptTypeMasked = /^true\/(.*)/,
          rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
          wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
          };
      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        if (match) {
          elem.type = match[1];
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;
        for (; i < l; i++) {
          data_priv.set(elems[i], "globalEval", !refElements || data_priv.get(refElements[i], "globalEval"));
        }
      }
      function cloneCopyEvent(src, dest) {
        var i,
            l,
            type,
            pdataOld,
            pdataCur,
            udataOld,
            udataCur,
            events;
        if (dest.nodeType !== 1) {
          return;
        }
        if (data_priv.hasData(src)) {
          pdataOld = data_priv.access(src);
          pdataCur = data_priv.set(dest, pdataOld);
          events = pdataOld.events;
          if (events) {
            delete pdataCur.handle;
            pdataCur.events = {};
            for (type in events) {
              for (i = 0, l = events[type].length; i < l; i++) {
                jQuery.event.add(dest, type, events[type][i]);
              }
            }
          }
        }
        if (data_user.hasData(src)) {
          udataOld = data_user.access(src);
          udataCur = jQuery.extend({}, udataOld);
          data_user.set(dest, udataCur);
        }
      }
      function getAll(context, tag) {
        var ret = context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
      }
      function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName === "input" || nodeName === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i,
              l,
              srcElements,
              destElements,
              clone = elem.cloneNode(true),
              inPage = jQuery.contains(elem.ownerDocument, elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            destElements = getAll(clone);
            srcElements = getAll(elem);
            for (i = 0, l = srcElements.length; i < l; i++) {
              fixInput(srcElements[i], destElements[i]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone);
              for (i = 0, l = srcElements.length; i < l; i++) {
                cloneCopyEvent(srcElements[i], destElements[i]);
              }
            } else {
              cloneCopyEvent(elem, clone);
            }
          }
          destElements = getAll(clone, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone;
        },
        buildFragment: function(elems, context, scripts, selection) {
          var elem,
              tmp,
              tag,
              wrap,
              contains,
              j,
              fragment = context.createDocumentFragment(),
              nodes = [],
              i = 0,
              l = elems.length;
          for (; i < l; i++) {
            elem = elems[i];
            if (elem || elem === 0) {
              if (jQuery.type(elem) === "object") {
                jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
              } else if (!rhtml.test(elem)) {
                nodes.push(context.createTextNode(elem));
              } else {
                tmp = tmp || fragment.appendChild(context.createElement("div"));
                tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, "<$1></$2>") + wrap[2];
                j = wrap[0];
                while (j--) {
                  tmp = tmp.lastChild;
                }
                jQuery.merge(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = "";
              }
            }
          }
          fragment.textContent = "";
          i = 0;
          while ((elem = nodes[i++])) {
            if (selection && jQuery.inArray(elem, selection) !== -1) {
              continue;
            }
            contains = jQuery.contains(elem.ownerDocument, elem);
            tmp = getAll(fragment.appendChild(elem), "script");
            if (contains) {
              setGlobalEval(tmp);
            }
            if (scripts) {
              j = 0;
              while ((elem = tmp[j++])) {
                if (rscriptType.test(elem.type || "")) {
                  scripts.push(elem);
                }
              }
            }
          }
          return fragment;
        },
        cleanData: function(elems) {
          var data,
              elem,
              type,
              key,
              special = jQuery.event.special,
              i = 0;
          for (; (elem = elems[i]) !== undefined; i++) {
            if (jQuery.acceptData(elem)) {
              key = elem[data_priv.expando];
              if (key && (data = data_priv.cache[key])) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery.event.remove(elem, type);
                    } else {
                      jQuery.removeEvent(elem, type, data.handle);
                    }
                  }
                }
                if (data_priv.cache[key]) {
                  delete data_priv.cache[key];
                }
              }
            }
            delete data_user.cache[elem[data_user.expando]];
          }
        }
      });
      jQuery.fn.extend({
        text: function(value) {
          return access(this, function(value) {
            return value === undefined ? jQuery.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return this.domManip(arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return this.domManip(arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return this.domManip(arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return this.domManip(arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        remove: function(selector, keepData) {
          var elem,
              elems = selector ? jQuery.filter(selector, this) : this,
              i = 0;
          for (; (elem = elems[i]) != null; i++) {
            if (!keepData && elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem));
            }
            if (elem.parentNode) {
              if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
                setGlobalEval(getAll(elem, "script"));
              }
              elem.parentNode.removeChild(elem);
            }
          }
          return this;
        },
        empty: function() {
          var elem,
              i = 0;
          for (; (elem = this[i]) != null; i++) {
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value) {
            var elem = this[0] || {},
                i = 0,
                l = this.length;
            if (value === undefined && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
              value = value.replace(rxhtmlTag, "<$1></$2>");
              try {
                for (; i < l; i++) {
                  elem = this[i] || {};
                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value;
                  }
                }
                elem = 0;
              } catch (e) {}
            }
            if (elem) {
              this.empty().append(value);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var arg = arguments[0];
          this.domManip(arguments, function(elem) {
            arg = this.parentNode;
            jQuery.cleanData(getAll(this));
            if (arg) {
              arg.replaceChild(elem, this);
            }
          });
          return arg && (arg.length || arg.nodeType) ? this : this.remove();
        },
        detach: function(selector) {
          return this.remove(selector, true);
        },
        domManip: function(args, callback) {
          args = concat.apply([], args);
          var fragment,
              first,
              scripts,
              hasScripts,
              node,
              doc,
              i = 0,
              l = this.length,
              set = this,
              iNoClone = l - 1,
              value = args[0],
              isFunction = jQuery.isFunction(value);
          if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
            return this.each(function(index) {
              var self = set.eq(index);
              if (isFunction) {
                args[0] = value.call(this, index, self.html());
              }
              self.domManip(args, callback);
            });
          }
          if (l) {
            fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
            first = fragment.firstChild;
            if (fragment.childNodes.length === 1) {
              fragment = first;
            }
            if (first) {
              scripts = jQuery.map(getAll(fragment, "script"), disableScript);
              hasScripts = scripts.length;
              for (; i < l; i++) {
                node = fragment;
                if (i !== iNoClone) {
                  node = jQuery.clone(node, true, true);
                  if (hasScripts) {
                    jQuery.merge(scripts, getAll(node, "script"));
                  }
                }
                callback.call(this[i], node, i);
              }
              if (hasScripts) {
                doc = scripts[scripts.length - 1].ownerDocument;
                jQuery.map(scripts, restoreScript);
                for (i = 0; i < hasScripts; i++) {
                  node = scripts[i];
                  if (rscriptType.test(node.type || "") && !data_priv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                    if (node.src) {
                      if (jQuery._evalUrl) {
                        jQuery._evalUrl(node.src);
                      }
                    } else {
                      jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                    }
                  }
                }
              }
            }
          }
          return this;
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name, original) {
        jQuery.fn[name] = function(selector) {
          var elems,
              ret = [],
              insert = jQuery(selector),
              last = insert.length - 1,
              i = 0;
          for (; i <= last; i++) {
            elems = i === last ? this : this.clone(true);
            jQuery(insert[i])[original](elems);
            push.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var iframe,
          elemdisplay = {};
      function actualDisplay(name, doc) {
        var style,
            elem = jQuery(doc.createElement(name)).appendTo(doc.body),
            display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], "display");
        elem.detach();
        return display;
      }
      function defaultDisplay(nodeName) {
        var doc = document,
            display = elemdisplay[nodeName];
        if (!display) {
          display = actualDisplay(nodeName, doc);
          if (display === "none" || !display) {
            iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
            doc = iframe[0].contentDocument;
            doc.write();
            doc.close();
            display = actualDisplay(nodeName, doc);
            iframe.detach();
          }
          elemdisplay[nodeName] = display;
        }
        return display;
      }
      var rmargin = (/^margin/);
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var getStyles = function(elem) {
        if (elem.ownerDocument.defaultView.opener) {
          return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        }
        return window.getComputedStyle(elem, null);
      };
      function curCSS(elem, name, computed) {
        var width,
            minWidth,
            maxWidth,
            ret,
            style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
          ret = computed.getPropertyValue(name) || computed[name];
        }
        if (computed) {
          if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
            ret = jQuery.style(elem, name);
          }
          if (rnumnonpx.test(ret) && rmargin.test(name)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== undefined ? ret + "" : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }};
      }
      (function() {
        var pixelPositionVal,
            boxSizingReliableVal,
            docElem = document.documentElement,
            container = document.createElement("div"),
            div = document.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" + "position:absolute";
        container.appendChild(div);
        function computePixelPositionAndBoxSizingReliable() {
          div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" + "box-sizing:border-box;display:block;margin-top:1%;top:1%;" + "border:1px;padding:1px;width:4px;position:absolute";
          div.innerHTML = "";
          docElem.appendChild(container);
          var divStyle = window.getComputedStyle(div, null);
          pixelPositionVal = divStyle.top !== "1%";
          boxSizingReliableVal = divStyle.width === "4px";
          docElem.removeChild(container);
        }
        if (window.getComputedStyle) {
          jQuery.extend(support, {
            pixelPosition: function() {
              computePixelPositionAndBoxSizingReliable();
              return pixelPositionVal;
            },
            boxSizingReliable: function() {
              if (boxSizingReliableVal == null) {
                computePixelPositionAndBoxSizingReliable();
              }
              return boxSizingReliableVal;
            },
            reliableMarginRight: function() {
              var ret,
                  marginDiv = div.appendChild(document.createElement("div"));
              marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" + "box-sizing:content-box;display:block;margin:0;border:0;padding:0";
              marginDiv.style.marginRight = marginDiv.style.width = "0";
              div.style.width = "1px";
              docElem.appendChild(container);
              ret = !parseFloat(window.getComputedStyle(marginDiv, null).marginRight);
              docElem.removeChild(container);
              div.removeChild(marginDiv);
              return ret;
            }
          });
        }
      })();
      jQuery.swap = function(elem, options, callback, args) {
        var ret,
            name,
            old = {};
        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }
        ret = callback.apply(elem, args || []);
        for (name in options) {
          elem.style[name] = old[name];
        }
        return ret;
      };
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
          rnumsplit = new RegExp("^(" + pnum + ")(.*)$", "i"),
          rrelNum = new RegExp("^([+-])=(" + pnum + ")", "i"),
          cssShow = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
          },
          cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
          },
          cssPrefixes = ["Webkit", "O", "Moz", "ms"];
      function vendorPropName(style, name) {
        if (name in style) {
          return name;
        }
        var capName = name[0].toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;
        while (i--) {
          name = cssPrefixes[i] + capName;
          if (name in style) {
            return name;
          }
        }
        return origName;
      }
      function setPositiveNumber(elem, value, subtract) {
        var matches = rnumsplit.exec(value);
        return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value;
      }
      function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
            val = 0;
        for (; i < 4; i += 2) {
          if (extra === "margin") {
            val += jQuery.css(elem, extra + cssExpand[i], true, styles);
          }
          if (isBorderBox) {
            if (extra === "content") {
              val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
            }
            if (extra !== "margin") {
              val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
          } else {
            val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
            if (extra !== "padding") {
              val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
          }
        }
        return val;
      }
      function getWidthOrHeight(elem, name, extra) {
        var valueIsBorderBox = true,
            val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            styles = getStyles(elem),
            isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        if (val <= 0 || val == null) {
          val = curCSS(elem, name, styles);
          if (val < 0 || val == null) {
            val = elem.style[name];
          }
          if (rnumnonpx.test(val)) {
            return val;
          }
          valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
          val = parseFloat(val) || 0;
        }
        return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
      }
      function showHide(elements, show) {
        var display,
            elem,
            hidden,
            values = [],
            index = 0,
            length = elements.length;
        for (; index < length; index++) {
          elem = elements[index];
          if (!elem.style) {
            continue;
          }
          values[index] = data_priv.get(elem, "olddisplay");
          display = elem.style.display;
          if (show) {
            if (!values[index] && display === "none") {
              elem.style.display = "";
            }
            if (elem.style.display === "" && isHidden(elem)) {
              values[index] = data_priv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
            }
          } else {
            hidden = isHidden(elem);
            if (display !== "none" || !hidden) {
              data_priv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
            }
          }
        }
        for (index = 0; index < length; index++) {
          elem = elements[index];
          if (!elem.style) {
            continue;
          }
          if (!show || elem.style.display === "none" || elem.style.display === "") {
            elem.style.display = show ? values[index] || "" : "none";
          }
        }
        return elements;
      }
      jQuery.extend({
        cssHooks: {opacity: {get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }}},
        cssNumber: {
          "columnCount": true,
          "fillOpacity": true,
          "flexGrow": true,
          "flexShrink": true,
          "fontWeight": true,
          "lineHeight": true,
          "opacity": true,
          "order": true,
          "orphans": true,
          "widows": true,
          "zIndex": true,
          "zoom": true
        },
        cssProps: {"float": "cssFloat"},
        style: function(elem, name, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret,
              type,
              hooks,
              origName = jQuery.camelCase(name),
              style = elem.style;
          name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (value !== undefined) {
            type = typeof value;
            if (type === "string" && (ret = rrelNum.exec(value))) {
              value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
              type = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type === "number" && !jQuery.cssNumber[origName]) {
              value += "px";
            }
            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style[name] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
              style[name] = value;
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
              return ret;
            }
            return style[name];
          }
        },
        css: function(elem, name, extra, styles) {
          var val,
              num,
              hooks,
              origName = jQuery.camelCase(name);
          name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === undefined) {
            val = curCSS(elem, name, styles);
          }
          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery.each(["height", "width"], function(i, name) {
        jQuery.cssHooks[name] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, name, extra);
              }) : getWidthOrHeight(elem, name, extra);
            }
          },
          set: function(elem, value, extra) {
            var styles = extra && getStyles(elem);
            return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles) : 0);
          }
        };
      });
      jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
          return jQuery.swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
        }
      });
      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
            var i = 0,
                expanded = {},
                parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i < 4; i++) {
              expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
            }
            return expanded;
          }};
        if (!rmargin.test(prefix)) {
          jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function(name, value) {
          return access(this, function(elem, name, value) {
            var styles,
                len,
                map = {},
                i = 0;
            if (jQuery.isArray(name)) {
              styles = getStyles(elem);
              len = name.length;
              for (; i < len; i++) {
                map[name[i]] = jQuery.css(elem, name[i], false, styles);
              }
              return map;
            }
            return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
          }, name, value, arguments.length > 1);
        },
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHidden(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }
      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || "swing";
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased,
              hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {_default: {
          get: function(tween) {
            var result;
            if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
              return tween.elem[tween.prop];
            }
            result = jQuery.css(tween.elem, tween.prop, "");
            return !result || result === "auto" ? 0 : result;
          },
          set: function(tween) {
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }};
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }};
      jQuery.easing = {
        linear: function(p) {
          return p;
        },
        swing: function(p) {
          return 0.5 - Math.cos(p * Math.PI) / 2;
        }
      };
      jQuery.fx = Tween.prototype.init;
      jQuery.fx.step = {};
      var fxNow,
          timerId,
          rfxtypes = /^(?:toggle|show|hide)$/,
          rfxnum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
          rrun = /queueHooks$/,
          animationPrefilters = [defaultPrefilter],
          tweeners = {"*": [function(prop, value) {
              var tween = this.createTween(prop, value),
                  target = tween.cur(),
                  parts = rfxnum.exec(value),
                  unit = parts && parts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
                  start = (jQuery.cssNumber[prop] || unit !== "px" && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)),
                  scale = 1,
                  maxIterations = 20;
              if (start && start[3] !== unit) {
                unit = unit || start[3];
                parts = parts || [];
                start = +target || 1;
                do {
                  scale = scale || ".5";
                  start = start / scale;
                  jQuery.style(tween.elem, prop, start + unit);
                } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
              }
              if (parts) {
                start = tween.start = +start || +target || 0;
                tween.unit = unit;
                tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
              }
              return tween;
            }]};
      function createFxNow() {
        setTimeout(function() {
          fxNow = undefined;
        });
        return (fxNow = jQuery.now());
      }
      function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = {height: type};
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
          which = cssExpand[i];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween,
            collection = (tweeners[prop] || []).concat(tweeners["*"]),
            index = 0,
            length = collection.length;
        for (; index < length; index++) {
          if ((tween = collection[index].call(animation, prop, value))) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop,
            value,
            toggle,
            tween,
            hooks,
            oldfire,
            display,
            checkDisplay,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHidden(elem),
            dataShow = data_priv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          display = jQuery.css(elem, "display");
          checkDisplay = display === "none" ? data_priv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
          if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
            style.display = "inline-block";
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.exec(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          } else {
            display = undefined;
          }
        }
        if (!jQuery.isEmptyObject(orig)) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = data_priv.access(elem, "fxshow", {});
          }
          if (toggle) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            jQuery(elem).show();
          } else {
            anim.done(function() {
              jQuery(elem).hide();
            });
          }
          anim.done(function() {
            var prop;
            data_priv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
          for (prop in orig) {
            tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
            if (!(prop in dataShow)) {
              dataShow[prop] = tween.start;
              if (hidden) {
                tween.end = tween.start;
                tween.start = prop === "width" || prop === "height" ? 1 : 0;
              }
            }
          }
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
          style.display = display;
        }
      }
      function propFilter(props, specialEasing) {
        var index,
            name,
            easing,
            value,
            hooks;
        for (index in props) {
          name = jQuery.camelCase(index);
          easing = specialEasing[name];
          value = props[index];
          if (jQuery.isArray(value)) {
            easing = value[1];
            value = props[index] = value[0];
          }
          if (index !== name) {
            props[name] = value;
            delete props[index];
          }
          hooks = jQuery.cssHooks[name];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name];
            for (index in value) {
              if (!(index in props)) {
                props[index] = value[index];
                specialEasing[index] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }
      function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function() {
              delete tick.elem;
            }),
            tick = function() {
              if (stopped) {
                return false;
              }
              var currentTime = fxNow || createFxNow(),
                  remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                  temp = remaining / animation.duration || 0,
                  percent = 1 - temp,
                  index = 0,
                  length = animation.tweens.length;
              for (; index < length; index++) {
                animation.tweens[index].run(percent);
              }
              deferred.notifyWith(elem, [animation, percent, remaining]);
              if (percent < 1 && length) {
                return remaining;
              } else {
                deferred.resolveWith(elem, [animation]);
                return false;
              }
            },
            animation = deferred.promise({
              elem: elem,
              props: jQuery.extend({}, properties),
              opts: jQuery.extend(true, {specialEasing: {}}, options),
              originalProperties: properties,
              originalOptions: options,
              startTime: fxNow || createFxNow(),
              duration: options.duration,
              tweens: [],
              createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
              },
              stop: function(gotoEnd) {
                var index = 0,
                    length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                  return this;
                }
                stopped = true;
                for (; index < length; index++) {
                  animation.tweens[index].run(1);
                }
                if (gotoEnd) {
                  deferred.resolveWith(elem, [animation, gotoEnd]);
                } else {
                  deferred.rejectWith(elem, [animation, gotoEnd]);
                }
                return this;
              }
            }),
            props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
          result = animationPrefilters[index].call(animation, elem, props, animation.opts);
          if (result) {
            return result;
          }
        }
        jQuery.map(props, createTween, animation);
        if (jQuery.isFunction(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        jQuery.fx.timer(jQuery.extend(tick, {
          elem: elem,
          anim: animation,
          queue: animation.opts.queue
        }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      }
      jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
          if (jQuery.isFunction(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.split(" ");
          }
          var prop,
              index = 0,
              length = props.length;
          for (; index < length; index++) {
            prop = props[index];
            tweeners[prop] = tweeners[prop] || [];
            tweeners[prop].unshift(callback);
          }
        },
        prefilter: function(callback, prepend) {
          if (prepend) {
            animationPrefilters.unshift(callback);
          } else {
            animationPrefilters.push(callback);
          }
        }
      });
      jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (jQuery.isFunction(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
          return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty = jQuery.isEmptyObject(prop),
              optall = jQuery.speed(speed, easing, callback),
              doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                if (empty || data_priv.get(this, "finish")) {
                  anim.stop(true);
                }
              };
          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
          }
          if (clearQueue && type !== false) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true,
                index = type != null && type + "queueHooks",
                timers = jQuery.timers,
                data = data_priv.get(this);
            if (index) {
              if (data[index] && data[index].stop) {
                stopQueue(data[index]);
              }
            } else {
              for (index in data) {
                if (data[index] && data[index].stop && rrun.test(index)) {
                  stopQueue(data[index]);
                }
              }
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                timers[index].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index,
                data = data_priv.get(this),
                queue = data[type + "queue"],
                hooks = data[type + "queueHooks"],
                timers = jQuery.timers,
                length = queue ? queue.length : 0;
            data.finish = true;
            jQuery.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && timers[index].queue === type) {
                timers[index].anim.stop(true);
                timers.splice(index, 1);
              }
            }
            for (index = 0; index < length; index++) {
              if (queue[index] && queue[index].finish) {
                queue[index].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
      });
      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
      }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery.timers = [];
      jQuery.fx.tick = function() {
        var timer,
            i = 0,
            timers = jQuery.timers;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) {
          timer = timers[i];
          if (!timer() && timers[i] === timer) {
            timers.splice(i--, 1);
          }
        }
        if (!timers.length) {
          jQuery.fx.stop();
        }
        fxNow = undefined;
      };
      jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
          jQuery.fx.start();
        } else {
          jQuery.timers.pop();
        }
      };
      jQuery.fx.interval = 13;
      jQuery.fx.start = function() {
        if (!timerId) {
          timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
      };
      jQuery.fx.stop = function() {
        clearInterval(timerId);
        timerId = null;
      };
      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
      };
      jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
          var timeout = setTimeout(next, time);
          hooks.stop = function() {
            clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var nodeHook,
          boolHook,
          attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function(name, value) {
          return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
          return this.each(function() {
            jQuery.removeAttr(this, name);
          });
        }
      });
      jQuery.extend({
        attr: function(elem, name, value) {
          var hooks,
              ret,
              nType = elem.nodeType;
          if (!elem || nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === strundefined) {
            return jQuery.prop(elem, name, value);
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            name = name.toLowerCase();
            hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
          }
          if (value !== undefined) {
            if (value === null) {
              jQuery.removeAttr(elem, name);
            } else if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
              return ret;
            } else {
              elem.setAttribute(name, value + "");
              return value;
            }
          } else if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          } else {
            ret = jQuery.find.attr(elem, name);
            return ret == null ? undefined : ret;
          }
        },
        removeAttr: function(elem, value) {
          var name,
              propName,
              i = 0,
              attrNames = value && value.match(rnotwhite);
          if (attrNames && elem.nodeType === 1) {
            while ((name = attrNames[i++])) {
              propName = jQuery.propFix[name] || name;
              if (jQuery.expr.match.bool.test(name)) {
                elem[propName] = false;
              }
              elem.removeAttribute(name);
            }
          }
        },
        attrHooks: {type: {set: function(elem, value) {
              if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }}}
      });
      boolHook = {set: function(elem, value, name) {
          if (value === false) {
            jQuery.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }
          return name;
        }};
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
          var ret,
              handle;
          if (!isXML) {
            handle = attrHandle[name];
            attrHandle[name] = ret;
            ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
            attrHandle[name] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i;
      jQuery.fn.extend({
        prop: function(name, value) {
          return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
          return this.each(function() {
            delete this[jQuery.propFix[name] || name];
          });
        }
      });
      jQuery.extend({
        propFix: {
          "for": "htmlFor",
          "class": "className"
        },
        prop: function(elem, name, value) {
          var ret,
              hooks,
              notxml,
              nType = elem.nodeType;
          if (!elem || nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
          if (notxml) {
            name = jQuery.propFix[name] || name;
            hooks = jQuery.propHooks[name];
          }
          if (value !== undefined) {
            return hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : (elem[name] = value);
          } else {
            return hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
          }
        },
        propHooks: {tabIndex: {get: function(elem) {
              return elem.hasAttribute("tabindex") || rfocusable.test(elem.nodeName) || elem.href ? elem.tabIndex : -1;
            }}}
      });
      if (!support.optSelected) {
        jQuery.propHooks.selected = {get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          }};
      }
      jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        jQuery.propFix[this.toLowerCase()] = this;
      });
      var rclass = /[\t\r\n\f]/g;
      jQuery.fn.extend({
        addClass: function(value) {
          var classes,
              elem,
              cur,
              clazz,
              j,
              finalValue,
              proceed = typeof value === "string" && value,
              i = 0,
              len = this.length;
          if (jQuery.isFunction(value)) {
            return this.each(function(j) {
              jQuery(this).addClass(value.call(this, j, this.className));
            });
          }
          if (proceed) {
            classes = (value || "").match(rnotwhite) || [];
            for (; i < len; i++) {
              elem = this[i];
              cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : " ");
              if (cur) {
                j = 0;
                while ((clazz = classes[j++])) {
                  if (cur.indexOf(" " + clazz + " ") < 0) {
                    cur += clazz + " ";
                  }
                }
                finalValue = jQuery.trim(cur);
                if (elem.className !== finalValue) {
                  elem.className = finalValue;
                }
              }
            }
          }
          return this;
        },
        removeClass: function(value) {
          var classes,
              elem,
              cur,
              clazz,
              j,
              finalValue,
              proceed = arguments.length === 0 || typeof value === "string" && value,
              i = 0,
              len = this.length;
          if (jQuery.isFunction(value)) {
            return this.each(function(j) {
              jQuery(this).removeClass(value.call(this, j, this.className));
            });
          }
          if (proceed) {
            classes = (value || "").match(rnotwhite) || [];
            for (; i < len; i++) {
              elem = this[i];
              cur = elem.nodeType === 1 && (elem.className ? (" " + elem.className + " ").replace(rclass, " ") : "");
              if (cur) {
                j = 0;
                while ((clazz = classes[j++])) {
                  while (cur.indexOf(" " + clazz + " ") >= 0) {
                    cur = cur.replace(" " + clazz + " ", " ");
                  }
                }
                finalValue = value ? jQuery.trim(cur) : "";
                if (elem.className !== finalValue) {
                  elem.className = finalValue;
                }
              }
            }
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var type = typeof value;
          if (typeof stateVal === "boolean" && type === "string") {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          if (jQuery.isFunction(value)) {
            return this.each(function(i) {
              jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
            });
          }
          return this.each(function() {
            if (type === "string") {
              var className,
                  i = 0,
                  self = jQuery(this),
                  classNames = value.match(rnotwhite) || [];
              while ((className = classNames[i++])) {
                if (self.hasClass(className)) {
                  self.removeClass(className);
                } else {
                  self.addClass(className);
                }
              }
            } else if (type === strundefined || type === "boolean") {
              if (this.className) {
                data_priv.set(this, "__className__", this.className);
              }
              this.className = this.className || value === false ? "" : data_priv.get(this, "__className__") || "";
            }
          });
        },
        hasClass: function(selector) {
          var className = " " + selector + " ",
              i = 0,
              l = this.length;
          for (; i < l; i++) {
            if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({val: function(value) {
          var hooks,
              ret,
              isFunction,
              elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                return ret;
              }
              ret = elem.value;
              return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
            }
            return;
          }
          isFunction = jQuery.isFunction(value);
          return this.each(function(i) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (isFunction) {
              val = value.call(this, i, jQuery(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (jQuery.isArray(val)) {
              val = jQuery.map(val, function(value) {
                return value == null ? "" : value + "";
              });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
              this.value = val;
            }
          });
        }});
      jQuery.extend({valHooks: {
          option: {get: function(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : jQuery.trim(jQuery.text(elem));
            }},
          select: {
            get: function(elem) {
              var value,
                  option,
                  options = elem.options,
                  index = elem.selectedIndex,
                  one = elem.type === "select-one" || index < 0,
                  values = one ? null : [],
                  max = one ? index + 1 : options.length,
                  i = index < 0 ? max : one ? index : 0;
              for (; i < max; i++) {
                option = options[i];
                if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery(option).val();
                  if (one) {
                    return value;
                  }
                  values.push(value);
                }
              }
              return values;
            },
            set: function(elem, value) {
              var optionSet,
                  option,
                  options = elem.options,
                  values = jQuery.makeArray(value),
                  i = options.length;
              while (i--) {
                option = options[i];
                if ((option.selected = jQuery.inArray(option.value, values) >= 0)) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values;
            }
          }
        }});
      jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {set: function(elem, value) {
            if (jQuery.isArray(value)) {
              return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0);
            }
          }};
        if (!support.checkOn) {
          jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
      });
      jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
          return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        },
        bind: function(types, data, fn) {
          return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
          return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
          return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
      });
      var nonce = jQuery.now();
      var rquery = (/\?/);
      jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
      };
      jQuery.parseXML = function(data) {
        var xml,
            tmp;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          tmp = new DOMParser();
          xml = tmp.parseFromString(data, "text/xml");
        } catch (e) {
          xml = undefined;
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
          jQuery.error("Invalid XML: " + data);
        }
        return xml;
      };
      var rhash = /#.*$/,
          rts = /([?&])_=[^&]*/,
          rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
          rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
          rnoContent = /^(?:GET|HEAD)$/,
          rprotocol = /^\/\//,
          rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
          prefilters = {},
          transports = {},
          allTypes = "*/".concat("*"),
          ajaxLocation = window.location.href,
          ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType,
              i = 0,
              dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
          if (jQuery.isFunction(func)) {
            while ((dataType = dataTypes[i++])) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {},
            seekingTransport = (structure === transports);
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key,
            deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== undefined) {
            (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
          }
        }
        if (deep) {
          jQuery.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s, jqXHR, responses) {
        var ct,
            type,
            finalDataType,
            firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct === undefined) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2,
            current,
            conv,
            tmp,
            prev,
            converters = {},
            dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s.converters) {
            converters[conv.toLowerCase()] = s.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s.responseFields[current]) {
            jqXHR[s.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s["throws"]) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return {
          state: "success",
          data: response
        };
      }
      jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: ajaxLocation,
          type: "GET",
          isLocal: rlocalProtocol.test(ajaxLocParts[1]),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /xml/,
            html: /html/,
            json: /json/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          converters: {
            "* text": String,
            "text html": true,
            "text json": jQuery.parseJSON,
            "text xml": jQuery.parseXML
          },
          flatOptions: {
            url: true,
            context: true
          }
        },
        ajaxSetup: function(target, settings) {
          return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = undefined;
          }
          options = options || {};
          var transport,
              cacheURL,
              responseHeadersString,
              responseHeaders,
              timeoutTimer,
              parts,
              fireGlobals,
              i,
              s = jQuery.ajaxSetup({}, options),
              callbackContext = s.context || s,
              globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
              deferred = jQuery.Deferred(),
              completeDeferred = jQuery.Callbacks("once memory"),
              statusCode = s.statusCode || {},
              requestHeaders = {},
              requestHeadersNames = {},
              state = 0,
              strAbort = "canceled",
              jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                  var match;
                  if (state === 2) {
                    if (!responseHeaders) {
                      responseHeaders = {};
                      while ((match = rheaders.exec(responseHeadersString))) {
                        responseHeaders[match[1].toLowerCase()] = match[2];
                      }
                    }
                    match = responseHeaders[key.toLowerCase()];
                  }
                  return match == null ? null : match;
                },
                getAllResponseHeaders: function() {
                  return state === 2 ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                  var lname = name.toLowerCase();
                  if (!state) {
                    name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                    requestHeaders[name] = value;
                  }
                  return this;
                },
                overrideMimeType: function(type) {
                  if (!state) {
                    s.mimeType = type;
                  }
                  return this;
                },
                statusCode: function(map) {
                  var code;
                  if (map) {
                    if (state < 2) {
                      for (code in map) {
                        statusCode[code] = [statusCode[code], map[code]];
                      }
                    } else {
                      jqXHR.always(map[jqXHR.status]);
                    }
                  }
                  return this;
                },
                abort: function(statusText) {
                  var finalText = statusText || strAbort;
                  if (transport) {
                    transport.abort(finalText);
                  }
                  done(0, finalText);
                  return this;
                }
              };
          deferred.promise(jqXHR).complete = completeDeferred.add;
          jqXHR.success = jqXHR.done;
          jqXHR.error = jqXHR.fail;
          s.url = ((url || s.url || ajaxLocation) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
          s.type = options.method || options.type || s.method || s.type;
          s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
          if (s.crossDomain == null) {
            parts = rurl.exec(s.url.toLowerCase());
            s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? "80" : "443")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? "80" : "443"))));
          }
          if (s.data && s.processData && typeof s.data !== "string") {
            s.data = jQuery.param(s.data, s.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
          if (state === 2) {
            return jqXHR;
          }
          fireGlobals = jQuery.event && s.global;
          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          }
          s.type = s.type.toUpperCase();
          s.hasContent = !rnoContent.test(s.type);
          cacheURL = s.url;
          if (!s.hasContent) {
            if (s.data) {
              cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
              delete s.data;
            }
            if (s.cache === false) {
              s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
            }
          }
          if (s.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }
            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          }
          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s.contentType);
          }
          jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
          for (i in s.headers) {
            jqXHR.setRequestHeader(i, s.headers[i]);
          }
          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          for (i in {
            success: 1,
            error: 1,
            complete: 1
          }) {
            jqXHR[i](s[i]);
          }
          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s]);
            }
            if (s.async && s.timeout > 0) {
              timeoutTimer = setTimeout(function() {
                jqXHR.abort("timeout");
              }, s.timeout);
            }
            try {
              state = 1;
              transport.send(requestHeaders, done);
            } catch (e) {
              if (state < 2) {
                done(-1, e);
              } else {
                throw e;
              }
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess,
                success,
                error,
                response,
                modified,
                statusText = nativeStatusText;
            if (state === 2) {
              return;
            }
            state = 2;
            if (timeoutTimer) {
              clearTimeout(timeoutTimer);
            }
            transport = undefined;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s, jqXHR, responses);
            }
            response = ajaxConvert(s, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = undefined;
            if (fireGlobals) {
              globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
              if (!(--jQuery.active)) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery.get(url, undefined, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
          if (jQuery.isFunction(data)) {
            type = type || callback;
            callback = data;
            data = undefined;
          }
          return jQuery.ajax({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
          });
        };
      });
      jQuery._evalUrl = function(url) {
        return jQuery.ajax({
          url: url,
          type: "GET",
          dataType: "script",
          async: false,
          global: false,
          "throws": true
        });
      };
      jQuery.fn.extend({
        wrapAll: function(html) {
          var wrap;
          if (jQuery.isFunction(html)) {
            return this.each(function(i) {
              jQuery(this).wrapAll(html.call(this, i));
            });
          }
          if (this[0]) {
            wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }
            wrap.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (jQuery.isFunction(html)) {
            return this.each(function(i) {
              jQuery(this).wrapInner(html.call(this, i));
            });
          }
          return this.each(function() {
            var self = jQuery(this),
                contents = self.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self.append(html);
            }
          });
        },
        wrap: function(html) {
          var isFunction = jQuery.isFunction(html);
          return this.each(function(i) {
            jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
          });
        },
        unwrap: function() {
          return this.parent().each(function() {
            if (!jQuery.nodeName(this, "body")) {
              jQuery(this).replaceWith(this.childNodes);
            }
          }).end();
        }
      });
      jQuery.expr.filters.hidden = function(elem) {
        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
      };
      jQuery.expr.filters.visible = function(elem) {
        return !jQuery.expr.filters.hidden(elem);
      };
      var r20 = /%20/g,
          rbracket = /\[\]$/,
          rCRLF = /\r?\n/g,
          rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
          rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) {
          jQuery.each(obj, function(i, v) {
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v);
            } else {
              buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add);
            }
          });
        } else if (!traditional && jQuery.type(obj) === "object") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      jQuery.param = function(a, traditional) {
        var prefix,
            s = [],
            add = function(key, value) {
              value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
              s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
            };
        if (traditional === undefined) {
          traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
          jQuery.each(a, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix in a) {
            buildParams(prefix, a[prefix], traditional, add);
          }
        }
        return s.join("&").replace(r20, "+");
      };
      jQuery.fn.extend({
        serialize: function() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(i, elem) {
            var val = jQuery(this).val();
            return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              };
            }) : {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          }).get();
        }
      });
      jQuery.ajaxSettings.xhr = function() {
        try {
          return new XMLHttpRequest();
        } catch (e) {}
      };
      var xhrId = 0,
          xhrCallbacks = {},
          xhrSuccessStatus = {
            0: 200,
            1223: 204
          },
          xhrSupported = jQuery.ajaxSettings.xhr();
      if (window.attachEvent) {
        window.attachEvent("onunload", function() {
          for (var key in xhrCallbacks) {
            xhrCallbacks[key]();
          }
        });
      }
      support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function(options) {
        var callback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i,
                  xhr = options.xhr(),
                  id = ++xhrId;
              xhr.open(options.type, options.url, options.async, options.username, options.password);
              if (options.xhrFields) {
                for (i in options.xhrFields) {
                  xhr[i] = options.xhrFields[i];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              }
              callback = function(type) {
                return function() {
                  if (callback) {
                    delete xhrCallbacks[id];
                    callback = xhr.onload = xhr.onerror = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      complete(xhr.status, xhr.statusText);
                    } else {
                      complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, typeof xhr.responseText === "string" ? {text: xhr.responseText} : undefined, xhr.getAllResponseHeaders());
                    }
                  }
                };
              };
              xhr.onload = callback();
              xhr.onerror = callback("error");
              callback = xhrCallbacks[id] = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e) {
                if (callback) {
                  throw e;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery.ajaxSetup({
        accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
        contents: {script: /(?:java|ecma)script/},
        converters: {"text script": function(text) {
            jQuery.globalEval(text);
            return text;
          }}
      });
      jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
          s.cache = false;
        }
        if (s.crossDomain) {
          s.type = "GET";
        }
      });
      jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
          var script,
              callback;
          return {
            send: function(_, complete) {
              script = jQuery("<script>").prop({
                async: true,
                charset: s.scriptCharset,
                src: s.url
              }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [],
          rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
          this[callback] = true;
          return callback;
        }
      });
      jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName,
            overwritten,
            responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
          callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
          if (jsonProp) {
            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s.jsonp !== false) {
            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
          }
          s.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s.dataTypes[0] = "json";
          overwritten = window[callbackName];
          window[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            window[callbackName] = overwritten;
            if (s[callbackName]) {
              s.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && jQuery.isFunction(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = undefined;
          });
          return "script";
        }
      });
      jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
          return null;
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        context = context || document;
        var parsed = rsingleTag.exec(data),
            scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = jQuery.buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
      };
      var _load = jQuery.fn.load;
      jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
          return _load.apply(this, arguments);
        }
        var selector,
            type,
            response,
            self = this,
            off = url.indexOf(" ");
        if (off >= 0) {
          selector = jQuery.trim(url.slice(off));
          url = url.slice(0, off);
        }
        if (jQuery.isFunction(params)) {
          callback = params;
          params = undefined;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self.length > 0) {
          jQuery.ajax({
            url: url,
            type: type,
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
          }).complete(callback && function(jqXHR, status) {
            self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
          });
        }
        return this;
      };
      jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
        jQuery.fn[type] = function(fn) {
          return this.on(type, fn);
        };
      });
      jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
          return elem === fn.elem;
        }).length;
      };
      var docElem = window.document.documentElement;
      function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
      }
      jQuery.offset = {setOffset: function(elem, options, i) {
          var curPosition,
              curLeft,
              curCSSTop,
              curTop,
              curOffset,
              curCSSLeft,
              calculatePosition,
              position = jQuery.css(elem, "position"),
              curElem = jQuery(elem),
              props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (jQuery.isFunction(options)) {
            options = options.call(elem, i, curOffset);
          }
          if (options.top != null) {
            props.top = (options.top - curOffset.top) + curTop;
          }
          if (options.left != null) {
            props.left = (options.left - curOffset.left) + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }};
      jQuery.fn.extend({
        offset: function(options) {
          if (arguments.length) {
            return options === undefined ? this : this.each(function(i) {
              jQuery.offset.setOffset(this, options, i);
            });
          }
          var docElem,
              win,
              elem = this[0],
              box = {
                top: 0,
                left: 0
              },
              doc = elem && elem.ownerDocument;
          if (!doc) {
            return;
          }
          docElem = doc.documentElement;
          if (!jQuery.contains(docElem, elem)) {
            return box;
          }
          if (typeof elem.getBoundingClientRect !== strundefined) {
            box = elem.getBoundingClientRect();
          }
          win = getWindow(doc);
          return {
            top: box.top + win.pageYOffset - docElem.clientTop,
            left: box.left + win.pageXOffset - docElem.clientLeft
          };
        },
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent,
              offset,
              elem = this[0],
              parentOffset = {
                top: 0,
                left: 0
              };
          if (jQuery.css(elem, "position") === "fixed") {
            offset = elem.getBoundingClientRect();
          } else {
            offsetParent = this.offsetParent();
            offset = this.offset();
            if (!jQuery.nodeName(offsetParent[0], "html")) {
              parentOffset = offsetParent.offset();
            }
            parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
          }
          return {
            top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent || docElem;
            while (offsetParent && (!jQuery.nodeName(offsetParent, "html") && jQuery.css(offsetParent, "position") === "static")) {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || docElem;
          });
        }
      });
      jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
      }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
          return access(this, function(elem, method, val) {
            var win = getWindow(elem);
            if (val === undefined) {
              return win ? win[prop] : elem[method];
            }
            if (win) {
              win.scrollTo(!top ? val : window.pageXOffset, top ? val : window.pageYOffset);
            } else {
              elem[method] = val;
            }
          }, method, val, arguments.length, null);
        };
      });
      jQuery.each(["top", "left"], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
          if (computed) {
            computed = curCSS(elem, prop);
            return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
          }
        });
      });
      jQuery.each({
        Height: "height",
        Width: "width"
      }, function(name, type) {
        jQuery.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function(defaultExtra, funcName) {
          jQuery.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type, value) {
              var doc;
              if (jQuery.isWindow(elem)) {
                return elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
              }
              return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
            }, type, chainable ? margin : undefined, chainable, null);
          };
        });
      });
      jQuery.fn.size = function() {
        return this.length;
      };
      jQuery.fn.andSelf = jQuery.fn.addBack;
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery;
        });
      }
      var _jQuery = window.jQuery,
          _$ = window.$;
      jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
          window.$ = _$;
        }
        if (deep && window.jQuery === jQuery) {
          window.jQuery = _jQuery;
        }
        return jQuery;
      };
      if (typeof noGlobal === strundefined) {
        window.jQuery = window.$ = jQuery;
      }
      return jQuery;
    }));
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("7a", ["79"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('79');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("7b", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    (function(factory) {
      if (typeof define === 'function' && define.amd) {
        define(['jquery', 'moment'], factory);
      } else if (typeof exports === 'object') {
        module.exports = factory(require('jquery'), require('moment'));
      } else {
        factory(jQuery, moment);
      }
    })(function($, moment) {
      ;
      ;
      var FC = $.fullCalendar = {
        version: "2.5.0",
        internalApiVersion: 1
      };
      var fcViews = FC.views = {};
      $.fn.fullCalendar = function(options) {
        var args = Array.prototype.slice.call(arguments, 1);
        var res = this;
        this.each(function(i, _element) {
          var element = $(_element);
          var calendar = element.data('fullCalendar');
          var singleRes;
          if (typeof options === 'string') {
            if (calendar && $.isFunction(calendar[options])) {
              singleRes = calendar[options].apply(calendar, args);
              if (!i) {
                res = singleRes;
              }
              if (options === 'destroy') {
                element.removeData('fullCalendar');
              }
            }
          } else if (!calendar) {
            calendar = new Calendar(element, options);
            element.data('fullCalendar', calendar);
            calendar.render();
          }
        });
        return res;
      };
      var complexOptions = ['header', 'buttonText', 'buttonIcons', 'themeButtonIcons'];
      function mergeOptions(optionObjs) {
        return mergeProps(optionObjs, complexOptions);
      }
      function massageOverrides(input) {
        var overrides = {views: input.views || {}};
        var subObj;
        $.each(input, function(name, val) {
          if (name != 'views') {
            if ($.isPlainObject(val) && !/(time|duration|interval)$/i.test(name) && $.inArray(name, complexOptions) == -1) {
              subObj = null;
              $.each(val, function(subName, subVal) {
                if (/^(month|week|day|default|basic(Week|Day)?|agenda(Week|Day)?)$/.test(subName)) {
                  if (!overrides.views[subName]) {
                    overrides.views[subName] = {};
                  }
                  overrides.views[subName][name] = subVal;
                } else {
                  if (!subObj) {
                    subObj = {};
                  }
                  subObj[subName] = subVal;
                }
              });
              if (subObj) {
                overrides[name] = subObj;
              }
            } else {
              overrides[name] = val;
            }
          }
        });
        return overrides;
      }
      ;
      ;
      FC.intersectRanges = intersectRanges;
      FC.applyAll = applyAll;
      FC.debounce = debounce;
      FC.isInt = isInt;
      FC.htmlEscape = htmlEscape;
      FC.cssToStr = cssToStr;
      FC.proxy = proxy;
      FC.capitaliseFirstLetter = capitaliseFirstLetter;
      function compensateScroll(rowEls, scrollbarWidths) {
        if (scrollbarWidths.left) {
          rowEls.css({
            'border-left-width': 1,
            'margin-left': scrollbarWidths.left - 1
          });
        }
        if (scrollbarWidths.right) {
          rowEls.css({
            'border-right-width': 1,
            'margin-right': scrollbarWidths.right - 1
          });
        }
      }
      function uncompensateScroll(rowEls) {
        rowEls.css({
          'margin-left': '',
          'margin-right': '',
          'border-left-width': '',
          'border-right-width': ''
        });
      }
      function disableCursor() {
        $('body').addClass('fc-not-allowed');
      }
      function enableCursor() {
        $('body').removeClass('fc-not-allowed');
      }
      function distributeHeight(els, availableHeight, shouldRedistribute) {
        var minOffset1 = Math.floor(availableHeight / els.length);
        var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1));
        var flexEls = [];
        var flexOffsets = [];
        var flexHeights = [];
        var usedHeight = 0;
        undistributeHeight(els);
        els.each(function(i, el) {
          var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
          var naturalOffset = $(el).outerHeight(true);
          if (naturalOffset < minOffset) {
            flexEls.push(el);
            flexOffsets.push(naturalOffset);
            flexHeights.push($(el).height());
          } else {
            usedHeight += naturalOffset;
          }
        });
        if (shouldRedistribute) {
          availableHeight -= usedHeight;
          minOffset1 = Math.floor(availableHeight / flexEls.length);
          minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1));
        }
        $(flexEls).each(function(i, el) {
          var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
          var naturalOffset = flexOffsets[i];
          var naturalHeight = flexHeights[i];
          var newHeight = minOffset - (naturalOffset - naturalHeight);
          if (naturalOffset < minOffset) {
            $(el).height(newHeight);
          }
        });
      }
      function undistributeHeight(els) {
        els.height('');
      }
      function matchCellWidths(els) {
        var maxInnerWidth = 0;
        els.find('> *').each(function(i, innerEl) {
          var innerWidth = $(innerEl).outerWidth();
          if (innerWidth > maxInnerWidth) {
            maxInnerWidth = innerWidth;
          }
        });
        maxInnerWidth++;
        els.width(maxInnerWidth);
        return maxInnerWidth;
      }
      function setPotentialScroller(containerEl, height) {
        containerEl.height(height).addClass('fc-scroller');
        if (containerEl[0].scrollHeight - 1 > containerEl[0].clientHeight) {
          return true;
        }
        unsetScroller(containerEl);
        return false;
      }
      function unsetScroller(containerEl) {
        containerEl.height('').removeClass('fc-scroller');
      }
      FC.getOuterRect = getOuterRect;
      FC.getClientRect = getClientRect;
      FC.getContentRect = getContentRect;
      FC.getScrollbarWidths = getScrollbarWidths;
      function getScrollParent(el) {
        var position = el.css('position'),
            scrollParent = el.parents().filter(function() {
              var parent = $(this);
              return (/(auto|scroll)/).test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));
            }).eq(0);
        return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
      }
      function getOuterRect(el) {
        var offset = el.offset();
        return {
          left: offset.left,
          right: offset.left + el.outerWidth(),
          top: offset.top,
          bottom: offset.top + el.outerHeight()
        };
      }
      function getClientRect(el) {
        var offset = el.offset();
        var scrollbarWidths = getScrollbarWidths(el);
        var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left;
        var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top;
        return {
          left: left,
          right: left + el[0].clientWidth,
          top: top,
          bottom: top + el[0].clientHeight
        };
      }
      function getContentRect(el) {
        var offset = el.offset();
        var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left');
        var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top');
        return {
          left: left,
          right: left + el.width(),
          top: top,
          bottom: top + el.height()
        };
      }
      function getScrollbarWidths(el) {
        var leftRightWidth = el.innerWidth() - el[0].clientWidth;
        var widths = {
          left: 0,
          right: 0,
          top: 0,
          bottom: el.innerHeight() - el[0].clientHeight
        };
        if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') {
          widths.left = leftRightWidth;
        } else {
          widths.right = leftRightWidth;
        }
        return widths;
      }
      var _isLeftRtlScrollbars = null;
      function getIsLeftRtlScrollbars() {
        if (_isLeftRtlScrollbars === null) {
          _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
        }
        return _isLeftRtlScrollbars;
      }
      function computeIsLeftRtlScrollbars() {
        var el = $('<div><div/></div>').css({
          position: 'absolute',
          top: -1000,
          left: 0,
          border: 0,
          padding: 0,
          overflow: 'scroll',
          direction: 'rtl'
        }).appendTo('body');
        var innerEl = el.children();
        var res = innerEl.offset().left > el.offset().left;
        el.remove();
        return res;
      }
      function getCssFloat(el, prop) {
        return parseFloat(el.css(prop)) || 0;
      }
      function isPrimaryMouseButton(ev) {
        return ev.which == 1 && !ev.ctrlKey;
      }
      FC.intersectRects = intersectRects;
      function intersectRects(rect1, rect2) {
        var res = {
          left: Math.max(rect1.left, rect2.left),
          right: Math.min(rect1.right, rect2.right),
          top: Math.max(rect1.top, rect2.top),
          bottom: Math.min(rect1.bottom, rect2.bottom)
        };
        if (res.left < res.right && res.top < res.bottom) {
          return res;
        }
        return false;
      }
      function constrainPoint(point, rect) {
        return {
          left: Math.min(Math.max(point.left, rect.left), rect.right),
          top: Math.min(Math.max(point.top, rect.top), rect.bottom)
        };
      }
      function getRectCenter(rect) {
        return {
          left: (rect.left + rect.right) / 2,
          top: (rect.top + rect.bottom) / 2
        };
      }
      function diffPoints(point1, point2) {
        return {
          left: point1.left - point2.left,
          top: point1.top - point2.top
        };
      }
      FC.parseFieldSpecs = parseFieldSpecs;
      FC.compareByFieldSpecs = compareByFieldSpecs;
      FC.compareByFieldSpec = compareByFieldSpec;
      FC.flexibleCompare = flexibleCompare;
      function parseFieldSpecs(input) {
        var specs = [];
        var tokens = [];
        var i,
            token;
        if (typeof input === 'string') {
          tokens = input.split(/\s*,\s*/);
        } else if (typeof input === 'function') {
          tokens = [input];
        } else if ($.isArray(input)) {
          tokens = input;
        }
        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          if (typeof token === 'string') {
            specs.push(token.charAt(0) == '-' ? {
              field: token.substring(1),
              order: -1
            } : {
              field: token,
              order: 1
            });
          } else if (typeof token === 'function') {
            specs.push({func: token});
          }
        }
        return specs;
      }
      function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
        var i;
        var cmp;
        for (i = 0; i < fieldSpecs.length; i++) {
          cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
          if (cmp) {
            return cmp;
          }
        }
        return 0;
      }
      function compareByFieldSpec(obj1, obj2, fieldSpec) {
        if (fieldSpec.func) {
          return fieldSpec.func(obj1, obj2);
        }
        return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) * (fieldSpec.order || 1);
      }
      function flexibleCompare(a, b) {
        if (!a && !b) {
          return 0;
        }
        if (b == null) {
          return -1;
        }
        if (a == null) {
          return 1;
        }
        if ($.type(a) === 'string' || $.type(b) === 'string') {
          return String(a).localeCompare(String(b));
        }
        return a - b;
      }
      function intersectRanges(subjectRange, constraintRange) {
        var subjectStart = subjectRange.start;
        var subjectEnd = subjectRange.end;
        var constraintStart = constraintRange.start;
        var constraintEnd = constraintRange.end;
        var segStart,
            segEnd;
        var isStart,
            isEnd;
        if (subjectEnd > constraintStart && subjectStart < constraintEnd) {
          if (subjectStart >= constraintStart) {
            segStart = subjectStart.clone();
            isStart = true;
          } else {
            segStart = constraintStart.clone();
            isStart = false;
          }
          if (subjectEnd <= constraintEnd) {
            segEnd = subjectEnd.clone();
            isEnd = true;
          } else {
            segEnd = constraintEnd.clone();
            isEnd = false;
          }
          return {
            start: segStart,
            end: segEnd,
            isStart: isStart,
            isEnd: isEnd
          };
        }
      }
      FC.computeIntervalUnit = computeIntervalUnit;
      FC.divideRangeByDuration = divideRangeByDuration;
      FC.divideDurationByDuration = divideDurationByDuration;
      FC.multiplyDuration = multiplyDuration;
      FC.durationHasTime = durationHasTime;
      var dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
      var intervalUnits = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
      function diffDayTime(a, b) {
        return moment.duration({
          days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
          ms: a.time() - b.time()
        });
      }
      function diffDay(a, b) {
        return moment.duration({days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')});
      }
      function diffByUnit(a, b, unit) {
        return moment.duration(Math.round(a.diff(b, unit, true)), unit);
      }
      function computeIntervalUnit(start, end) {
        var i,
            unit;
        var val;
        for (i = 0; i < intervalUnits.length; i++) {
          unit = intervalUnits[i];
          val = computeRangeAs(unit, start, end);
          if (val >= 1 && isInt(val)) {
            break;
          }
        }
        return unit;
      }
      function computeRangeAs(unit, start, end) {
        if (end != null) {
          return end.diff(start, unit, true);
        } else if (moment.isDuration(start)) {
          return start.as(unit);
        } else {
          return start.end.diff(start.start, unit, true);
        }
      }
      function divideRangeByDuration(start, end, dur) {
        var months;
        if (durationHasTime(dur)) {
          return (end - start) / dur;
        }
        months = dur.asMonths();
        if (Math.abs(months) >= 1 && isInt(months)) {
          return end.diff(start, 'months', true) / months;
        }
        return end.diff(start, 'days', true) / dur.asDays();
      }
      function divideDurationByDuration(dur1, dur2) {
        var months1,
            months2;
        if (durationHasTime(dur1) || durationHasTime(dur2)) {
          return dur1 / dur2;
        }
        months1 = dur1.asMonths();
        months2 = dur2.asMonths();
        if (Math.abs(months1) >= 1 && isInt(months1) && Math.abs(months2) >= 1 && isInt(months2)) {
          return months1 / months2;
        }
        return dur1.asDays() / dur2.asDays();
      }
      function multiplyDuration(dur, n) {
        var months;
        if (durationHasTime(dur)) {
          return moment.duration(dur * n);
        }
        months = dur.asMonths();
        if (Math.abs(months) >= 1 && isInt(months)) {
          return moment.duration({months: months * n});
        }
        return moment.duration({days: dur.asDays() * n});
      }
      function durationHasTime(dur) {
        return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
      }
      function isNativeDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
      }
      function isTimeString(str) {
        return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
      }
      FC.log = function() {
        var console = window.console;
        if (console && console.log) {
          return console.log.apply(console, arguments);
        }
      };
      FC.warn = function() {
        var console = window.console;
        if (console && console.warn) {
          return console.warn.apply(console, arguments);
        } else {
          return FC.log.apply(FC, arguments);
        }
      };
      var hasOwnPropMethod = {}.hasOwnProperty;
      function mergeProps(propObjs, complexProps) {
        var dest = {};
        var i,
            name;
        var complexObjs;
        var j,
            val;
        var props;
        if (complexProps) {
          for (i = 0; i < complexProps.length; i++) {
            name = complexProps[i];
            complexObjs = [];
            for (j = propObjs.length - 1; j >= 0; j--) {
              val = propObjs[j][name];
              if (typeof val === 'object') {
                complexObjs.unshift(val);
              } else if (val !== undefined) {
                dest[name] = val;
                break;
              }
            }
            if (complexObjs.length) {
              dest[name] = mergeProps(complexObjs);
            }
          }
        }
        for (i = propObjs.length - 1; i >= 0; i--) {
          props = propObjs[i];
          for (name in props) {
            if (!(name in dest)) {
              dest[name] = props[name];
            }
          }
        }
        return dest;
      }
      function createObject(proto) {
        var f = function() {};
        f.prototype = proto;
        return new f();
      }
      function copyOwnProps(src, dest) {
        for (var name in src) {
          if (hasOwnProp(src, name)) {
            dest[name] = src[name];
          }
        }
      }
      function copyNativeMethods(src, dest) {
        var names = ['constructor', 'toString', 'valueOf'];
        var i,
            name;
        for (i = 0; i < names.length; i++) {
          name = names[i];
          if (src[name] !== Object.prototype[name]) {
            dest[name] = src[name];
          }
        }
      }
      function hasOwnProp(obj, name) {
        return hasOwnPropMethod.call(obj, name);
      }
      function isAtomic(val) {
        return /undefined|null|boolean|number|string/.test($.type(val));
      }
      function applyAll(functions, thisObj, args) {
        if ($.isFunction(functions)) {
          functions = [functions];
        }
        if (functions) {
          var i;
          var ret;
          for (i = 0; i < functions.length; i++) {
            ret = functions[i].apply(thisObj, args) || ret;
          }
          return ret;
        }
      }
      function firstDefined() {
        for (var i = 0; i < arguments.length; i++) {
          if (arguments[i] !== undefined) {
            return arguments[i];
          }
        }
      }
      function htmlEscape(s) {
        return (s + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&#039;').replace(/"/g, '&quot;').replace(/\n/g, '<br />');
      }
      function stripHtmlEntities(text) {
        return text.replace(/&.*?;/g, '');
      }
      function cssToStr(cssProps) {
        var statements = [];
        $.each(cssProps, function(name, val) {
          if (val != null) {
            statements.push(name + ':' + val);
          }
        });
        return statements.join(';');
      }
      function capitaliseFirstLetter(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      function compareNumbers(a, b) {
        return a - b;
      }
      function isInt(n) {
        return n % 1 === 0;
      }
      function proxy(obj, methodName) {
        var method = obj[methodName];
        return function() {
          return method.apply(obj, arguments);
        };
      }
      function debounce(func, wait) {
        var timeoutId;
        var args;
        var context;
        var timestamp;
        var later = function() {
          var last = +new Date() - timestamp;
          if (last < wait && last > 0) {
            timeoutId = setTimeout(later, wait - last);
          } else {
            timeoutId = null;
            func.apply(context, args);
            if (!timeoutId) {
              context = args = null;
            }
          }
        };
        return function() {
          context = this;
          args = arguments;
          timestamp = +new Date();
          if (!timeoutId) {
            timeoutId = setTimeout(later, wait);
          }
        };
      }
      ;
      ;
      var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
      var ambigTimeOrZoneRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
      var newMomentProto = moment.fn;
      var oldMomentProto = $.extend({}, newMomentProto);
      var allowValueOptimization;
      var setUTCValues;
      var setLocalValues;
      FC.moment = function() {
        return makeMoment(arguments);
      };
      FC.moment.utc = function() {
        var mom = makeMoment(arguments, true);
        if (mom.hasTime()) {
          mom.utc();
        }
        return mom;
      };
      FC.moment.parseZone = function() {
        return makeMoment(arguments, true, true);
      };
      function makeMoment(args, parseAsUTC, parseZone) {
        var input = args[0];
        var isSingleString = args.length == 1 && typeof input === 'string';
        var isAmbigTime;
        var isAmbigZone;
        var ambigMatch;
        var mom;
        if (moment.isMoment(input)) {
          mom = moment.apply(null, args);
          transferAmbigs(input, mom);
        } else if (isNativeDate(input) || input === undefined) {
          mom = moment.apply(null, args);
        } else {
          isAmbigTime = false;
          isAmbigZone = false;
          if (isSingleString) {
            if (ambigDateOfMonthRegex.test(input)) {
              input += '-01';
              args = [input];
              isAmbigTime = true;
              isAmbigZone = true;
            } else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
              isAmbigTime = !ambigMatch[5];
              isAmbigZone = true;
            }
          } else if ($.isArray(input)) {
            isAmbigZone = true;
          }
          if (parseAsUTC || isAmbigTime) {
            mom = moment.utc.apply(moment, args);
          } else {
            mom = moment.apply(null, args);
          }
          if (isAmbigTime) {
            mom._ambigTime = true;
            mom._ambigZone = true;
          } else if (parseZone) {
            if (isAmbigZone) {
              mom._ambigZone = true;
            } else if (isSingleString) {
              if (mom.utcOffset) {
                mom.utcOffset(input);
              } else {
                mom.zone(input);
              }
            }
          }
        }
        mom._fullCalendar = true;
        return mom;
      }
      newMomentProto.clone = function() {
        var mom = oldMomentProto.clone.apply(this, arguments);
        transferAmbigs(this, mom);
        if (this._fullCalendar) {
          mom._fullCalendar = true;
        }
        return mom;
      };
      newMomentProto.week = newMomentProto.weeks = function(input) {
        var weekCalc = (this._locale || this._lang)._fullCalendar_weekCalc;
        if (input == null && typeof weekCalc === 'function') {
          return weekCalc(this);
        } else if (weekCalc === 'ISO') {
          return oldMomentProto.isoWeek.apply(this, arguments);
        }
        return oldMomentProto.week.apply(this, arguments);
      };
      newMomentProto.time = function(time) {
        if (!this._fullCalendar) {
          return oldMomentProto.time.apply(this, arguments);
        }
        if (time == null) {
          return moment.duration({
            hours: this.hours(),
            minutes: this.minutes(),
            seconds: this.seconds(),
            milliseconds: this.milliseconds()
          });
        } else {
          this._ambigTime = false;
          if (!moment.isDuration(time) && !moment.isMoment(time)) {
            time = moment.duration(time);
          }
          var dayHours = 0;
          if (moment.isDuration(time)) {
            dayHours = Math.floor(time.asDays()) * 24;
          }
          return this.hours(dayHours + time.hours()).minutes(time.minutes()).seconds(time.seconds()).milliseconds(time.milliseconds());
        }
      };
      newMomentProto.stripTime = function() {
        var a;
        if (!this._ambigTime) {
          a = this.toArray();
          this.utc();
          setUTCValues(this, a.slice(0, 3));
          this._ambigTime = true;
          this._ambigZone = true;
        }
        return this;
      };
      newMomentProto.hasTime = function() {
        return !this._ambigTime;
      };
      newMomentProto.stripZone = function() {
        var a,
            wasAmbigTime;
        if (!this._ambigZone) {
          a = this.toArray();
          wasAmbigTime = this._ambigTime;
          this.utc();
          setUTCValues(this, a);
          this._ambigTime = wasAmbigTime || false;
          this._ambigZone = true;
        }
        return this;
      };
      newMomentProto.hasZone = function() {
        return !this._ambigZone;
      };
      newMomentProto.local = function() {
        var a = this.toArray();
        var wasAmbigZone = this._ambigZone;
        oldMomentProto.local.apply(this, arguments);
        this._ambigTime = false;
        this._ambigZone = false;
        if (wasAmbigZone) {
          setLocalValues(this, a);
        }
        return this;
      };
      newMomentProto.utc = function() {
        oldMomentProto.utc.apply(this, arguments);
        this._ambigTime = false;
        this._ambigZone = false;
        return this;
      };
      $.each(['zone', 'utcOffset'], function(i, name) {
        if (oldMomentProto[name]) {
          newMomentProto[name] = function(tzo) {
            if (tzo != null) {
              this._ambigTime = false;
              this._ambigZone = false;
            }
            return oldMomentProto[name].apply(this, arguments);
          };
        }
      });
      newMomentProto.format = function() {
        if (this._fullCalendar && arguments[0]) {
          return formatDate(this, arguments[0]);
        }
        if (this._ambigTime) {
          return oldMomentFormat(this, 'YYYY-MM-DD');
        }
        if (this._ambigZone) {
          return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
        }
        return oldMomentProto.format.apply(this, arguments);
      };
      newMomentProto.toISOString = function() {
        if (this._ambigTime) {
          return oldMomentFormat(this, 'YYYY-MM-DD');
        }
        if (this._ambigZone) {
          return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
        }
        return oldMomentProto.toISOString.apply(this, arguments);
      };
      newMomentProto.isWithin = function(start, end) {
        var a = commonlyAmbiguate([this, start, end]);
        return a[0] >= a[1] && a[0] < a[2];
      };
      newMomentProto.isSame = function(input, units) {
        var a;
        if (!this._fullCalendar) {
          return oldMomentProto.isSame.apply(this, arguments);
        }
        if (units) {
          a = commonlyAmbiguate([this, input], true);
          return oldMomentProto.isSame.call(a[0], a[1], units);
        } else {
          input = FC.moment.parseZone(input);
          return oldMomentProto.isSame.call(this, input) && Boolean(this._ambigTime) === Boolean(input._ambigTime) && Boolean(this._ambigZone) === Boolean(input._ambigZone);
        }
      };
      $.each(['isBefore', 'isAfter'], function(i, methodName) {
        newMomentProto[methodName] = function(input, units) {
          var a;
          if (!this._fullCalendar) {
            return oldMomentProto[methodName].apply(this, arguments);
          }
          a = commonlyAmbiguate([this, input]);
          return oldMomentProto[methodName].call(a[0], a[1], units);
        };
      });
      function commonlyAmbiguate(inputs, preserveTime) {
        var anyAmbigTime = false;
        var anyAmbigZone = false;
        var len = inputs.length;
        var moms = [];
        var i,
            mom;
        for (i = 0; i < len; i++) {
          mom = inputs[i];
          if (!moment.isMoment(mom)) {
            mom = FC.moment.parseZone(mom);
          }
          anyAmbigTime = anyAmbigTime || mom._ambigTime;
          anyAmbigZone = anyAmbigZone || mom._ambigZone;
          moms.push(mom);
        }
        for (i = 0; i < len; i++) {
          mom = moms[i];
          if (!preserveTime && anyAmbigTime && !mom._ambigTime) {
            moms[i] = mom.clone().stripTime();
          } else if (anyAmbigZone && !mom._ambigZone) {
            moms[i] = mom.clone().stripZone();
          }
        }
        return moms;
      }
      function transferAmbigs(src, dest) {
        if (src._ambigTime) {
          dest._ambigTime = true;
        } else if (dest._ambigTime) {
          dest._ambigTime = false;
        }
        if (src._ambigZone) {
          dest._ambigZone = true;
        } else if (dest._ambigZone) {
          dest._ambigZone = false;
        }
      }
      function setMomentValues(mom, a) {
        mom.year(a[0] || 0).month(a[1] || 0).date(a[2] || 0).hours(a[3] || 0).minutes(a[4] || 0).seconds(a[5] || 0).milliseconds(a[6] || 0);
      }
      allowValueOptimization = '_d' in moment() && 'updateOffset' in moment;
      setUTCValues = allowValueOptimization ? function(mom, a) {
        mom._d.setTime(Date.UTC.apply(Date, a));
        moment.updateOffset(mom, false);
      } : setMomentValues;
      setLocalValues = allowValueOptimization ? function(mom, a) {
        mom._d.setTime(+new Date(a[0] || 0, a[1] || 0, a[2] || 0, a[3] || 0, a[4] || 0, a[5] || 0, a[6] || 0));
        moment.updateOffset(mom, false);
      } : setMomentValues;
      ;
      ;
      function oldMomentFormat(mom, formatStr) {
        return oldMomentProto.format.call(mom, formatStr);
      }
      function formatDate(date, formatStr) {
        return formatDateWithChunks(date, getFormatStringChunks(formatStr));
      }
      function formatDateWithChunks(date, chunks) {
        var s = '';
        var i;
        for (i = 0; i < chunks.length; i++) {
          s += formatDateWithChunk(date, chunks[i]);
        }
        return s;
      }
      var tokenOverrides = {
        t: function(date) {
          return oldMomentFormat(date, 'a').charAt(0);
        },
        T: function(date) {
          return oldMomentFormat(date, 'A').charAt(0);
        }
      };
      function formatDateWithChunk(date, chunk) {
        var token;
        var maybeStr;
        if (typeof chunk === 'string') {
          return chunk;
        } else if ((token = chunk.token)) {
          if (tokenOverrides[token]) {
            return tokenOverrides[token](date);
          }
          return oldMomentFormat(date, token);
        } else if (chunk.maybe) {
          maybeStr = formatDateWithChunks(date, chunk.maybe);
          if (maybeStr.match(/[1-9]/)) {
            return maybeStr;
          }
        }
        return '';
      }
      function formatRange(date1, date2, formatStr, separator, isRTL) {
        var localeData;
        date1 = FC.moment.parseZone(date1);
        date2 = FC.moment.parseZone(date2);
        localeData = (date1.localeData || date1.lang).call(date1);
        formatStr = localeData.longDateFormat(formatStr) || formatStr;
        separator = separator || ' - ';
        return formatRangeWithChunks(date1, date2, getFormatStringChunks(formatStr), separator, isRTL);
      }
      FC.formatRange = formatRange;
      function formatRangeWithChunks(date1, date2, chunks, separator, isRTL) {
        var unzonedDate1 = date1.clone().stripZone();
        var unzonedDate2 = date2.clone().stripZone();
        var chunkStr;
        var leftI;
        var leftStr = '';
        var rightI;
        var rightStr = '';
        var middleI;
        var middleStr1 = '';
        var middleStr2 = '';
        var middleStr = '';
        for (leftI = 0; leftI < chunks.length; leftI++) {
          chunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[leftI]);
          if (chunkStr === false) {
            break;
          }
          leftStr += chunkStr;
        }
        for (rightI = chunks.length - 1; rightI > leftI; rightI--) {
          chunkStr = formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunks[rightI]);
          if (chunkStr === false) {
            break;
          }
          rightStr = chunkStr + rightStr;
        }
        for (middleI = leftI; middleI <= rightI; middleI++) {
          middleStr1 += formatDateWithChunk(date1, chunks[middleI]);
          middleStr2 += formatDateWithChunk(date2, chunks[middleI]);
        }
        if (middleStr1 || middleStr2) {
          if (isRTL) {
            middleStr = middleStr2 + separator + middleStr1;
          } else {
            middleStr = middleStr1 + separator + middleStr2;
          }
        }
        return leftStr + middleStr + rightStr;
      }
      var similarUnitMap = {
        Y: 'year',
        M: 'month',
        D: 'day',
        d: 'day',
        A: 'second',
        a: 'second',
        T: 'second',
        t: 'second',
        H: 'second',
        h: 'second',
        m: 'second',
        s: 'second'
      };
      function formatSimilarChunk(date1, date2, unzonedDate1, unzonedDate2, chunk) {
        var token;
        var unit;
        if (typeof chunk === 'string') {
          return chunk;
        } else if ((token = chunk.token)) {
          unit = similarUnitMap[token.charAt(0)];
          if (unit && unzonedDate1.isSame(unzonedDate2, unit)) {
            return oldMomentFormat(date1, token);
          }
        }
        return false;
      }
      var formatStringChunkCache = {};
      function getFormatStringChunks(formatStr) {
        if (formatStr in formatStringChunkCache) {
          return formatStringChunkCache[formatStr];
        }
        return (formatStringChunkCache[formatStr] = chunkFormatString(formatStr));
      }
      function chunkFormatString(formatStr) {
        var chunks = [];
        var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;
        var match;
        while ((match = chunker.exec(formatStr))) {
          if (match[1]) {
            chunks.push(match[1]);
          } else if (match[2]) {
            chunks.push({maybe: chunkFormatString(match[2])});
          } else if (match[3]) {
            chunks.push({token: match[3]});
          } else if (match[5]) {
            chunks.push(match[5]);
          }
        }
        return chunks;
      }
      ;
      ;
      FC.Class = Class;
      function Class() {}
      Class.extend = function() {
        var len = arguments.length;
        var i;
        var members;
        for (i = 0; i < len; i++) {
          members = arguments[i];
          if (i < len - 1) {
            mixIntoClass(this, members);
          }
        }
        return extendClass(this, members || {});
      };
      Class.mixin = function(members) {
        mixIntoClass(this, members);
      };
      function extendClass(superClass, members) {
        var subClass;
        if (hasOwnProp(members, 'constructor')) {
          subClass = members.constructor;
        }
        if (typeof subClass !== 'function') {
          subClass = members.constructor = function() {
            superClass.apply(this, arguments);
          };
        }
        subClass.prototype = createObject(superClass.prototype);
        copyOwnProps(members, subClass.prototype);
        copyNativeMethods(members, subClass.prototype);
        copyOwnProps(superClass, subClass);
        return subClass;
      }
      function mixIntoClass(theClass, members) {
        copyOwnProps(members.prototype || members, theClass.prototype);
      }
      ;
      ;
      var Emitter = FC.Emitter = Class.extend({
        callbackHash: null,
        on: function(name, callback) {
          this.getCallbacks(name).add(callback);
          return this;
        },
        off: function(name, callback) {
          this.getCallbacks(name).remove(callback);
          return this;
        },
        trigger: function(name) {
          var args = Array.prototype.slice.call(arguments, 1);
          this.triggerWith(name, this, args);
          return this;
        },
        triggerWith: function(name, context, args) {
          var callbacks = this.getCallbacks(name);
          callbacks.fireWith(context, args);
          return this;
        },
        getCallbacks: function(name) {
          var callbacks;
          if (!this.callbackHash) {
            this.callbackHash = {};
          }
          callbacks = this.callbackHash[name];
          if (!callbacks) {
            callbacks = this.callbackHash[name] = $.Callbacks();
          }
          return callbacks;
        }
      });
      ;
      ;
      var Popover = Class.extend({
        isHidden: true,
        options: null,
        el: null,
        documentMousedownProxy: null,
        margin: 10,
        constructor: function(options) {
          this.options = options || {};
        },
        show: function() {
          if (this.isHidden) {
            if (!this.el) {
              this.render();
            }
            this.el.show();
            this.position();
            this.isHidden = false;
            this.trigger('show');
          }
        },
        hide: function() {
          if (!this.isHidden) {
            this.el.hide();
            this.isHidden = true;
            this.trigger('hide');
          }
        },
        render: function() {
          var _this = this;
          var options = this.options;
          this.el = $('<div class="fc-popover"/>').addClass(options.className || '').css({
            top: 0,
            left: 0
          }).append(options.content).appendTo(options.parentEl);
          this.el.on('click', '.fc-close', function() {
            _this.hide();
          });
          if (options.autoHide) {
            $(document).on('mousedown', this.documentMousedownProxy = proxy(this, 'documentMousedown'));
          }
        },
        documentMousedown: function(ev) {
          if (this.el && !$(ev.target).closest(this.el).length) {
            this.hide();
          }
        },
        removeElement: function() {
          this.hide();
          if (this.el) {
            this.el.remove();
            this.el = null;
          }
          $(document).off('mousedown', this.documentMousedownProxy);
        },
        position: function() {
          var options = this.options;
          var origin = this.el.offsetParent().offset();
          var width = this.el.outerWidth();
          var height = this.el.outerHeight();
          var windowEl = $(window);
          var viewportEl = getScrollParent(this.el);
          var viewportTop;
          var viewportLeft;
          var viewportOffset;
          var top;
          var left;
          top = options.top || 0;
          if (options.left !== undefined) {
            left = options.left;
          } else if (options.right !== undefined) {
            left = options.right - width;
          } else {
            left = 0;
          }
          if (viewportEl.is(window) || viewportEl.is(document)) {
            viewportEl = windowEl;
            viewportTop = 0;
            viewportLeft = 0;
          } else {
            viewportOffset = viewportEl.offset();
            viewportTop = viewportOffset.top;
            viewportLeft = viewportOffset.left;
          }
          viewportTop += windowEl.scrollTop();
          viewportLeft += windowEl.scrollLeft();
          if (options.viewportConstrain !== false) {
            top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
            top = Math.max(top, viewportTop + this.margin);
            left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
            left = Math.max(left, viewportLeft + this.margin);
          }
          this.el.css({
            top: top - origin.top,
            left: left - origin.left
          });
        },
        trigger: function(name) {
          if (this.options[name]) {
            this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
          }
        }
      });
      ;
      ;
      var CoordCache = FC.CoordCache = Class.extend({
        els: null,
        forcedOffsetParentEl: null,
        origin: null,
        boundingRect: null,
        isHorizontal: false,
        isVertical: false,
        lefts: null,
        rights: null,
        tops: null,
        bottoms: null,
        constructor: function(options) {
          this.els = $(options.els);
          this.isHorizontal = options.isHorizontal;
          this.isVertical = options.isVertical;
          this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
        },
        build: function() {
          var offsetParentEl = this.forcedOffsetParentEl || this.els.eq(0).offsetParent();
          this.origin = offsetParentEl.offset();
          this.boundingRect = this.queryBoundingRect();
          if (this.isHorizontal) {
            this.buildElHorizontals();
          }
          if (this.isVertical) {
            this.buildElVerticals();
          }
        },
        clear: function() {
          this.origin = null;
          this.boundingRect = null;
          this.lefts = null;
          this.rights = null;
          this.tops = null;
          this.bottoms = null;
        },
        queryBoundingRect: function() {
          var scrollParentEl = getScrollParent(this.els.eq(0));
          if (!scrollParentEl.is(document)) {
            return getClientRect(scrollParentEl);
          }
        },
        buildElHorizontals: function() {
          var lefts = [];
          var rights = [];
          this.els.each(function(i, node) {
            var el = $(node);
            var left = el.offset().left;
            var width = el.outerWidth();
            lefts.push(left);
            rights.push(left + width);
          });
          this.lefts = lefts;
          this.rights = rights;
        },
        buildElVerticals: function() {
          var tops = [];
          var bottoms = [];
          this.els.each(function(i, node) {
            var el = $(node);
            var top = el.offset().top;
            var height = el.outerHeight();
            tops.push(top);
            bottoms.push(top + height);
          });
          this.tops = tops;
          this.bottoms = bottoms;
        },
        getHorizontalIndex: function(leftOffset) {
          var boundingRect = this.boundingRect;
          var lefts = this.lefts;
          var rights = this.rights;
          var len = lefts.length;
          var i;
          if (!boundingRect || (leftOffset >= boundingRect.left && leftOffset < boundingRect.right)) {
            for (i = 0; i < len; i++) {
              if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
                return i;
              }
            }
          }
        },
        getVerticalIndex: function(topOffset) {
          var boundingRect = this.boundingRect;
          var tops = this.tops;
          var bottoms = this.bottoms;
          var len = tops.length;
          var i;
          if (!boundingRect || (topOffset >= boundingRect.top && topOffset < boundingRect.bottom)) {
            for (i = 0; i < len; i++) {
              if (topOffset >= tops[i] && topOffset < bottoms[i]) {
                return i;
              }
            }
          }
        },
        getLeftOffset: function(leftIndex) {
          return this.lefts[leftIndex];
        },
        getLeftPosition: function(leftIndex) {
          return this.lefts[leftIndex] - this.origin.left;
        },
        getRightOffset: function(leftIndex) {
          return this.rights[leftIndex];
        },
        getRightPosition: function(leftIndex) {
          return this.rights[leftIndex] - this.origin.left;
        },
        getWidth: function(leftIndex) {
          return this.rights[leftIndex] - this.lefts[leftIndex];
        },
        getTopOffset: function(topIndex) {
          return this.tops[topIndex];
        },
        getTopPosition: function(topIndex) {
          return this.tops[topIndex] - this.origin.top;
        },
        getBottomOffset: function(topIndex) {
          return this.bottoms[topIndex];
        },
        getBottomPosition: function(topIndex) {
          return this.bottoms[topIndex] - this.origin.top;
        },
        getHeight: function(topIndex) {
          return this.bottoms[topIndex] - this.tops[topIndex];
        }
      });
      ;
      ;
      var DragListener = FC.DragListener = Class.extend({
        options: null,
        isListening: false,
        isDragging: false,
        originX: null,
        originY: null,
        mousemoveProxy: null,
        mouseupProxy: null,
        subjectEl: null,
        subjectHref: null,
        scrollEl: null,
        scrollBounds: null,
        scrollTopVel: null,
        scrollLeftVel: null,
        scrollIntervalId: null,
        scrollHandlerProxy: null,
        scrollSensitivity: 30,
        scrollSpeed: 200,
        scrollIntervalMs: 50,
        constructor: function(options) {
          options = options || {};
          this.options = options;
          this.subjectEl = options.subjectEl;
        },
        mousedown: function(ev) {
          if (isPrimaryMouseButton(ev)) {
            ev.preventDefault();
            this.startListening(ev);
            if (!this.options.distance) {
              this.startDrag(ev);
            }
          }
        },
        startListening: function(ev) {
          var scrollParent;
          if (!this.isListening) {
            if (ev && this.options.scroll) {
              scrollParent = getScrollParent($(ev.target));
              if (!scrollParent.is(window) && !scrollParent.is(document)) {
                this.scrollEl = scrollParent;
                this.scrollHandlerProxy = debounce(proxy(this, 'scrollHandler'), 100);
                this.scrollEl.on('scroll', this.scrollHandlerProxy);
              }
            }
            $(document).on('mousemove', this.mousemoveProxy = proxy(this, 'mousemove')).on('mouseup', this.mouseupProxy = proxy(this, 'mouseup')).on('selectstart', this.preventDefault);
            if (ev) {
              this.originX = ev.pageX;
              this.originY = ev.pageY;
            } else {
              this.originX = 0;
              this.originY = 0;
            }
            this.isListening = true;
            this.listenStart(ev);
          }
        },
        listenStart: function(ev) {
          this.trigger('listenStart', ev);
        },
        mousemove: function(ev) {
          var dx = ev.pageX - this.originX;
          var dy = ev.pageY - this.originY;
          var minDistance;
          var distanceSq;
          if (!this.isDragging) {
            minDistance = this.options.distance || 1;
            distanceSq = dx * dx + dy * dy;
            if (distanceSq >= minDistance * minDistance) {
              this.startDrag(ev);
            }
          }
          if (this.isDragging) {
            this.drag(dx, dy, ev);
          }
        },
        startDrag: function(ev) {
          if (!this.isListening) {
            this.startListening();
          }
          if (!this.isDragging) {
            this.isDragging = true;
            this.dragStart(ev);
          }
        },
        dragStart: function(ev) {
          var subjectEl = this.subjectEl;
          this.trigger('dragStart', ev);
          if ((this.subjectHref = subjectEl ? subjectEl.attr('href') : null)) {
            subjectEl.removeAttr('href');
          }
        },
        drag: function(dx, dy, ev) {
          this.trigger('drag', dx, dy, ev);
          this.updateScroll(ev);
        },
        mouseup: function(ev) {
          this.stopListening(ev);
        },
        stopDrag: function(ev) {
          if (this.isDragging) {
            this.stopScrolling();
            this.dragStop(ev);
            this.isDragging = false;
          }
        },
        dragStop: function(ev) {
          var _this = this;
          this.trigger('dragStop', ev);
          setTimeout(function() {
            if (_this.subjectHref) {
              _this.subjectEl.attr('href', _this.subjectHref);
            }
          }, 0);
        },
        stopListening: function(ev) {
          this.stopDrag(ev);
          if (this.isListening) {
            if (this.scrollEl) {
              this.scrollEl.off('scroll', this.scrollHandlerProxy);
              this.scrollHandlerProxy = null;
            }
            $(document).off('mousemove', this.mousemoveProxy).off('mouseup', this.mouseupProxy).off('selectstart', this.preventDefault);
            this.mousemoveProxy = null;
            this.mouseupProxy = null;
            this.isListening = false;
            this.listenStop(ev);
          }
        },
        listenStop: function(ev) {
          this.trigger('listenStop', ev);
        },
        trigger: function(name) {
          if (this.options[name]) {
            this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
          }
        },
        preventDefault: function(ev) {
          ev.preventDefault();
        },
        computeScrollBounds: function() {
          var el = this.scrollEl;
          this.scrollBounds = el ? getOuterRect(el) : null;
        },
        updateScroll: function(ev) {
          var sensitivity = this.scrollSensitivity;
          var bounds = this.scrollBounds;
          var topCloseness,
              bottomCloseness;
          var leftCloseness,
              rightCloseness;
          var topVel = 0;
          var leftVel = 0;
          if (bounds) {
            topCloseness = (sensitivity - (ev.pageY - bounds.top)) / sensitivity;
            bottomCloseness = (sensitivity - (bounds.bottom - ev.pageY)) / sensitivity;
            leftCloseness = (sensitivity - (ev.pageX - bounds.left)) / sensitivity;
            rightCloseness = (sensitivity - (bounds.right - ev.pageX)) / sensitivity;
            if (topCloseness >= 0 && topCloseness <= 1) {
              topVel = topCloseness * this.scrollSpeed * -1;
            } else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
              topVel = bottomCloseness * this.scrollSpeed;
            }
            if (leftCloseness >= 0 && leftCloseness <= 1) {
              leftVel = leftCloseness * this.scrollSpeed * -1;
            } else if (rightCloseness >= 0 && rightCloseness <= 1) {
              leftVel = rightCloseness * this.scrollSpeed;
            }
          }
          this.setScrollVel(topVel, leftVel);
        },
        setScrollVel: function(topVel, leftVel) {
          this.scrollTopVel = topVel;
          this.scrollLeftVel = leftVel;
          this.constrainScrollVel();
          if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
            this.scrollIntervalId = setInterval(proxy(this, 'scrollIntervalFunc'), this.scrollIntervalMs);
          }
        },
        constrainScrollVel: function() {
          var el = this.scrollEl;
          if (this.scrollTopVel < 0) {
            if (el.scrollTop() <= 0) {
              this.scrollTopVel = 0;
            }
          } else if (this.scrollTopVel > 0) {
            if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) {
              this.scrollTopVel = 0;
            }
          }
          if (this.scrollLeftVel < 0) {
            if (el.scrollLeft() <= 0) {
              this.scrollLeftVel = 0;
            }
          } else if (this.scrollLeftVel > 0) {
            if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) {
              this.scrollLeftVel = 0;
            }
          }
        },
        scrollIntervalFunc: function() {
          var el = this.scrollEl;
          var frac = this.scrollIntervalMs / 1000;
          if (this.scrollTopVel) {
            el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
          }
          if (this.scrollLeftVel) {
            el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
          }
          this.constrainScrollVel();
          if (!this.scrollTopVel && !this.scrollLeftVel) {
            this.stopScrolling();
          }
        },
        stopScrolling: function() {
          if (this.scrollIntervalId) {
            clearInterval(this.scrollIntervalId);
            this.scrollIntervalId = null;
            this.scrollStop();
          }
        },
        scrollHandler: function() {
          if (!this.scrollIntervalId) {
            this.scrollStop();
          }
        },
        scrollStop: function() {}
      });
      ;
      ;
      var HitDragListener = DragListener.extend({
        component: null,
        origHit: null,
        hit: null,
        coordAdjust: null,
        constructor: function(component, options) {
          DragListener.call(this, options);
          this.component = component;
        },
        listenStart: function(ev) {
          var subjectEl = this.subjectEl;
          var subjectRect;
          var origPoint;
          var point;
          DragListener.prototype.listenStart.apply(this, arguments);
          this.computeCoords();
          if (ev) {
            origPoint = {
              left: ev.pageX,
              top: ev.pageY
            };
            point = origPoint;
            if (subjectEl) {
              subjectRect = getOuterRect(subjectEl);
              point = constrainPoint(point, subjectRect);
            }
            this.origHit = this.queryHit(point.left, point.top);
            if (subjectEl && this.options.subjectCenter) {
              if (this.origHit) {
                subjectRect = intersectRects(this.origHit, subjectRect) || subjectRect;
              }
              point = getRectCenter(subjectRect);
            }
            this.coordAdjust = diffPoints(point, origPoint);
          } else {
            this.origHit = null;
            this.coordAdjust = null;
          }
        },
        computeCoords: function() {
          this.component.prepareHits();
          this.computeScrollBounds();
        },
        dragStart: function(ev) {
          var hit;
          DragListener.prototype.dragStart.apply(this, arguments);
          hit = this.queryHit(ev.pageX, ev.pageY);
          if (hit) {
            this.hitOver(hit);
          }
        },
        drag: function(dx, dy, ev) {
          var hit;
          DragListener.prototype.drag.apply(this, arguments);
          hit = this.queryHit(ev.pageX, ev.pageY);
          if (!isHitsEqual(hit, this.hit)) {
            if (this.hit) {
              this.hitOut();
            }
            if (hit) {
              this.hitOver(hit);
            }
          }
        },
        dragStop: function() {
          this.hitDone();
          DragListener.prototype.dragStop.apply(this, arguments);
        },
        hitOver: function(hit) {
          var isOrig = isHitsEqual(hit, this.origHit);
          this.hit = hit;
          this.trigger('hitOver', this.hit, isOrig, this.origHit);
        },
        hitOut: function() {
          if (this.hit) {
            this.trigger('hitOut', this.hit);
            this.hitDone();
            this.hit = null;
          }
        },
        hitDone: function() {
          if (this.hit) {
            this.trigger('hitDone', this.hit);
          }
        },
        listenStop: function() {
          DragListener.prototype.listenStop.apply(this, arguments);
          this.origHit = null;
          this.hit = null;
          this.component.releaseHits();
        },
        scrollStop: function() {
          DragListener.prototype.scrollStop.apply(this, arguments);
          this.computeCoords();
        },
        queryHit: function(left, top) {
          if (this.coordAdjust) {
            left += this.coordAdjust.left;
            top += this.coordAdjust.top;
          }
          return this.component.queryHit(left, top);
        }
      });
      function isHitsEqual(hit0, hit1) {
        if (!hit0 && !hit1) {
          return true;
        }
        if (hit0 && hit1) {
          return hit0.component === hit1.component && isHitPropsWithin(hit0, hit1) && isHitPropsWithin(hit1, hit0);
        }
        return false;
      }
      function isHitPropsWithin(subHit, superHit) {
        for (var propName in subHit) {
          if (!/^(component|left|right|top|bottom)$/.test(propName)) {
            if (subHit[propName] !== superHit[propName]) {
              return false;
            }
          }
        }
        return true;
      }
      ;
      ;
      var MouseFollower = Class.extend({
        options: null,
        sourceEl: null,
        el: null,
        parentEl: null,
        top0: null,
        left0: null,
        mouseY0: null,
        mouseX0: null,
        topDelta: null,
        leftDelta: null,
        mousemoveProxy: null,
        isFollowing: false,
        isHidden: false,
        isAnimating: false,
        constructor: function(sourceEl, options) {
          this.options = options = options || {};
          this.sourceEl = sourceEl;
          this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent();
        },
        start: function(ev) {
          if (!this.isFollowing) {
            this.isFollowing = true;
            this.mouseY0 = ev.pageY;
            this.mouseX0 = ev.pageX;
            this.topDelta = 0;
            this.leftDelta = 0;
            if (!this.isHidden) {
              this.updatePosition();
            }
            $(document).on('mousemove', this.mousemoveProxy = proxy(this, 'mousemove'));
          }
        },
        stop: function(shouldRevert, callback) {
          var _this = this;
          var revertDuration = this.options.revertDuration;
          function complete() {
            this.isAnimating = false;
            _this.removeElement();
            this.top0 = this.left0 = null;
            if (callback) {
              callback();
            }
          }
          if (this.isFollowing && !this.isAnimating) {
            this.isFollowing = false;
            $(document).off('mousemove', this.mousemoveProxy);
            if (shouldRevert && revertDuration && !this.isHidden) {
              this.isAnimating = true;
              this.el.animate({
                top: this.top0,
                left: this.left0
              }, {
                duration: revertDuration,
                complete: complete
              });
            } else {
              complete();
            }
          }
        },
        getEl: function() {
          var el = this.el;
          if (!el) {
            this.sourceEl.width();
            el = this.el = this.sourceEl.clone().css({
              position: 'absolute',
              visibility: '',
              display: this.isHidden ? 'none' : '',
              margin: 0,
              right: 'auto',
              bottom: 'auto',
              width: this.sourceEl.width(),
              height: this.sourceEl.height(),
              opacity: this.options.opacity || '',
              zIndex: this.options.zIndex
            }).appendTo(this.parentEl);
          }
          return el;
        },
        removeElement: function() {
          if (this.el) {
            this.el.remove();
            this.el = null;
          }
        },
        updatePosition: function() {
          var sourceOffset;
          var origin;
          this.getEl();
          if (this.top0 === null) {
            this.sourceEl.width();
            sourceOffset = this.sourceEl.offset();
            origin = this.el.offsetParent().offset();
            this.top0 = sourceOffset.top - origin.top;
            this.left0 = sourceOffset.left - origin.left;
          }
          this.el.css({
            top: this.top0 + this.topDelta,
            left: this.left0 + this.leftDelta
          });
        },
        mousemove: function(ev) {
          this.topDelta = ev.pageY - this.mouseY0;
          this.leftDelta = ev.pageX - this.mouseX0;
          if (!this.isHidden) {
            this.updatePosition();
          }
        },
        hide: function() {
          if (!this.isHidden) {
            this.isHidden = true;
            if (this.el) {
              this.el.hide();
            }
          }
        },
        show: function() {
          if (this.isHidden) {
            this.isHidden = false;
            this.updatePosition();
            this.getEl().show();
          }
        }
      });
      ;
      ;
      var Grid = FC.Grid = Class.extend({
        view: null,
        isRTL: null,
        start: null,
        end: null,
        el: null,
        elsByFill: null,
        externalDragStartProxy: null,
        eventTimeFormat: null,
        displayEventTime: null,
        displayEventEnd: null,
        minResizeDuration: null,
        largeUnit: null,
        constructor: function(view) {
          this.view = view;
          this.isRTL = view.opt('isRTL');
          this.elsByFill = {};
          this.externalDragStartProxy = proxy(this, 'externalDragStart');
        },
        computeEventTimeFormat: function() {
          return this.view.opt('smallTimeFormat');
        },
        computeDisplayEventTime: function() {
          return true;
        },
        computeDisplayEventEnd: function() {
          return true;
        },
        setRange: function(range) {
          this.start = range.start.clone();
          this.end = range.end.clone();
          this.rangeUpdated();
          this.processRangeOptions();
        },
        rangeUpdated: function() {},
        processRangeOptions: function() {
          var view = this.view;
          var displayEventTime;
          var displayEventEnd;
          this.eventTimeFormat = view.opt('eventTimeFormat') || view.opt('timeFormat') || this.computeEventTimeFormat();
          displayEventTime = view.opt('displayEventTime');
          if (displayEventTime == null) {
            displayEventTime = this.computeDisplayEventTime();
          }
          displayEventEnd = view.opt('displayEventEnd');
          if (displayEventEnd == null) {
            displayEventEnd = this.computeDisplayEventEnd();
          }
          this.displayEventTime = displayEventTime;
          this.displayEventEnd = displayEventEnd;
        },
        spanToSegs: function(span) {},
        diffDates: function(a, b) {
          if (this.largeUnit) {
            return diffByUnit(a, b, this.largeUnit);
          } else {
            return diffDayTime(a, b);
          }
        },
        prepareHits: function() {},
        releaseHits: function() {},
        queryHit: function(leftOffset, topOffset) {},
        getHitSpan: function(hit) {},
        getHitEl: function(hit) {},
        setElement: function(el) {
          var _this = this;
          this.el = el;
          el.on('mousedown', function(ev) {
            if (!$(ev.target).is('.fc-event-container *, .fc-more') && !$(ev.target).closest('.fc-popover').length) {
              _this.dayMousedown(ev);
            }
          });
          this.bindSegHandlers();
          this.bindGlobalHandlers();
        },
        removeElement: function() {
          this.unbindGlobalHandlers();
          this.el.remove();
        },
        renderSkeleton: function() {},
        renderDates: function() {},
        unrenderDates: function() {},
        bindGlobalHandlers: function() {
          $(document).on('dragstart sortstart', this.externalDragStartProxy);
        },
        unbindGlobalHandlers: function() {
          $(document).off('dragstart sortstart', this.externalDragStartProxy);
        },
        dayMousedown: function(ev) {
          var _this = this;
          var view = this.view;
          var isSelectable = view.opt('selectable');
          var dayClickHit;
          var selectionSpan;
          var dragListener = new HitDragListener(this, {
            scroll: view.opt('dragScroll'),
            dragStart: function() {
              view.unselect();
            },
            hitOver: function(hit, isOrig, origHit) {
              if (origHit) {
                dayClickHit = isOrig ? hit : null;
                if (isSelectable) {
                  selectionSpan = _this.computeSelection(_this.getHitSpan(origHit), _this.getHitSpan(hit));
                  if (selectionSpan) {
                    _this.renderSelection(selectionSpan);
                  } else if (selectionSpan === false) {
                    disableCursor();
                  }
                }
              }
            },
            hitOut: function() {
              dayClickHit = null;
              selectionSpan = null;
              _this.unrenderSelection();
              enableCursor();
            },
            listenStop: function(ev) {
              if (dayClickHit) {
                view.triggerDayClick(_this.getHitSpan(dayClickHit), _this.getHitEl(dayClickHit), ev);
              }
              if (selectionSpan) {
                view.reportSelection(selectionSpan, ev);
              }
              enableCursor();
            }
          });
          dragListener.mousedown(ev);
        },
        renderEventLocationHelper: function(eventLocation, sourceSeg) {
          var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);
          this.renderHelper(fakeEvent, sourceSeg);
        },
        fabricateHelperEvent: function(eventLocation, sourceSeg) {
          var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {};
          fakeEvent.start = eventLocation.start.clone();
          fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;
          fakeEvent.allDay = null;
          this.view.calendar.normalizeEventDates(fakeEvent);
          fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');
          if (!sourceSeg) {
            fakeEvent.editable = false;
          }
          return fakeEvent;
        },
        renderHelper: function(eventLocation, sourceSeg) {},
        unrenderHelper: function() {},
        renderSelection: function(span) {
          this.renderHighlight(span);
        },
        unrenderSelection: function() {
          this.unrenderHighlight();
        },
        computeSelection: function(span0, span1) {
          var span = this.computeSelectionSpan(span0, span1);
          if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {
            return false;
          }
          return span;
        },
        computeSelectionSpan: function(span0, span1) {
          var dates = [span0.start, span0.end, span1.start, span1.end];
          dates.sort(compareNumbers);
          return {
            start: dates[0].clone(),
            end: dates[3].clone()
          };
        },
        renderHighlight: function(span) {
          this.renderFill('highlight', this.spanToSegs(span));
        },
        unrenderHighlight: function() {
          this.unrenderFill('highlight');
        },
        highlightSegClasses: function() {
          return ['fc-highlight'];
        },
        renderFill: function(type, segs) {},
        unrenderFill: function(type) {
          var el = this.elsByFill[type];
          if (el) {
            el.remove();
            delete this.elsByFill[type];
          }
        },
        renderFillSegEls: function(type, segs) {
          var _this = this;
          var segElMethod = this[type + 'SegEl'];
          var html = '';
          var renderedSegs = [];
          var i;
          if (segs.length) {
            for (i = 0; i < segs.length; i++) {
              html += this.fillSegHtml(type, segs[i]);
            }
            $(html).each(function(i, node) {
              var seg = segs[i];
              var el = $(node);
              if (segElMethod) {
                el = segElMethod.call(_this, seg, el);
              }
              if (el) {
                el = $(el);
                if (el.is(_this.fillSegTag)) {
                  seg.el = el;
                  renderedSegs.push(seg);
                }
              }
            });
          }
          return renderedSegs;
        },
        fillSegTag: 'div',
        fillSegHtml: function(type, seg) {
          var classesMethod = this[type + 'SegClasses'];
          var cssMethod = this[type + 'SegCss'];
          var classes = classesMethod ? classesMethod.call(this, seg) : [];
          var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});
          return '<' + this.fillSegTag + (classes.length ? ' class="' + classes.join(' ') + '"' : '') + (css ? ' style="' + css + '"' : '') + ' />';
        },
        getDayClasses: function(date) {
          var view = this.view;
          var today = view.calendar.getNow().stripTime();
          var classes = ['fc-' + dayIDs[date.day()]];
          if (view.intervalDuration.as('months') == 1 && date.month() != view.intervalStart.month()) {
            classes.push('fc-other-month');
          }
          if (date.isSame(today, 'day')) {
            classes.push('fc-today', view.highlightStateClass);
          } else if (date < today) {
            classes.push('fc-past');
          } else {
            classes.push('fc-future');
          }
          return classes;
        }
      });
      ;
      ;
      Grid.mixin({
        mousedOverSeg: null,
        isDraggingSeg: false,
        isResizingSeg: false,
        isDraggingExternal: false,
        segs: null,
        renderEvents: function(events) {
          var bgEvents = [];
          var fgEvents = [];
          var i;
          for (i = 0; i < events.length; i++) {
            (isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);
          }
          this.segs = [].concat(this.renderBgEvents(bgEvents), this.renderFgEvents(fgEvents));
        },
        renderBgEvents: function(events) {
          var segs = this.eventsToSegs(events);
          return this.renderBgSegs(segs) || segs;
        },
        renderFgEvents: function(events) {
          var segs = this.eventsToSegs(events);
          return this.renderFgSegs(segs) || segs;
        },
        unrenderEvents: function() {
          this.triggerSegMouseout();
          this.unrenderFgSegs();
          this.unrenderBgSegs();
          this.segs = null;
        },
        getEventSegs: function() {
          return this.segs || [];
        },
        renderFgSegs: function(segs) {},
        unrenderFgSegs: function() {},
        renderFgSegEls: function(segs, disableResizing) {
          var view = this.view;
          var html = '';
          var renderedSegs = [];
          var i;
          if (segs.length) {
            for (i = 0; i < segs.length; i++) {
              html += this.fgSegHtml(segs[i], disableResizing);
            }
            $(html).each(function(i, node) {
              var seg = segs[i];
              var el = view.resolveEventEl(seg.event, $(node));
              if (el) {
                el.data('fc-seg', seg);
                seg.el = el;
                renderedSegs.push(seg);
              }
            });
          }
          return renderedSegs;
        },
        fgSegHtml: function(seg, disableResizing) {},
        renderBgSegs: function(segs) {
          return this.renderFill('bgEvent', segs);
        },
        unrenderBgSegs: function() {
          this.unrenderFill('bgEvent');
        },
        bgEventSegEl: function(seg, el) {
          return this.view.resolveEventEl(seg.event, el);
        },
        bgEventSegClasses: function(seg) {
          var event = seg.event;
          var source = event.source || {};
          return ['fc-bgevent'].concat(event.className, source.className || []);
        },
        bgEventSegCss: function(seg) {
          var view = this.view;
          var event = seg.event;
          var source = event.source || {};
          return {'background-color': event.backgroundColor || event.color || source.backgroundColor || source.color || view.opt('eventBackgroundColor') || view.opt('eventColor')};
        },
        businessHoursSegClasses: function(seg) {
          return ['fc-nonbusiness', 'fc-bgevent'];
        },
        bindSegHandlers: function() {
          var _this = this;
          var view = this.view;
          $.each({
            mouseenter: function(seg, ev) {
              _this.triggerSegMouseover(seg, ev);
            },
            mouseleave: function(seg, ev) {
              _this.triggerSegMouseout(seg, ev);
            },
            click: function(seg, ev) {
              return view.trigger('eventClick', this, seg.event, ev);
            },
            mousedown: function(seg, ev) {
              if ($(ev.target).is('.fc-resizer') && view.isEventResizable(seg.event)) {
                _this.segResizeMousedown(seg, ev, $(ev.target).is('.fc-start-resizer'));
              } else if (view.isEventDraggable(seg.event)) {
                _this.segDragMousedown(seg, ev);
              }
            }
          }, function(name, func) {
            _this.el.on(name, '.fc-event-container > *', function(ev) {
              var seg = $(this).data('fc-seg');
              if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
                return func.call(this, seg, ev);
              }
            });
          });
        },
        triggerSegMouseover: function(seg, ev) {
          if (!this.mousedOverSeg) {
            this.mousedOverSeg = seg;
            this.view.trigger('eventMouseover', seg.el[0], seg.event, ev);
          }
        },
        triggerSegMouseout: function(seg, ev) {
          ev = ev || {};
          if (this.mousedOverSeg) {
            seg = seg || this.mousedOverSeg;
            this.mousedOverSeg = null;
            this.view.trigger('eventMouseout', seg.el[0], seg.event, ev);
          }
        },
        segDragMousedown: function(seg, ev) {
          var _this = this;
          var view = this.view;
          var calendar = view.calendar;
          var el = seg.el;
          var event = seg.event;
          var dropLocation;
          var mouseFollower = new MouseFollower(seg.el, {
            parentEl: view.el,
            opacity: view.opt('dragOpacity'),
            revertDuration: view.opt('dragRevertDuration'),
            zIndex: 2
          });
          var dragListener = new HitDragListener(view, {
            distance: 5,
            scroll: view.opt('dragScroll'),
            subjectEl: el,
            subjectCenter: true,
            listenStart: function(ev) {
              mouseFollower.hide();
              mouseFollower.start(ev);
            },
            dragStart: function(ev) {
              _this.triggerSegMouseout(seg, ev);
              _this.segDragStart(seg, ev);
              view.hideEvent(event);
            },
            hitOver: function(hit, isOrig, origHit) {
              if (seg.hit) {
                origHit = seg.hit;
              }
              dropLocation = _this.computeEventDrop(origHit.component.getHitSpan(origHit), hit.component.getHitSpan(hit), event);
              if (dropLocation && !calendar.isEventSpanAllowed(_this.eventToSpan(dropLocation), event)) {
                disableCursor();
                dropLocation = null;
              }
              if (dropLocation && view.renderDrag(dropLocation, seg)) {
                mouseFollower.hide();
              } else {
                mouseFollower.show();
              }
              if (isOrig) {
                dropLocation = null;
              }
            },
            hitOut: function() {
              view.unrenderDrag();
              mouseFollower.show();
              dropLocation = null;
            },
            hitDone: function() {
              enableCursor();
            },
            dragStop: function(ev) {
              mouseFollower.stop(!dropLocation, function() {
                view.unrenderDrag();
                view.showEvent(event);
                _this.segDragStop(seg, ev);
                if (dropLocation) {
                  view.reportEventDrop(event, dropLocation, this.largeUnit, el, ev);
                }
              });
            },
            listenStop: function() {
              mouseFollower.stop();
            }
          });
          dragListener.mousedown(ev);
        },
        segDragStart: function(seg, ev) {
          this.isDraggingSeg = true;
          this.view.trigger('eventDragStart', seg.el[0], seg.event, ev, {});
        },
        segDragStop: function(seg, ev) {
          this.isDraggingSeg = false;
          this.view.trigger('eventDragStop', seg.el[0], seg.event, ev, {});
        },
        computeEventDrop: function(startSpan, endSpan, event) {
          var calendar = this.view.calendar;
          var dragStart = startSpan.start;
          var dragEnd = endSpan.start;
          var delta;
          var dropLocation;
          if (dragStart.hasTime() === dragEnd.hasTime()) {
            delta = this.diffDates(dragEnd, dragStart);
            if (event.allDay && durationHasTime(delta)) {
              dropLocation = {
                start: event.start.clone(),
                end: calendar.getEventEnd(event),
                allDay: false
              };
              calendar.normalizeEventTimes(dropLocation);
            } else {
              dropLocation = {
                start: event.start.clone(),
                end: event.end ? event.end.clone() : null,
                allDay: event.allDay
              };
            }
            dropLocation.start.add(delta);
            if (dropLocation.end) {
              dropLocation.end.add(delta);
            }
          } else {
            dropLocation = {
              start: dragEnd.clone(),
              end: null,
              allDay: !dragEnd.hasTime()
            };
          }
          return dropLocation;
        },
        applyDragOpacity: function(els) {
          var opacity = this.view.opt('dragOpacity');
          if (opacity != null) {
            els.each(function(i, node) {
              node.style.opacity = opacity;
            });
          }
        },
        externalDragStart: function(ev, ui) {
          var view = this.view;
          var el;
          var accept;
          if (view.opt('droppable')) {
            el = $((ui ? ui.item : null) || ev.target);
            accept = view.opt('dropAccept');
            if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
              if (!this.isDraggingExternal) {
                this.listenToExternalDrag(el, ev, ui);
              }
            }
          }
        },
        listenToExternalDrag: function(el, ev, ui) {
          var _this = this;
          var meta = getDraggedElMeta(el);
          var dropLocation;
          var dragListener = new HitDragListener(this, {
            listenStart: function() {
              _this.isDraggingExternal = true;
            },
            hitOver: function(hit) {
              dropLocation = _this.computeExternalDrop(hit.component.getHitSpan(hit), meta);
              if (dropLocation) {
                _this.renderDrag(dropLocation);
              } else {
                disableCursor();
              }
            },
            hitOut: function() {
              dropLocation = null;
              _this.unrenderDrag();
              enableCursor();
            },
            dragStop: function() {
              _this.unrenderDrag();
              enableCursor();
              if (dropLocation) {
                _this.view.reportExternalDrop(meta, dropLocation, el, ev, ui);
              }
            },
            listenStop: function() {
              _this.isDraggingExternal = false;
            }
          });
          dragListener.startDrag(ev);
        },
        computeExternalDrop: function(span, meta) {
          var calendar = this.view.calendar;
          var dropLocation = {
            start: calendar.applyTimezone(span.start),
            end: null
          };
          if (meta.startTime && !dropLocation.start.hasTime()) {
            dropLocation.start.time(meta.startTime);
          }
          if (meta.duration) {
            dropLocation.end = dropLocation.start.clone().add(meta.duration);
          }
          if (!calendar.isExternalSpanAllowed(this.eventToSpan(dropLocation), dropLocation, meta.eventProps)) {
            return null;
          }
          return dropLocation;
        },
        renderDrag: function(dropLocation, seg) {},
        unrenderDrag: function() {},
        segResizeMousedown: function(seg, ev, isStart) {
          var _this = this;
          var view = this.view;
          var calendar = view.calendar;
          var el = seg.el;
          var event = seg.event;
          var eventEnd = calendar.getEventEnd(event);
          var resizeLocation;
          var dragListener = new HitDragListener(this, {
            distance: 5,
            scroll: view.opt('dragScroll'),
            subjectEl: el,
            dragStart: function(ev) {
              _this.triggerSegMouseout(seg, ev);
              _this.segResizeStart(seg, ev);
            },
            hitOver: function(hit, isOrig, origHit) {
              var origHitSpan = _this.getHitSpan(origHit);
              var hitSpan = _this.getHitSpan(hit);
              resizeLocation = isStart ? _this.computeEventStartResize(origHitSpan, hitSpan, event) : _this.computeEventEndResize(origHitSpan, hitSpan, event);
              if (resizeLocation) {
                if (!calendar.isEventSpanAllowed(_this.eventToSpan(resizeLocation), event)) {
                  disableCursor();
                  resizeLocation = null;
                } else if (resizeLocation.start.isSame(event.start) && resizeLocation.end.isSame(eventEnd)) {
                  resizeLocation = null;
                }
              }
              if (resizeLocation) {
                view.hideEvent(event);
                _this.renderEventResize(resizeLocation, seg);
              }
            },
            hitOut: function() {
              resizeLocation = null;
            },
            hitDone: function() {
              _this.unrenderEventResize();
              view.showEvent(event);
              enableCursor();
            },
            dragStop: function(ev) {
              _this.segResizeStop(seg, ev);
              if (resizeLocation) {
                view.reportEventResize(event, resizeLocation, this.largeUnit, el, ev);
              }
            }
          });
          dragListener.mousedown(ev);
        },
        segResizeStart: function(seg, ev) {
          this.isResizingSeg = true;
          this.view.trigger('eventResizeStart', seg.el[0], seg.event, ev, {});
        },
        segResizeStop: function(seg, ev) {
          this.isResizingSeg = false;
          this.view.trigger('eventResizeStop', seg.el[0], seg.event, ev, {});
        },
        computeEventStartResize: function(startSpan, endSpan, event) {
          return this.computeEventResize('start', startSpan, endSpan, event);
        },
        computeEventEndResize: function(startSpan, endSpan, event) {
          return this.computeEventResize('end', startSpan, endSpan, event);
        },
        computeEventResize: function(type, startSpan, endSpan, event) {
          var calendar = this.view.calendar;
          var delta = this.diffDates(endSpan[type], startSpan[type]);
          var resizeLocation;
          var defaultDuration;
          resizeLocation = {
            start: event.start.clone(),
            end: calendar.getEventEnd(event),
            allDay: event.allDay
          };
          if (resizeLocation.allDay && durationHasTime(delta)) {
            resizeLocation.allDay = false;
            calendar.normalizeEventTimes(resizeLocation);
          }
          resizeLocation[type].add(delta);
          if (!resizeLocation.start.isBefore(resizeLocation.end)) {
            defaultDuration = this.minResizeDuration || (event.allDay ? calendar.defaultAllDayEventDuration : calendar.defaultTimedEventDuration);
            if (type == 'start') {
              resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);
            } else {
              resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);
            }
          }
          return resizeLocation;
        },
        renderEventResize: function(range, seg) {},
        unrenderEventResize: function() {},
        getEventTimeText: function(range, formatStr, displayEnd) {
          if (formatStr == null) {
            formatStr = this.eventTimeFormat;
          }
          if (displayEnd == null) {
            displayEnd = this.displayEventEnd;
          }
          if (this.displayEventTime && range.start.hasTime()) {
            if (displayEnd && range.end) {
              return this.view.formatRange(range, formatStr);
            } else {
              return range.start.format(formatStr);
            }
          }
          return '';
        },
        getSegClasses: function(seg, isDraggable, isResizable) {
          var event = seg.event;
          var classes = ['fc-event', seg.isStart ? 'fc-start' : 'fc-not-start', seg.isEnd ? 'fc-end' : 'fc-not-end'].concat(event.className, event.source ? event.source.className : []);
          if (isDraggable) {
            classes.push('fc-draggable');
          }
          if (isResizable) {
            classes.push('fc-resizable');
          }
          return classes;
        },
        getEventSkinCss: function(event) {
          var view = this.view;
          var source = event.source || {};
          var eventColor = event.color;
          var sourceColor = source.color;
          var optionColor = view.opt('eventColor');
          return {
            'background-color': event.backgroundColor || eventColor || source.backgroundColor || sourceColor || view.opt('eventBackgroundColor') || optionColor,
            'border-color': event.borderColor || eventColor || source.borderColor || sourceColor || view.opt('eventBorderColor') || optionColor,
            color: event.textColor || source.textColor || view.opt('eventTextColor')
          };
        },
        eventToSegs: function(event) {
          return this.eventsToSegs([event]);
        },
        eventToSpan: function(event) {
          var range = this.eventToRange(event);
          this.transformEventSpan(range, event);
          return range;
        },
        eventsToSegs: function(allEvents, segSliceFunc) {
          var _this = this;
          var eventsById = groupEventsById(allEvents);
          var segs = [];
          $.each(eventsById, function(id, events) {
            var ranges = [];
            var i;
            for (i = 0; i < events.length; i++) {
              ranges.push(_this.eventToRange(events[i]));
            }
            if (isInverseBgEvent(events[0])) {
              ranges = _this.invertRanges(ranges);
              for (i = 0; i < ranges.length; i++) {
                _this.generateEventSegs(ranges[i], events[0], segSliceFunc, segs);
              }
            } else {
              for (i = 0; i < ranges.length; i++) {
                _this.generateEventSegs(ranges[i], events[i], segSliceFunc, segs);
              }
            }
          });
          return segs;
        },
        eventToRange: function(event) {
          return {
            start: event.start.clone().stripZone(),
            end: this.view.calendar.getEventEnd(event).stripZone()
          };
        },
        generateEventSegs: function(range, event, segSliceFunc, out) {
          var segs;
          var i;
          this.transformEventSpan(range, event);
          segs = segSliceFunc ? segSliceFunc(range) : this.spanToSegs(range);
          for (i = 0; i < segs.length; i++) {
            this.transformEventSeg(segs[i], range, event);
            out.push(segs[i]);
          }
        },
        transformEventSpan: function(range, event) {},
        transformEventSeg: function(seg, span, event) {
          seg.event = event;
          seg.eventStartMS = +span.start;
          seg.eventDurationMS = span.end - span.start;
        },
        invertRanges: function(ranges) {
          var view = this.view;
          var viewStart = view.start.clone();
          var viewEnd = view.end.clone();
          var inverseRanges = [];
          var start = viewStart;
          var i,
              range;
          ranges.sort(compareRanges);
          for (i = 0; i < ranges.length; i++) {
            range = ranges[i];
            if (range.start > start) {
              inverseRanges.push({
                start: start,
                end: range.start
              });
            }
            start = range.end;
          }
          if (start < viewEnd) {
            inverseRanges.push({
              start: start,
              end: viewEnd
            });
          }
          return inverseRanges;
        },
        sortEventSegs: function(segs) {
          segs.sort(proxy(this, 'compareEventSegs'));
        },
        compareEventSegs: function(seg1, seg2) {
          return seg1.eventStartMS - seg2.eventStartMS || seg2.eventDurationMS - seg1.eventDurationMS || seg2.event.allDay - seg1.event.allDay || compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
        }
      });
      function isBgEvent(event) {
        var rendering = getEventRendering(event);
        return rendering === 'background' || rendering === 'inverse-background';
      }
      function isInverseBgEvent(event) {
        return getEventRendering(event) === 'inverse-background';
      }
      function getEventRendering(event) {
        return firstDefined((event.source || {}).rendering, event.rendering);
      }
      function groupEventsById(events) {
        var eventsById = {};
        var i,
            event;
        for (i = 0; i < events.length; i++) {
          event = events[i];
          (eventsById[event._id] || (eventsById[event._id] = [])).push(event);
        }
        return eventsById;
      }
      function compareRanges(range1, range2) {
        return range1.start - range2.start;
      }
      FC.dataAttrPrefix = '';
      function getDraggedElMeta(el) {
        var prefix = FC.dataAttrPrefix;
        var eventProps;
        var startTime;
        var duration;
        var stick;
        if (prefix) {
          prefix += '-';
        }
        eventProps = el.data(prefix + 'event') || null;
        if (eventProps) {
          if (typeof eventProps === 'object') {
            eventProps = $.extend({}, eventProps);
          } else {
            eventProps = {};
          }
          startTime = eventProps.start;
          if (startTime == null) {
            startTime = eventProps.time;
          }
          duration = eventProps.duration;
          stick = eventProps.stick;
          delete eventProps.start;
          delete eventProps.time;
          delete eventProps.duration;
          delete eventProps.stick;
        }
        if (startTime == null) {
          startTime = el.data(prefix + 'start');
        }
        if (startTime == null) {
          startTime = el.data(prefix + 'time');
        }
        if (duration == null) {
          duration = el.data(prefix + 'duration');
        }
        if (stick == null) {
          stick = el.data(prefix + 'stick');
        }
        startTime = startTime != null ? moment.duration(startTime) : null;
        duration = duration != null ? moment.duration(duration) : null;
        stick = Boolean(stick);
        return {
          eventProps: eventProps,
          startTime: startTime,
          duration: duration,
          stick: stick
        };
      }
      ;
      ;
      var DayTableMixin = FC.DayTableMixin = {
        breakOnWeeks: false,
        dayDates: null,
        dayIndices: null,
        daysPerRow: null,
        rowCnt: null,
        colCnt: null,
        colHeadFormat: null,
        updateDayTable: function() {
          var view = this.view;
          var date = this.start.clone();
          var dayIndex = -1;
          var dayIndices = [];
          var dayDates = [];
          var daysPerRow;
          var firstDay;
          var rowCnt;
          while (date.isBefore(this.end)) {
            if (view.isHiddenDay(date)) {
              dayIndices.push(dayIndex + 0.5);
            } else {
              dayIndex++;
              dayIndices.push(dayIndex);
              dayDates.push(date.clone());
            }
            date.add(1, 'days');
          }
          if (this.breakOnWeeks) {
            firstDay = dayDates[0].day();
            for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
              if (dayDates[daysPerRow].day() == firstDay) {
                break;
              }
            }
            rowCnt = Math.ceil(dayDates.length / daysPerRow);
          } else {
            rowCnt = 1;
            daysPerRow = dayDates.length;
          }
          this.dayDates = dayDates;
          this.dayIndices = dayIndices;
          this.daysPerRow = daysPerRow;
          this.rowCnt = rowCnt;
          this.updateDayTableCols();
        },
        updateDayTableCols: function() {
          this.colCnt = this.computeColCnt();
          this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();
        },
        computeColCnt: function() {
          return this.daysPerRow;
        },
        getCellDate: function(row, col) {
          return this.dayDates[this.getCellDayIndex(row, col)].clone();
        },
        getCellRange: function(row, col) {
          var start = this.getCellDate(row, col);
          var end = start.clone().add(1, 'days');
          return {
            start: start,
            end: end
          };
        },
        getCellDayIndex: function(row, col) {
          return row * this.daysPerRow + this.getColDayIndex(col);
        },
        getColDayIndex: function(col) {
          if (this.isRTL) {
            return this.colCnt - 1 - col;
          } else {
            return col;
          }
        },
        getDateDayIndex: function(date) {
          var dayIndices = this.dayIndices;
          var dayOffset = date.diff(this.start, 'days');
          if (dayOffset < 0) {
            return dayIndices[0] - 1;
          } else if (dayOffset >= dayIndices.length) {
            return dayIndices[dayIndices.length - 1] + 1;
          } else {
            return dayIndices[dayOffset];
          }
        },
        computeColHeadFormat: function() {
          if (this.rowCnt > 1 || this.colCnt > 10) {
            return 'ddd';
          } else if (this.colCnt > 1) {
            return this.view.opt('dayOfMonthFormat');
          } else {
            return 'dddd';
          }
        },
        sliceRangeByRow: function(range) {
          var daysPerRow = this.daysPerRow;
          var normalRange = this.view.computeDayRange(range);
          var rangeFirst = this.getDateDayIndex(normalRange.start);
          var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days'));
          var segs = [];
          var row;
          var rowFirst,
              rowLast;
          var segFirst,
              segLast;
          for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            segFirst = Math.max(rangeFirst, rowFirst);
            segLast = Math.min(rangeLast, rowLast);
            segFirst = Math.ceil(segFirst);
            segLast = Math.floor(segLast);
            if (segFirst <= segLast) {
              segs.push({
                row: row,
                firstRowDayIndex: segFirst - rowFirst,
                lastRowDayIndex: segLast - rowFirst,
                isStart: segFirst === rangeFirst,
                isEnd: segLast === rangeLast
              });
            }
          }
          return segs;
        },
        sliceRangeByDay: function(range) {
          var daysPerRow = this.daysPerRow;
          var normalRange = this.view.computeDayRange(range);
          var rangeFirst = this.getDateDayIndex(normalRange.start);
          var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days'));
          var segs = [];
          var row;
          var rowFirst,
              rowLast;
          var i;
          var segFirst,
              segLast;
          for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            for (i = rowFirst; i <= rowLast; i++) {
              segFirst = Math.max(rangeFirst, i);
              segLast = Math.min(rangeLast, i);
              segFirst = Math.ceil(segFirst);
              segLast = Math.floor(segLast);
              if (segFirst <= segLast) {
                segs.push({
                  row: row,
                  firstRowDayIndex: segFirst - rowFirst,
                  lastRowDayIndex: segLast - rowFirst,
                  isStart: segFirst === rangeFirst,
                  isEnd: segLast === rangeLast
                });
              }
            }
          }
          return segs;
        },
        renderHeadHtml: function() {
          var view = this.view;
          return '' + '<div class="fc-row ' + view.widgetHeaderClass + '">' + '<table>' + '<thead>' + this.renderHeadTrHtml() + '</thead>' + '</table>' + '</div>';
        },
        renderHeadIntroHtml: function() {
          return this.renderIntroHtml();
        },
        renderHeadTrHtml: function() {
          return '' + '<tr>' + (this.isRTL ? '' : this.renderHeadIntroHtml()) + this.renderHeadDateCellsHtml() + (this.isRTL ? this.renderHeadIntroHtml() : '') + '</tr>';
        },
        renderHeadDateCellsHtml: function() {
          var htmls = [];
          var col,
              date;
          for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(0, col);
            htmls.push(this.renderHeadDateCellHtml(date));
          }
          return htmls.join('');
        },
        renderHeadDateCellHtml: function(date, colspan) {
          var view = this.view;
          return '' + '<th class="fc-day-header ' + view.widgetHeaderClass + ' fc-' + dayIDs[date.day()] + '"' + (colspan > 1 ? ' colspan="' + colspan + '"' : '') + '>' + htmlEscape(date.format(this.colHeadFormat)) + '</th>';
        },
        renderBgTrHtml: function(row) {
          return '' + '<tr>' + (this.isRTL ? '' : this.renderBgIntroHtml(row)) + this.renderBgCellsHtml(row) + (this.isRTL ? this.renderBgIntroHtml(row) : '') + '</tr>';
        },
        renderBgIntroHtml: function(row) {
          return this.renderIntroHtml();
        },
        renderBgCellsHtml: function(row) {
          var htmls = [];
          var col,
              date;
          for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderBgCellHtml(date));
          }
          return htmls.join('');
        },
        renderBgCellHtml: function(date) {
          var view = this.view;
          var classes = this.getDayClasses(date);
          classes.unshift('fc-day', view.widgetContentClass);
          return '<td class="' + classes.join(' ') + '"' + ' data-date="' + date.format('YYYY-MM-DD') + '"' + '></td>';
        },
        renderIntroHtml: function() {},
        bookendCells: function(trEl) {
          var introHtml = this.renderIntroHtml();
          if (introHtml) {
            if (this.isRTL) {
              trEl.append(introHtml);
            } else {
              trEl.prepend(introHtml);
            }
          }
        }
      };
      ;
      ;
      var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {
        numbersVisible: false,
        bottomCoordPadding: 0,
        rowEls: null,
        cellEls: null,
        helperEls: null,
        rowCoordCache: null,
        colCoordCache: null,
        renderDates: function(isRigid) {
          var view = this.view;
          var rowCnt = this.rowCnt;
          var colCnt = this.colCnt;
          var html = '';
          var row;
          var col;
          for (row = 0; row < rowCnt; row++) {
            html += this.renderDayRowHtml(row, isRigid);
          }
          this.el.html(html);
          this.rowEls = this.el.find('.fc-row');
          this.cellEls = this.el.find('.fc-day');
          this.rowCoordCache = new CoordCache({
            els: this.rowEls,
            isVertical: true
          });
          this.colCoordCache = new CoordCache({
            els: this.cellEls.slice(0, this.colCnt),
            isHorizontal: true
          });
          for (row = 0; row < rowCnt; row++) {
            for (col = 0; col < colCnt; col++) {
              view.trigger('dayRender', null, this.getCellDate(row, col), this.getCellEl(row, col));
            }
          }
        },
        unrenderDates: function() {
          this.removeSegPopover();
        },
        renderBusinessHours: function() {
          var events = this.view.calendar.getBusinessHoursEvents(true);
          var segs = this.eventsToSegs(events);
          this.renderFill('businessHours', segs, 'bgevent');
        },
        renderDayRowHtml: function(row, isRigid) {
          var view = this.view;
          var classes = ['fc-row', 'fc-week', view.widgetContentClass];
          if (isRigid) {
            classes.push('fc-rigid');
          }
          return '' + '<div class="' + classes.join(' ') + '">' + '<div class="fc-bg">' + '<table>' + this.renderBgTrHtml(row) + '</table>' + '</div>' + '<div class="fc-content-skeleton">' + '<table>' + (this.numbersVisible ? '<thead>' + this.renderNumberTrHtml(row) + '</thead>' : '') + '</table>' + '</div>' + '</div>';
        },
        renderNumberTrHtml: function(row) {
          return '' + '<tr>' + (this.isRTL ? '' : this.renderNumberIntroHtml(row)) + this.renderNumberCellsHtml(row) + (this.isRTL ? this.renderNumberIntroHtml(row) : '') + '</tr>';
        },
        renderNumberIntroHtml: function(row) {
          return this.renderIntroHtml();
        },
        renderNumberCellsHtml: function(row) {
          var htmls = [];
          var col,
              date;
          for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderNumberCellHtml(date));
          }
          return htmls.join('');
        },
        renderNumberCellHtml: function(date) {
          var classes;
          if (!this.view.dayNumbersVisible) {
            return '<td/>';
          }
          classes = this.getDayClasses(date);
          classes.unshift('fc-day-number');
          return '' + '<td class="' + classes.join(' ') + '" data-date="' + date.format() + '">' + date.date() + '</td>';
        },
        computeEventTimeFormat: function() {
          return this.view.opt('extraSmallTimeFormat');
        },
        computeDisplayEventEnd: function() {
          return this.colCnt == 1;
        },
        rangeUpdated: function() {
          this.updateDayTable();
        },
        spanToSegs: function(span) {
          var segs = this.sliceRangeByRow(span);
          var i,
              seg;
          for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (this.isRTL) {
              seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
              seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
            } else {
              seg.leftCol = seg.firstRowDayIndex;
              seg.rightCol = seg.lastRowDayIndex;
            }
          }
          return segs;
        },
        prepareHits: function() {
          this.colCoordCache.build();
          this.rowCoordCache.build();
          this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding;
        },
        releaseHits: function() {
          this.colCoordCache.clear();
          this.rowCoordCache.clear();
        },
        queryHit: function(leftOffset, topOffset) {
          var col = this.colCoordCache.getHorizontalIndex(leftOffset);
          var row = this.rowCoordCache.getVerticalIndex(topOffset);
          if (row != null && col != null) {
            return this.getCellHit(row, col);
          }
        },
        getHitSpan: function(hit) {
          return this.getCellRange(hit.row, hit.col);
        },
        getHitEl: function(hit) {
          return this.getCellEl(hit.row, hit.col);
        },
        getCellHit: function(row, col) {
          return {
            row: row,
            col: col,
            component: this,
            left: this.colCoordCache.getLeftOffset(col),
            right: this.colCoordCache.getRightOffset(col),
            top: this.rowCoordCache.getTopOffset(row),
            bottom: this.rowCoordCache.getBottomOffset(row)
          };
        },
        getCellEl: function(row, col) {
          return this.cellEls.eq(row * this.colCnt + col);
        },
        renderDrag: function(eventLocation, seg) {
          this.renderHighlight(this.eventToSpan(eventLocation));
          if (seg && !seg.el.closest(this.el).length) {
            this.renderEventLocationHelper(eventLocation, seg);
            this.applyDragOpacity(this.helperEls);
            return true;
          }
        },
        unrenderDrag: function() {
          this.unrenderHighlight();
          this.unrenderHelper();
        },
        renderEventResize: function(eventLocation, seg) {
          this.renderHighlight(this.eventToSpan(eventLocation));
          this.renderEventLocationHelper(eventLocation, seg);
        },
        unrenderEventResize: function() {
          this.unrenderHighlight();
          this.unrenderHelper();
        },
        renderHelper: function(event, sourceSeg) {
          var helperNodes = [];
          var segs = this.eventToSegs(event);
          var rowStructs;
          segs = this.renderFgSegEls(segs);
          rowStructs = this.renderSegRows(segs);
          this.rowEls.each(function(row, rowNode) {
            var rowEl = $(rowNode);
            var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>');
            var skeletonTop;
            if (sourceSeg && sourceSeg.row === row) {
              skeletonTop = sourceSeg.el.position().top;
            } else {
              skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
            }
            skeletonEl.css('top', skeletonTop).find('table').append(rowStructs[row].tbodyEl);
            rowEl.append(skeletonEl);
            helperNodes.push(skeletonEl[0]);
          });
          this.helperEls = $(helperNodes);
        },
        unrenderHelper: function() {
          if (this.helperEls) {
            this.helperEls.remove();
            this.helperEls = null;
          }
        },
        fillSegTag: 'td',
        renderFill: function(type, segs, className) {
          var nodes = [];
          var i,
              seg;
          var skeletonEl;
          segs = this.renderFillSegEls(type, segs);
          for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            skeletonEl = this.renderFillRow(type, seg, className);
            this.rowEls.eq(seg.row).append(skeletonEl);
            nodes.push(skeletonEl[0]);
          }
          this.elsByFill[type] = $(nodes);
          return segs;
        },
        renderFillRow: function(type, seg, className) {
          var colCnt = this.colCnt;
          var startCol = seg.leftCol;
          var endCol = seg.rightCol + 1;
          var skeletonEl;
          var trEl;
          className = className || type.toLowerCase();
          skeletonEl = $('<div class="fc-' + className + '-skeleton">' + '<table><tr/></table>' + '</div>');
          trEl = skeletonEl.find('tr');
          if (startCol > 0) {
            trEl.append('<td colspan="' + startCol + '"/>');
          }
          trEl.append(seg.el.attr('colspan', endCol - startCol));
          if (endCol < colCnt) {
            trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
          }
          this.bookendCells(trEl);
          return skeletonEl;
        }
      });
      ;
      ;
      DayGrid.mixin({
        rowStructs: null,
        unrenderEvents: function() {
          this.removeSegPopover();
          Grid.prototype.unrenderEvents.apply(this, arguments);
        },
        getEventSegs: function() {
          return Grid.prototype.getEventSegs.call(this).concat(this.popoverSegs || []);
        },
        renderBgSegs: function(segs) {
          var allDaySegs = $.grep(segs, function(seg) {
            return seg.event.allDay;
          });
          return Grid.prototype.renderBgSegs.call(this, allDaySegs);
        },
        renderFgSegs: function(segs) {
          var rowStructs;
          segs = this.renderFgSegEls(segs);
          rowStructs = this.rowStructs = this.renderSegRows(segs);
          this.rowEls.each(function(i, rowNode) {
            $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);
          });
          return segs;
        },
        unrenderFgSegs: function() {
          var rowStructs = this.rowStructs || [];
          var rowStruct;
          while ((rowStruct = rowStructs.pop())) {
            rowStruct.tbodyEl.remove();
          }
          this.rowStructs = null;
        },
        renderSegRows: function(segs) {
          var rowStructs = [];
          var segRows;
          var row;
          segRows = this.groupSegRows(segs);
          for (row = 0; row < segRows.length; row++) {
            rowStructs.push(this.renderSegRow(row, segRows[row]));
          }
          return rowStructs;
        },
        fgSegHtml: function(seg, disableResizing) {
          var view = this.view;
          var event = seg.event;
          var isDraggable = view.isEventDraggable(event);
          var isResizableFromStart = !disableResizing && event.allDay && seg.isStart && view.isEventResizableFromStart(event);
          var isResizableFromEnd = !disableResizing && event.allDay && seg.isEnd && view.isEventResizableFromEnd(event);
          var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
          var skinCss = cssToStr(this.getEventSkinCss(event));
          var timeHtml = '';
          var timeText;
          var titleHtml;
          classes.unshift('fc-day-grid-event', 'fc-h-event');
          if (seg.isStart) {
            timeText = this.getEventTimeText(event);
            if (timeText) {
              timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + '</span>';
            }
          }
          titleHtml = '<span class="fc-title">' + (htmlEscape(event.title || '') || '&nbsp;') + '</span>';
          return '<a class="' + classes.join(' ') + '"' + (event.url ? ' href="' + htmlEscape(event.url) + '"' : '') + (skinCss ? ' style="' + skinCss + '"' : '') + '>' + '<div class="fc-content">' + (this.isRTL ? titleHtml + ' ' + timeHtml : timeHtml + ' ' + titleHtml) + '</div>' + (isResizableFromStart ? '<div class="fc-resizer fc-start-resizer" />' : '') + (isResizableFromEnd ? '<div class="fc-resizer fc-end-resizer" />' : '') + '</a>';
        },
        renderSegRow: function(row, rowSegs) {
          var colCnt = this.colCnt;
          var segLevels = this.buildSegLevels(rowSegs);
          var levelCnt = Math.max(1, segLevels.length);
          var tbody = $('<tbody/>');
          var segMatrix = [];
          var cellMatrix = [];
          var loneCellMatrix = [];
          var i,
              levelSegs;
          var col;
          var tr;
          var j,
              seg;
          var td;
          function emptyCellsUntil(endCol) {
            while (col < endCol) {
              td = (loneCellMatrix[i - 1] || [])[col];
              if (td) {
                td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);
              } else {
                td = $('<td/>');
                tr.append(td);
              }
              cellMatrix[i][col] = td;
              loneCellMatrix[i][col] = td;
              col++;
            }
          }
          for (i = 0; i < levelCnt; i++) {
            levelSegs = segLevels[i];
            col = 0;
            tr = $('<tr/>');
            segMatrix.push([]);
            cellMatrix.push([]);
            loneCellMatrix.push([]);
            if (levelSegs) {
              for (j = 0; j < levelSegs.length; j++) {
                seg = levelSegs[j];
                emptyCellsUntil(seg.leftCol);
                td = $('<td class="fc-event-container"/>').append(seg.el);
                if (seg.leftCol != seg.rightCol) {
                  td.attr('colspan', seg.rightCol - seg.leftCol + 1);
                } else {
                  loneCellMatrix[i][col] = td;
                }
                while (col <= seg.rightCol) {
                  cellMatrix[i][col] = td;
                  segMatrix[i][col] = seg;
                  col++;
                }
                tr.append(td);
              }
            }
            emptyCellsUntil(colCnt);
            this.bookendCells(tr);
            tbody.append(tr);
          }
          return {
            row: row,
            tbodyEl: tbody,
            cellMatrix: cellMatrix,
            segMatrix: segMatrix,
            segLevels: segLevels,
            segs: rowSegs
          };
        },
        buildSegLevels: function(segs) {
          var levels = [];
          var i,
              seg;
          var j;
          this.sortEventSegs(segs);
          for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            for (j = 0; j < levels.length; j++) {
              if (!isDaySegCollision(seg, levels[j])) {
                break;
              }
            }
            seg.level = j;
            (levels[j] || (levels[j] = [])).push(seg);
          }
          for (j = 0; j < levels.length; j++) {
            levels[j].sort(compareDaySegCols);
          }
          return levels;
        },
        groupSegRows: function(segs) {
          var segRows = [];
          var i;
          for (i = 0; i < this.rowCnt; i++) {
            segRows.push([]);
          }
          for (i = 0; i < segs.length; i++) {
            segRows[segs[i].row].push(segs[i]);
          }
          return segRows;
        }
      });
      function isDaySegCollision(seg, otherSegs) {
        var i,
            otherSeg;
        for (i = 0; i < otherSegs.length; i++) {
          otherSeg = otherSegs[i];
          if (otherSeg.leftCol <= seg.rightCol && otherSeg.rightCol >= seg.leftCol) {
            return true;
          }
        }
        return false;
      }
      function compareDaySegCols(a, b) {
        return a.leftCol - b.leftCol;
      }
      ;
      ;
      DayGrid.mixin({
        segPopover: null,
        popoverSegs: null,
        removeSegPopover: function() {
          if (this.segPopover) {
            this.segPopover.hide();
          }
        },
        limitRows: function(levelLimit) {
          var rowStructs = this.rowStructs || [];
          var row;
          var rowLevelLimit;
          for (row = 0; row < rowStructs.length; row++) {
            this.unlimitRow(row);
            if (!levelLimit) {
              rowLevelLimit = false;
            } else if (typeof levelLimit === 'number') {
              rowLevelLimit = levelLimit;
            } else {
              rowLevelLimit = this.computeRowLevelLimit(row);
            }
            if (rowLevelLimit !== false) {
              this.limitRow(row, rowLevelLimit);
            }
          }
        },
        computeRowLevelLimit: function(row) {
          var rowEl = this.rowEls.eq(row);
          var rowHeight = rowEl.height();
          var trEls = this.rowStructs[row].tbodyEl.children();
          var i,
              trEl;
          var trHeight;
          function iterInnerHeights(i, childNode) {
            trHeight = Math.max(trHeight, $(childNode).outerHeight());
          }
          for (i = 0; i < trEls.length; i++) {
            trEl = trEls.eq(i).removeClass('fc-limited');
            trHeight = 0;
            trEl.find('> td > :first-child').each(iterInnerHeights);
            if (trEl.position().top + trHeight > rowHeight) {
              return i;
            }
          }
          return false;
        },
        limitRow: function(row, levelLimit) {
          var _this = this;
          var rowStruct = this.rowStructs[row];
          var moreNodes = [];
          var col = 0;
          var levelSegs;
          var cellMatrix;
          var limitedNodes;
          var i,
              seg;
          var segsBelow;
          var totalSegsBelow;
          var colSegsBelow;
          var td,
              rowspan;
          var segMoreNodes;
          var j;
          var moreTd,
              moreWrap,
              moreLink;
          function emptyCellsUntil(endCol) {
            while (col < endCol) {
              segsBelow = _this.getCellSegs(row, col, levelLimit);
              if (segsBelow.length) {
                td = cellMatrix[levelLimit - 1][col];
                moreLink = _this.renderMoreLink(row, col, segsBelow);
                moreWrap = $('<div/>').append(moreLink);
                td.append(moreWrap);
                moreNodes.push(moreWrap[0]);
              }
              col++;
            }
          }
          if (levelLimit && levelLimit < rowStruct.segLevels.length) {
            levelSegs = rowStruct.segLevels[levelLimit - 1];
            cellMatrix = rowStruct.cellMatrix;
            limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit).addClass('fc-limited').get();
            for (i = 0; i < levelSegs.length; i++) {
              seg = levelSegs[i];
              emptyCellsUntil(seg.leftCol);
              colSegsBelow = [];
              totalSegsBelow = 0;
              while (col <= seg.rightCol) {
                segsBelow = this.getCellSegs(row, col, levelLimit);
                colSegsBelow.push(segsBelow);
                totalSegsBelow += segsBelow.length;
                col++;
              }
              if (totalSegsBelow) {
                td = cellMatrix[levelLimit - 1][seg.leftCol];
                rowspan = td.attr('rowspan') || 1;
                segMoreNodes = [];
                for (j = 0; j < colSegsBelow.length; j++) {
                  moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
                  segsBelow = colSegsBelow[j];
                  moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow));
                  moreWrap = $('<div/>').append(moreLink);
                  moreTd.append(moreWrap);
                  segMoreNodes.push(moreTd[0]);
                  moreNodes.push(moreTd[0]);
                }
                td.addClass('fc-limited').after($(segMoreNodes));
                limitedNodes.push(td[0]);
              }
            }
            emptyCellsUntil(this.colCnt);
            rowStruct.moreEls = $(moreNodes);
            rowStruct.limitedEls = $(limitedNodes);
          }
        },
        unlimitRow: function(row) {
          var rowStruct = this.rowStructs[row];
          if (rowStruct.moreEls) {
            rowStruct.moreEls.remove();
            rowStruct.moreEls = null;
          }
          if (rowStruct.limitedEls) {
            rowStruct.limitedEls.removeClass('fc-limited');
            rowStruct.limitedEls = null;
          }
        },
        renderMoreLink: function(row, col, hiddenSegs) {
          var _this = this;
          var view = this.view;
          return $('<a class="fc-more"/>').text(this.getMoreLinkText(hiddenSegs.length)).on('click', function(ev) {
            var clickOption = view.opt('eventLimitClick');
            var date = _this.getCellDate(row, col);
            var moreEl = $(this);
            var dayEl = _this.getCellEl(row, col);
            var allSegs = _this.getCellSegs(row, col);
            var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
            var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
            if (typeof clickOption === 'function') {
              clickOption = view.trigger('eventLimitClick', null, {
                date: date,
                dayEl: dayEl,
                moreEl: moreEl,
                segs: reslicedAllSegs,
                hiddenSegs: reslicedHiddenSegs
              }, ev);
            }
            if (clickOption === 'popover') {
              _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
            } else if (typeof clickOption === 'string') {
              view.calendar.zoomTo(date, clickOption);
            }
          });
        },
        showSegPopover: function(row, col, moreLink, segs) {
          var _this = this;
          var view = this.view;
          var moreWrap = moreLink.parent();
          var topEl;
          var options;
          if (this.rowCnt == 1) {
            topEl = view.el;
          } else {
            topEl = this.rowEls.eq(row);
          }
          options = {
            className: 'fc-more-popover',
            content: this.renderSegPopoverContent(row, col, segs),
            parentEl: this.el,
            top: topEl.offset().top,
            autoHide: true,
            viewportConstrain: view.opt('popoverViewportConstrain'),
            hide: function() {
              _this.segPopover.removeElement();
              _this.segPopover = null;
              _this.popoverSegs = null;
            }
          };
          if (this.isRTL) {
            options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1;
          } else {
            options.left = moreWrap.offset().left - 1;
          }
          this.segPopover = new Popover(options);
          this.segPopover.show();
        },
        renderSegPopoverContent: function(row, col, segs) {
          var view = this.view;
          var isTheme = view.opt('theme');
          var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));
          var content = $('<div class="fc-header ' + view.widgetHeaderClass + '">' + '<span class="fc-close ' + (isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') + '"></span>' + '<span class="fc-title">' + htmlEscape(title) + '</span>' + '<div class="fc-clear"/>' + '</div>' + '<div class="fc-body ' + view.widgetContentClass + '">' + '<div class="fc-event-container"></div>' + '</div>');
          var segContainer = content.find('.fc-event-container');
          var i;
          segs = this.renderFgSegEls(segs, true);
          this.popoverSegs = segs;
          for (i = 0; i < segs.length; i++) {
            this.prepareHits();
            segs[i].hit = this.getCellHit(row, col);
            this.releaseHits();
            segContainer.append(segs[i].el);
          }
          return content;
        },
        resliceDaySegs: function(segs, dayDate) {
          var events = $.map(segs, function(seg) {
            return seg.event;
          });
          var dayStart = dayDate.clone();
          var dayEnd = dayStart.clone().add(1, 'days');
          var dayRange = {
            start: dayStart,
            end: dayEnd
          };
          segs = this.eventsToSegs(events, function(range) {
            var seg = intersectRanges(range, dayRange);
            return seg ? [seg] : [];
          });
          this.sortEventSegs(segs);
          return segs;
        },
        getMoreLinkText: function(num) {
          var opt = this.view.opt('eventLimitText');
          if (typeof opt === 'function') {
            return opt(num);
          } else {
            return '+' + num + ' ' + opt;
          }
        },
        getCellSegs: function(row, col, startLevel) {
          var segMatrix = this.rowStructs[row].segMatrix;
          var level = startLevel || 0;
          var segs = [];
          var seg;
          while (level < segMatrix.length) {
            seg = segMatrix[level][col];
            if (seg) {
              segs.push(seg);
            }
            level++;
          }
          return segs;
        }
      });
      ;
      ;
      var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {
        slotDuration: null,
        snapDuration: null,
        snapsPerSlot: null,
        minTime: null,
        maxTime: null,
        labelFormat: null,
        labelInterval: null,
        colEls: null,
        slatEls: null,
        helperEl: null,
        colCoordCache: null,
        slatCoordCache: null,
        businessHourSegs: null,
        constructor: function() {
          Grid.apply(this, arguments);
          this.processOptions();
        },
        renderDates: function() {
          this.el.html(this.renderHtml());
          this.colEls = this.el.find('.fc-day');
          this.slatEls = this.el.find('.fc-slats tr');
          this.colCoordCache = new CoordCache({
            els: this.colEls,
            isHorizontal: true
          });
          this.slatCoordCache = new CoordCache({
            els: this.slatEls,
            isVertical: true
          });
        },
        renderBusinessHours: function() {
          var events = this.view.calendar.getBusinessHoursEvents();
          this.businessHourSegs = this.renderFill('businessHours', this.eventsToSegs(events), 'bgevent');
        },
        renderHtml: function() {
          return '' + '<div class="fc-bg">' + '<table>' + this.renderBgTrHtml(0) + '</table>' + '</div>' + '<div class="fc-slats">' + '<table>' + this.renderSlatRowHtml() + '</table>' + '</div>';
        },
        renderSlatRowHtml: function() {
          var view = this.view;
          var isRTL = this.isRTL;
          var html = '';
          var slotTime = moment.duration(+this.minTime);
          var slotDate;
          var isLabeled;
          var axisHtml;
          while (slotTime < this.maxTime) {
            slotDate = this.start.clone().time(slotTime);
            isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));
            axisHtml = '<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' + (isLabeled ? '<span>' + htmlEscape(slotDate.format(this.labelFormat)) + '</span>' : '') + '</td>';
            html += '<tr ' + (isLabeled ? '' : 'class="fc-minor"') + '>' + (!isRTL ? axisHtml : '') + '<td class="' + view.widgetContentClass + '"/>' + (isRTL ? axisHtml : '') + "</tr>";
            slotTime.add(this.slotDuration);
          }
          return html;
        },
        processOptions: function() {
          var view = this.view;
          var slotDuration = view.opt('slotDuration');
          var snapDuration = view.opt('snapDuration');
          var input;
          slotDuration = moment.duration(slotDuration);
          snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
          this.slotDuration = slotDuration;
          this.snapDuration = snapDuration;
          this.snapsPerSlot = slotDuration / snapDuration;
          this.minResizeDuration = snapDuration;
          this.minTime = moment.duration(view.opt('minTime'));
          this.maxTime = moment.duration(view.opt('maxTime'));
          input = view.opt('slotLabelFormat');
          if ($.isArray(input)) {
            input = input[input.length - 1];
          }
          this.labelFormat = input || view.opt('axisFormat') || view.opt('smallTimeFormat');
          input = view.opt('slotLabelInterval');
          this.labelInterval = input ? moment.duration(input) : this.computeLabelInterval(slotDuration);
        },
        computeLabelInterval: function(slotDuration) {
          var i;
          var labelInterval;
          var slotsPerLabel;
          for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
            labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
            slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
            if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
              return labelInterval;
            }
          }
          return moment.duration(slotDuration);
        },
        computeEventTimeFormat: function() {
          return this.view.opt('noMeridiemTimeFormat');
        },
        computeDisplayEventEnd: function() {
          return true;
        },
        prepareHits: function() {
          this.colCoordCache.build();
          this.slatCoordCache.build();
        },
        releaseHits: function() {
          this.colCoordCache.clear();
        },
        queryHit: function(leftOffset, topOffset) {
          var snapsPerSlot = this.snapsPerSlot;
          var colCoordCache = this.colCoordCache;
          var slatCoordCache = this.slatCoordCache;
          var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
          var slatIndex = slatCoordCache.getVerticalIndex(topOffset);
          if (colIndex != null && slatIndex != null) {
            var slatTop = slatCoordCache.getTopOffset(slatIndex);
            var slatHeight = slatCoordCache.getHeight(slatIndex);
            var partial = (topOffset - slatTop) / slatHeight;
            var localSnapIndex = Math.floor(partial * snapsPerSlot);
            var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
            var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
            var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;
            return {
              col: colIndex,
              snap: snapIndex,
              component: this,
              left: colCoordCache.getLeftOffset(colIndex),
              right: colCoordCache.getRightOffset(colIndex),
              top: snapTop,
              bottom: snapBottom
            };
          }
        },
        getHitSpan: function(hit) {
          var start = this.getCellDate(0, hit.col);
          var time = this.computeSnapTime(hit.snap);
          var end;
          start.time(time);
          end = start.clone().add(this.snapDuration);
          return {
            start: start,
            end: end
          };
        },
        getHitEl: function(hit) {
          return this.colEls.eq(hit.col);
        },
        rangeUpdated: function() {
          this.updateDayTable();
        },
        computeSnapTime: function(snapIndex) {
          return moment.duration(this.minTime + this.snapDuration * snapIndex);
        },
        spanToSegs: function(span) {
          var segs = this.sliceRangeByTimes(span);
          var i;
          for (i = 0; i < segs.length; i++) {
            if (this.isRTL) {
              segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
            } else {
              segs[i].col = segs[i].dayIndex;
            }
          }
          return segs;
        },
        sliceRangeByTimes: function(range) {
          var segs = [];
          var seg;
          var dayIndex;
          var dayDate;
          var dayRange;
          for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
            dayDate = this.dayDates[dayIndex].clone();
            dayRange = {
              start: dayDate.clone().time(this.minTime),
              end: dayDate.clone().time(this.maxTime)
            };
            seg = intersectRanges(range, dayRange);
            if (seg) {
              seg.dayIndex = dayIndex;
              segs.push(seg);
            }
          }
          return segs;
        },
        updateSize: function(isResize) {
          this.slatCoordCache.build();
          if (isResize) {
            this.updateSegVerticals();
          }
        },
        computeDateTop: function(date, startOfDayDate) {
          return this.computeTimeTop(moment.duration(date - startOfDayDate.clone().stripTime()));
        },
        computeTimeTop: function(time) {
          var len = this.slatEls.length;
          var slatCoverage = (time - this.minTime) / this.slotDuration;
          var slatIndex;
          var slatRemainder;
          slatCoverage = Math.max(0, slatCoverage);
          slatCoverage = Math.min(len, slatCoverage);
          slatIndex = Math.floor(slatCoverage);
          slatIndex = Math.min(slatIndex, len - 1);
          slatRemainder = slatCoverage - slatIndex;
          return this.slatCoordCache.getTopPosition(slatIndex) + this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
        },
        renderDrag: function(eventLocation, seg) {
          if (seg) {
            this.renderEventLocationHelper(eventLocation, seg);
            this.applyDragOpacity(this.helperEl);
            return true;
          } else {
            this.renderHighlight(this.eventToSpan(eventLocation));
          }
        },
        unrenderDrag: function() {
          this.unrenderHelper();
          this.unrenderHighlight();
        },
        renderEventResize: function(eventLocation, seg) {
          this.renderEventLocationHelper(eventLocation, seg);
        },
        unrenderEventResize: function() {
          this.unrenderHelper();
        },
        renderHelper: function(event, sourceSeg) {
          var segs = this.eventToSegs(event);
          var tableEl;
          var i,
              seg;
          var sourceEl;
          segs = this.renderFgSegEls(segs);
          tableEl = this.renderSegTable(segs);
          for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (sourceSeg && sourceSeg.col === seg.col) {
              sourceEl = sourceSeg.el;
              seg.el.css({
                left: sourceEl.css('left'),
                right: sourceEl.css('right'),
                'margin-left': sourceEl.css('margin-left'),
                'margin-right': sourceEl.css('margin-right')
              });
            }
          }
          this.helperEl = $('<div class="fc-helper-skeleton"/>').append(tableEl).appendTo(this.el);
        },
        unrenderHelper: function() {
          if (this.helperEl) {
            this.helperEl.remove();
            this.helperEl = null;
          }
        },
        renderSelection: function(span) {
          if (this.view.opt('selectHelper')) {
            this.renderEventLocationHelper(span);
          } else {
            this.renderHighlight(span);
          }
        },
        unrenderSelection: function() {
          this.unrenderHelper();
          this.unrenderHighlight();
        },
        renderFill: function(type, segs, className) {
          var segCols;
          var skeletonEl;
          var trEl;
          var col,
              colSegs;
          var tdEl;
          var containerEl;
          var dayDate;
          var i,
              seg;
          if (segs.length) {
            segs = this.renderFillSegEls(type, segs);
            segCols = this.groupSegCols(segs);
            className = className || type.toLowerCase();
            skeletonEl = $('<div class="fc-' + className + '-skeleton">' + '<table><tr/></table>' + '</div>');
            trEl = skeletonEl.find('tr');
            for (col = 0; col < segCols.length; col++) {
              colSegs = segCols[col];
              tdEl = $('<td/>').appendTo(trEl);
              if (colSegs.length) {
                containerEl = $('<div class="fc-' + className + '-container"/>').appendTo(tdEl);
                dayDate = this.getCellDate(0, col);
                for (i = 0; i < colSegs.length; i++) {
                  seg = colSegs[i];
                  containerEl.append(seg.el.css({
                    top: this.computeDateTop(seg.start, dayDate),
                    bottom: -this.computeDateTop(seg.end, dayDate)
                  }));
                }
              }
            }
            this.bookendCells(trEl);
            this.el.append(skeletonEl);
            this.elsByFill[type] = skeletonEl;
          }
          return segs;
        }
      });
      ;
      ;
      TimeGrid.mixin({
        eventSkeletonEl: null,
        renderFgSegs: function(segs) {
          segs = this.renderFgSegEls(segs);
          this.el.append(this.eventSkeletonEl = $('<div class="fc-content-skeleton"/>').append(this.renderSegTable(segs)));
          return segs;
        },
        unrenderFgSegs: function(segs) {
          if (this.eventSkeletonEl) {
            this.eventSkeletonEl.remove();
            this.eventSkeletonEl = null;
          }
        },
        renderSegTable: function(segs) {
          var tableEl = $('<table><tr/></table>');
          var trEl = tableEl.find('tr');
          var segCols;
          var i,
              seg;
          var col,
              colSegs;
          var containerEl;
          segCols = this.groupSegCols(segs);
          this.computeSegVerticals(segs);
          for (col = 0; col < segCols.length; col++) {
            colSegs = segCols[col];
            this.placeSlotSegs(colSegs);
            containerEl = $('<div class="fc-event-container"/>');
            for (i = 0; i < colSegs.length; i++) {
              seg = colSegs[i];
              seg.el.css(this.generateSegPositionCss(seg));
              if (seg.bottom - seg.top < 30) {
                seg.el.addClass('fc-short');
              }
              containerEl.append(seg.el);
            }
            trEl.append($('<td/>').append(containerEl));
          }
          this.bookendCells(trEl);
          return tableEl;
        },
        placeSlotSegs: function(segs) {
          var levels;
          var level0;
          var i;
          this.sortEventSegs(segs);
          levels = buildSlotSegLevels(segs);
          computeForwardSlotSegs(levels);
          if ((level0 = levels[0])) {
            for (i = 0; i < level0.length; i++) {
              computeSlotSegPressures(level0[i]);
            }
            for (i = 0; i < level0.length; i++) {
              this.computeSlotSegCoords(level0[i], 0, 0);
            }
          }
        },
        computeSlotSegCoords: function(seg, seriesBackwardPressure, seriesBackwardCoord) {
          var forwardSegs = seg.forwardSegs;
          var i;
          if (seg.forwardCoord === undefined) {
            if (!forwardSegs.length) {
              seg.forwardCoord = 1;
            } else {
              this.sortForwardSlotSegs(forwardSegs);
              this.computeSlotSegCoords(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
              seg.forwardCoord = forwardSegs[0].backwardCoord;
            }
            seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / (seriesBackwardPressure + 1);
            for (i = 0; i < forwardSegs.length; i++) {
              this.computeSlotSegCoords(forwardSegs[i], 0, seg.forwardCoord);
            }
          }
        },
        updateSegVerticals: function() {
          var allSegs = (this.segs || []).concat(this.businessHourSegs || []);
          var i;
          this.computeSegVerticals(allSegs);
          for (i = 0; i < allSegs.length; i++) {
            allSegs[i].el.css(this.generateSegVerticalCss(allSegs[i]));
          }
        },
        computeSegVerticals: function(segs) {
          var i,
              seg;
          for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.top = this.computeDateTop(seg.start, seg.start);
            seg.bottom = this.computeDateTop(seg.end, seg.start);
          }
        },
        fgSegHtml: function(seg, disableResizing) {
          var view = this.view;
          var event = seg.event;
          var isDraggable = view.isEventDraggable(event);
          var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
          var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
          var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
          var skinCss = cssToStr(this.getEventSkinCss(event));
          var timeText;
          var fullTimeText;
          var startTimeText;
          classes.unshift('fc-time-grid-event', 'fc-v-event');
          if (view.isMultiDayEvent(event)) {
            if (seg.isStart || seg.isEnd) {
              timeText = this.getEventTimeText(seg);
              fullTimeText = this.getEventTimeText(seg, 'LT');
              startTimeText = this.getEventTimeText(seg, null, false);
            }
          } else {
            timeText = this.getEventTimeText(event);
            fullTimeText = this.getEventTimeText(event, 'LT');
            startTimeText = this.getEventTimeText(event, null, false);
          }
          return '<a class="' + classes.join(' ') + '"' + (event.url ? ' href="' + htmlEscape(event.url) + '"' : '') + (skinCss ? ' style="' + skinCss + '"' : '') + '>' + '<div class="fc-content">' + (timeText ? '<div class="fc-time"' + ' data-start="' + htmlEscape(startTimeText) + '"' + ' data-full="' + htmlEscape(fullTimeText) + '"' + '>' + '<span>' + htmlEscape(timeText) + '</span>' + '</div>' : '') + (event.title ? '<div class="fc-title">' + htmlEscape(event.title) + '</div>' : '') + '</div>' + '<div class="fc-bg"/>' + (isResizableFromEnd ? '<div class="fc-resizer fc-end-resizer" />' : '') + '</a>';
        },
        generateSegPositionCss: function(seg) {
          var shouldOverlap = this.view.opt('slotEventOverlap');
          var backwardCoord = seg.backwardCoord;
          var forwardCoord = seg.forwardCoord;
          var props = this.generateSegVerticalCss(seg);
          var left;
          var right;
          if (shouldOverlap) {
            forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
          }
          if (this.isRTL) {
            left = 1 - forwardCoord;
            right = backwardCoord;
          } else {
            left = backwardCoord;
            right = 1 - forwardCoord;
          }
          props.zIndex = seg.level + 1;
          props.left = left * 100 + '%';
          props.right = right * 100 + '%';
          if (shouldOverlap && seg.forwardPressure) {
            props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2;
          }
          return props;
        },
        generateSegVerticalCss: function(seg) {
          return {
            top: seg.top,
            bottom: -seg.bottom
          };
        },
        groupSegCols: function(segs) {
          var segCols = [];
          var i;
          for (i = 0; i < this.colCnt; i++) {
            segCols.push([]);
          }
          for (i = 0; i < segs.length; i++) {
            segCols[segs[i].col].push(segs[i]);
          }
          return segCols;
        },
        sortForwardSlotSegs: function(forwardSegs) {
          forwardSegs.sort(proxy(this, 'compareForwardSlotSegs'));
        },
        compareForwardSlotSegs: function(seg1, seg2) {
          return seg2.forwardPressure - seg1.forwardPressure || (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) || this.compareEventSegs(seg1, seg2);
        }
      });
      function buildSlotSegLevels(segs) {
        var levels = [];
        var i,
            seg;
        var j;
        for (i = 0; i < segs.length; i++) {
          seg = segs[i];
          for (j = 0; j < levels.length; j++) {
            if (!computeSlotSegCollisions(seg, levels[j]).length) {
              break;
            }
          }
          seg.level = j;
          (levels[j] || (levels[j] = [])).push(seg);
        }
        return levels;
      }
      function computeForwardSlotSegs(levels) {
        var i,
            level;
        var j,
            seg;
        var k;
        for (i = 0; i < levels.length; i++) {
          level = levels[i];
          for (j = 0; j < level.length; j++) {
            seg = level[j];
            seg.forwardSegs = [];
            for (k = i + 1; k < levels.length; k++) {
              computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
            }
          }
        }
      }
      function computeSlotSegPressures(seg) {
        var forwardSegs = seg.forwardSegs;
        var forwardPressure = 0;
        var i,
            forwardSeg;
        if (seg.forwardPressure === undefined) {
          for (i = 0; i < forwardSegs.length; i++) {
            forwardSeg = forwardSegs[i];
            computeSlotSegPressures(forwardSeg);
            forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
          }
          seg.forwardPressure = forwardPressure;
        }
      }
      function computeSlotSegCollisions(seg, otherSegs, results) {
        results = results || [];
        for (var i = 0; i < otherSegs.length; i++) {
          if (isSlotSegCollision(seg, otherSegs[i])) {
            results.push(otherSegs[i]);
          }
        }
        return results;
      }
      function isSlotSegCollision(seg1, seg2) {
        return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
      }
      ;
      ;
      var View = FC.View = Class.extend({
        type: null,
        name: null,
        title: null,
        calendar: null,
        options: null,
        el: null,
        displaying: null,
        isSkeletonRendered: false,
        isEventsRendered: false,
        start: null,
        end: null,
        intervalStart: null,
        intervalEnd: null,
        intervalDuration: null,
        intervalUnit: null,
        isRTL: false,
        isSelected: false,
        eventOrderSpecs: null,
        scrollerEl: null,
        scrollTop: null,
        widgetHeaderClass: null,
        widgetContentClass: null,
        highlightStateClass: null,
        nextDayThreshold: null,
        isHiddenDayHash: null,
        documentMousedownProxy: null,
        constructor: function(calendar, type, options, intervalDuration) {
          this.calendar = calendar;
          this.type = this.name = type;
          this.options = options;
          this.intervalDuration = intervalDuration || moment.duration(1, 'day');
          this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
          this.initThemingProps();
          this.initHiddenDays();
          this.isRTL = this.opt('isRTL');
          this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));
          this.documentMousedownProxy = proxy(this, 'documentMousedown');
          this.initialize();
        },
        initialize: function() {},
        opt: function(name) {
          return this.options[name];
        },
        trigger: function(name, thisObj) {
          var calendar = this.calendar;
          return calendar.trigger.apply(calendar, [name, thisObj || this].concat(Array.prototype.slice.call(arguments, 2), [this]));
        },
        setDate: function(date) {
          this.setRange(this.computeRange(date));
        },
        setRange: function(range) {
          $.extend(this, range);
          this.updateTitle();
        },
        computeRange: function(date) {
          var intervalUnit = computeIntervalUnit(this.intervalDuration);
          var intervalStart = date.clone().startOf(intervalUnit);
          var intervalEnd = intervalStart.clone().add(this.intervalDuration);
          var start,
              end;
          if (/year|month|week|day/.test(intervalUnit)) {
            intervalStart.stripTime();
            intervalEnd.stripTime();
          } else {
            if (!intervalStart.hasTime()) {
              intervalStart = this.calendar.time(0);
            }
            if (!intervalEnd.hasTime()) {
              intervalEnd = this.calendar.time(0);
            }
          }
          start = intervalStart.clone();
          start = this.skipHiddenDays(start);
          end = intervalEnd.clone();
          end = this.skipHiddenDays(end, -1, true);
          return {
            intervalUnit: intervalUnit,
            intervalStart: intervalStart,
            intervalEnd: intervalEnd,
            start: start,
            end: end
          };
        },
        computePrevDate: function(date) {
          return this.massageCurrentDate(date.clone().startOf(this.intervalUnit).subtract(this.intervalDuration), -1);
        },
        computeNextDate: function(date) {
          return this.massageCurrentDate(date.clone().startOf(this.intervalUnit).add(this.intervalDuration));
        },
        massageCurrentDate: function(date, direction) {
          if (this.intervalDuration.as('days') <= 1) {
            if (this.isHiddenDay(date)) {
              date = this.skipHiddenDays(date, direction);
              date.startOf('day');
            }
          }
          return date;
        },
        updateTitle: function() {
          this.title = this.computeTitle();
        },
        computeTitle: function() {
          return this.formatRange({
            start: this.calendar.applyTimezone(this.intervalStart),
            end: this.calendar.applyTimezone(this.intervalEnd)
          }, this.opt('titleFormat') || this.computeTitleFormat(), this.opt('titleRangeSeparator'));
        },
        computeTitleFormat: function() {
          if (this.intervalUnit == 'year') {
            return 'YYYY';
          } else if (this.intervalUnit == 'month') {
            return this.opt('monthYearFormat');
          } else if (this.intervalDuration.as('days') > 1) {
            return 'll';
          } else {
            return 'LL';
          }
        },
        formatRange: function(range, formatStr, separator) {
          var end = range.end;
          if (!end.hasTime()) {
            end = end.clone().subtract(1);
          }
          return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
        },
        setElement: function(el) {
          this.el = el;
          this.bindGlobalHandlers();
        },
        removeElement: function() {
          this.clear();
          if (this.isSkeletonRendered) {
            this.unrenderSkeleton();
            this.isSkeletonRendered = false;
          }
          this.unbindGlobalHandlers();
          this.el.remove();
        },
        display: function(date) {
          var _this = this;
          var scrollState = null;
          if (this.displaying) {
            scrollState = this.queryScroll();
          }
          this.calendar.freezeContentHeight();
          return this.clear().then(function() {
            return (_this.displaying = $.when(_this.displayView(date)).then(function() {
              _this.forceScroll(_this.computeInitialScroll(scrollState));
              _this.calendar.unfreezeContentHeight();
              _this.triggerRender();
            }));
          });
        },
        clear: function() {
          var _this = this;
          var displaying = this.displaying;
          if (displaying) {
            return displaying.then(function() {
              _this.displaying = null;
              _this.clearEvents();
              return _this.clearView();
            });
          } else {
            return $.when();
          }
        },
        redisplay: function() {
          if (this.isSkeletonRendered) {
            var wasEventsRendered = this.isEventsRendered;
            this.clearEvents();
            this.clearView();
            this.displayView();
            if (wasEventsRendered) {
              this.displayEvents();
            }
          }
        },
        displayView: function(date) {
          if (!this.isSkeletonRendered) {
            this.renderSkeleton();
            this.isSkeletonRendered = true;
          }
          if (date) {
            this.setDate(date);
          }
          if (this.render) {
            this.render();
          }
          this.renderDates();
          this.updateSize();
          this.renderBusinessHours();
        },
        clearView: function() {
          this.unselect();
          this.triggerUnrender();
          this.unrenderBusinessHours();
          this.unrenderDates();
          if (this.destroy) {
            this.destroy();
          }
        },
        renderSkeleton: function() {},
        unrenderSkeleton: function() {},
        renderDates: function() {},
        unrenderDates: function() {},
        renderBusinessHours: function() {},
        unrenderBusinessHours: function() {},
        triggerRender: function() {
          this.trigger('viewRender', this, this, this.el);
        },
        triggerUnrender: function() {
          this.trigger('viewDestroy', this, this, this.el);
        },
        bindGlobalHandlers: function() {
          $(document).on('mousedown', this.documentMousedownProxy);
        },
        unbindGlobalHandlers: function() {
          $(document).off('mousedown', this.documentMousedownProxy);
        },
        initThemingProps: function() {
          var tm = this.opt('theme') ? 'ui' : 'fc';
          this.widgetHeaderClass = tm + '-widget-header';
          this.widgetContentClass = tm + '-widget-content';
          this.highlightStateClass = tm + '-state-highlight';
        },
        updateSize: function(isResize) {
          var scrollState;
          if (isResize) {
            scrollState = this.queryScroll();
          }
          this.updateHeight(isResize);
          this.updateWidth(isResize);
          if (isResize) {
            this.setScroll(scrollState);
          }
        },
        updateWidth: function(isResize) {},
        updateHeight: function(isResize) {
          var calendar = this.calendar;
          this.setHeight(calendar.getSuggestedViewHeight(), calendar.isHeightAuto());
        },
        setHeight: function(height, isAuto) {},
        computeScrollerHeight: function(totalHeight) {
          var scrollerEl = this.scrollerEl;
          var both;
          var otherHeight;
          both = this.el.add(scrollerEl);
          both.css({
            position: 'relative',
            left: -1
          });
          otherHeight = this.el.outerHeight() - scrollerEl.height();
          both.css({
            position: '',
            left: ''
          });
          return totalHeight - otherHeight;
        },
        computeInitialScroll: function(previousScrollState) {
          return 0;
        },
        queryScroll: function() {
          if (this.scrollerEl) {
            return this.scrollerEl.scrollTop();
          }
        },
        setScroll: function(scrollState) {
          if (this.scrollerEl) {
            return this.scrollerEl.scrollTop(scrollState);
          }
        },
        forceScroll: function(scrollState) {
          var _this = this;
          this.setScroll(scrollState);
          setTimeout(function() {
            _this.setScroll(scrollState);
          }, 0);
        },
        displayEvents: function(events) {
          var scrollState = this.queryScroll();
          this.clearEvents();
          this.renderEvents(events);
          this.isEventsRendered = true;
          this.setScroll(scrollState);
          this.triggerEventRender();
        },
        clearEvents: function() {
          if (this.isEventsRendered) {
            this.triggerEventUnrender();
            if (this.destroyEvents) {
              this.destroyEvents();
            }
            this.unrenderEvents();
            this.isEventsRendered = false;
          }
        },
        renderEvents: function(events) {},
        unrenderEvents: function() {},
        triggerEventRender: function() {
          this.renderedEventSegEach(function(seg) {
            this.trigger('eventAfterRender', seg.event, seg.event, seg.el);
          });
          this.trigger('eventAfterAllRender');
        },
        triggerEventUnrender: function() {
          this.renderedEventSegEach(function(seg) {
            this.trigger('eventDestroy', seg.event, seg.event, seg.el);
          });
        },
        resolveEventEl: function(event, el) {
          var custom = this.trigger('eventRender', event, event, el);
          if (custom === false) {
            el = null;
          } else if (custom && custom !== true) {
            el = $(custom);
          }
          return el;
        },
        showEvent: function(event) {
          this.renderedEventSegEach(function(seg) {
            seg.el.css('visibility', '');
          }, event);
        },
        hideEvent: function(event) {
          this.renderedEventSegEach(function(seg) {
            seg.el.css('visibility', 'hidden');
          }, event);
        },
        renderedEventSegEach: function(func, event) {
          var segs = this.getEventSegs();
          var i;
          for (i = 0; i < segs.length; i++) {
            if (!event || segs[i].event._id === event._id) {
              if (segs[i].el) {
                func.call(this, segs[i]);
              }
            }
          }
        },
        getEventSegs: function() {
          return [];
        },
        isEventDraggable: function(event) {
          var source = event.source || {};
          return firstDefined(event.startEditable, source.startEditable, this.opt('eventStartEditable'), event.editable, source.editable, this.opt('editable'));
        },
        reportEventDrop: function(event, dropLocation, largeUnit, el, ev) {
          var calendar = this.calendar;
          var mutateResult = calendar.mutateEvent(event, dropLocation, largeUnit);
          var undoFunc = function() {
            mutateResult.undo();
            calendar.reportEventChange();
          };
          this.triggerEventDrop(event, mutateResult.dateDelta, undoFunc, el, ev);
          calendar.reportEventChange();
        },
        triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {
          this.trigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {});
        },
        reportExternalDrop: function(meta, dropLocation, el, ev, ui) {
          var eventProps = meta.eventProps;
          var eventInput;
          var event;
          if (eventProps) {
            eventInput = $.extend({}, eventProps, dropLocation);
            event = this.calendar.renderEvent(eventInput, meta.stick)[0];
          }
          this.triggerExternalDrop(event, dropLocation, el, ev, ui);
        },
        triggerExternalDrop: function(event, dropLocation, el, ev, ui) {
          this.trigger('drop', el[0], dropLocation.start, ev, ui);
          if (event) {
            this.trigger('eventReceive', null, event);
          }
        },
        renderDrag: function(dropLocation, seg) {},
        unrenderDrag: function() {},
        isEventResizableFromStart: function(event) {
          return this.opt('eventResizableFromStart') && this.isEventResizable(event);
        },
        isEventResizableFromEnd: function(event) {
          return this.isEventResizable(event);
        },
        isEventResizable: function(event) {
          var source = event.source || {};
          return firstDefined(event.durationEditable, source.durationEditable, this.opt('eventDurationEditable'), event.editable, source.editable, this.opt('editable'));
        },
        reportEventResize: function(event, resizeLocation, largeUnit, el, ev) {
          var calendar = this.calendar;
          var mutateResult = calendar.mutateEvent(event, resizeLocation, largeUnit);
          var undoFunc = function() {
            mutateResult.undo();
            calendar.reportEventChange();
          };
          this.triggerEventResize(event, mutateResult.durationDelta, undoFunc, el, ev);
          calendar.reportEventChange();
        },
        triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {
          this.trigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {});
        },
        select: function(span, ev) {
          this.unselect(ev);
          this.renderSelection(span);
          this.reportSelection(span, ev);
        },
        renderSelection: function(span) {},
        reportSelection: function(span, ev) {
          this.isSelected = true;
          this.triggerSelect(span, ev);
        },
        triggerSelect: function(span, ev) {
          this.trigger('select', null, this.calendar.applyTimezone(span.start), this.calendar.applyTimezone(span.end), ev);
        },
        unselect: function(ev) {
          if (this.isSelected) {
            this.isSelected = false;
            if (this.destroySelection) {
              this.destroySelection();
            }
            this.unrenderSelection();
            this.trigger('unselect', null, ev);
          }
        },
        unrenderSelection: function() {},
        documentMousedown: function(ev) {
          var ignore;
          if (this.isSelected && this.opt('unselectAuto') && isPrimaryMouseButton(ev)) {
            ignore = this.opt('unselectCancel');
            if (!ignore || !$(ev.target).closest(ignore).length) {
              this.unselect(ev);
            }
          }
        },
        triggerDayClick: function(span, dayEl, ev) {
          this.trigger('dayClick', dayEl, this.calendar.applyTimezone(span.start), ev);
        },
        initHiddenDays: function() {
          var hiddenDays = this.opt('hiddenDays') || [];
          var isHiddenDayHash = [];
          var dayCnt = 0;
          var i;
          if (this.opt('weekends') === false) {
            hiddenDays.push(0, 6);
          }
          for (i = 0; i < 7; i++) {
            if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {
              dayCnt++;
            }
          }
          if (!dayCnt) {
            throw 'invalid hiddenDays';
          }
          this.isHiddenDayHash = isHiddenDayHash;
        },
        isHiddenDay: function(day) {
          if (moment.isMoment(day)) {
            day = day.day();
          }
          return this.isHiddenDayHash[day];
        },
        skipHiddenDays: function(date, inc, isExclusive) {
          var out = date.clone();
          inc = inc || 1;
          while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {
            out.add(inc, 'days');
          }
          return out;
        },
        computeDayRange: function(range) {
          var startDay = range.start.clone().stripTime();
          var end = range.end;
          var endDay = null;
          var endTimeMS;
          if (end) {
            endDay = end.clone().stripTime();
            endTimeMS = +end.time();
            if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
              endDay.add(1, 'days');
            }
          }
          if (!end || endDay <= startDay) {
            endDay = startDay.clone().add(1, 'days');
          }
          return {
            start: startDay,
            end: endDay
          };
        },
        isMultiDayEvent: function(event) {
          var range = this.computeDayRange(event);
          return range.end.diff(range.start, 'days') > 1;
        }
      });
      ;
      ;
      var Calendar = FC.Calendar = Class.extend({
        dirDefaults: null,
        langDefaults: null,
        overrides: null,
        options: null,
        viewSpecCache: null,
        view: null,
        header: null,
        loadingLevel: 0,
        constructor: Calendar_constructor,
        initialize: function() {},
        initOptions: function(overrides) {
          var lang,
              langDefaults;
          var isRTL,
              dirDefaults;
          overrides = massageOverrides(overrides);
          lang = overrides.lang;
          langDefaults = langOptionHash[lang];
          if (!langDefaults) {
            lang = Calendar.defaults.lang;
            langDefaults = langOptionHash[lang] || {};
          }
          isRTL = firstDefined(overrides.isRTL, langDefaults.isRTL, Calendar.defaults.isRTL);
          dirDefaults = isRTL ? Calendar.rtlDefaults : {};
          this.dirDefaults = dirDefaults;
          this.langDefaults = langDefaults;
          this.overrides = overrides;
          this.options = mergeOptions([Calendar.defaults, dirDefaults, langDefaults, overrides]);
          populateInstanceComputableOptions(this.options);
          this.viewSpecCache = {};
        },
        getViewSpec: function(viewType) {
          var cache = this.viewSpecCache;
          return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
        },
        getUnitViewSpec: function(unit) {
          var viewTypes;
          var i;
          var spec;
          if ($.inArray(unit, intervalUnits) != -1) {
            viewTypes = this.header.getViewsWithButtons();
            $.each(FC.views, function(viewType) {
              viewTypes.push(viewType);
            });
            for (i = 0; i < viewTypes.length; i++) {
              spec = this.getViewSpec(viewTypes[i]);
              if (spec) {
                if (spec.singleUnit == unit) {
                  return spec;
                }
              }
            }
          }
        },
        buildViewSpec: function(requestedViewType) {
          var viewOverrides = this.overrides.views || {};
          var specChain = [];
          var defaultsChain = [];
          var overridesChain = [];
          var viewType = requestedViewType;
          var spec;
          var overrides;
          var duration;
          var unit;
          while (viewType) {
            spec = fcViews[viewType];
            overrides = viewOverrides[viewType];
            viewType = null;
            if (typeof spec === 'function') {
              spec = {'class': spec};
            }
            if (spec) {
              specChain.unshift(spec);
              defaultsChain.unshift(spec.defaults || {});
              duration = duration || spec.duration;
              viewType = viewType || spec.type;
            }
            if (overrides) {
              overridesChain.unshift(overrides);
              duration = duration || overrides.duration;
              viewType = viewType || overrides.type;
            }
          }
          spec = mergeProps(specChain);
          spec.type = requestedViewType;
          if (!spec['class']) {
            return false;
          }
          if (duration) {
            duration = moment.duration(duration);
            if (duration.valueOf()) {
              spec.duration = duration;
              unit = computeIntervalUnit(duration);
              if (duration.as(unit) === 1) {
                spec.singleUnit = unit;
                overridesChain.unshift(viewOverrides[unit] || {});
              }
            }
          }
          spec.defaults = mergeOptions(defaultsChain);
          spec.overrides = mergeOptions(overridesChain);
          this.buildViewSpecOptions(spec);
          this.buildViewSpecButtonText(spec, requestedViewType);
          return spec;
        },
        buildViewSpecOptions: function(spec) {
          spec.options = mergeOptions([Calendar.defaults, spec.defaults, this.dirDefaults, this.langDefaults, this.overrides, spec.overrides]);
          populateInstanceComputableOptions(spec.options);
        },
        buildViewSpecButtonText: function(spec, requestedViewType) {
          function queryButtonText(options) {
            var buttonText = options.buttonText || {};
            return buttonText[requestedViewType] || (spec.singleUnit ? buttonText[spec.singleUnit] : null);
          }
          spec.buttonTextOverride = queryButtonText(this.overrides) || spec.overrides.buttonText;
          spec.buttonTextDefault = queryButtonText(this.langDefaults) || queryButtonText(this.dirDefaults) || spec.defaults.buttonText || queryButtonText(Calendar.defaults) || (spec.duration ? this.humanizeDuration(spec.duration) : null) || requestedViewType;
        },
        instantiateView: function(viewType) {
          var spec = this.getViewSpec(viewType);
          return new spec['class'](this, viewType, spec.options, spec.duration);
        },
        isValidViewType: function(viewType) {
          return Boolean(this.getViewSpec(viewType));
        },
        pushLoading: function() {
          if (!(this.loadingLevel++)) {
            this.trigger('loading', null, true, this.view);
          }
        },
        popLoading: function() {
          if (!(--this.loadingLevel)) {
            this.trigger('loading', null, false, this.view);
          }
        },
        buildSelectSpan: function(zonedStartInput, zonedEndInput) {
          var start = this.moment(zonedStartInput).stripZone();
          var end;
          if (zonedEndInput) {
            end = this.moment(zonedEndInput).stripZone();
          } else if (start.hasTime()) {
            end = start.clone().add(this.defaultTimedEventDuration);
          } else {
            end = start.clone().add(this.defaultAllDayEventDuration);
          }
          return {
            start: start,
            end: end
          };
        }
      });
      Calendar.mixin(Emitter);
      function Calendar_constructor(element, overrides) {
        var t = this;
        t.initOptions(overrides || {});
        var options = this.options;
        t.render = render;
        t.destroy = destroy;
        t.refetchEvents = refetchEvents;
        t.reportEvents = reportEvents;
        t.reportEventChange = reportEventChange;
        t.rerenderEvents = renderEvents;
        t.changeView = renderView;
        t.select = select;
        t.unselect = unselect;
        t.prev = prev;
        t.next = next;
        t.prevYear = prevYear;
        t.nextYear = nextYear;
        t.today = today;
        t.gotoDate = gotoDate;
        t.incrementDate = incrementDate;
        t.zoomTo = zoomTo;
        t.getDate = getDate;
        t.getCalendar = getCalendar;
        t.getView = getView;
        t.option = option;
        t.trigger = trigger;
        var localeData = createObject(getMomentLocaleData(options.lang));
        if (options.monthNames) {
          localeData._months = options.monthNames;
        }
        if (options.monthNamesShort) {
          localeData._monthsShort = options.monthNamesShort;
        }
        if (options.dayNames) {
          localeData._weekdays = options.dayNames;
        }
        if (options.dayNamesShort) {
          localeData._weekdaysShort = options.dayNamesShort;
        }
        if (options.firstDay != null) {
          var _week = createObject(localeData._week);
          _week.dow = options.firstDay;
          localeData._week = _week;
        }
        localeData._fullCalendar_weekCalc = (function(weekCalc) {
          if (typeof weekCalc === 'function') {
            return weekCalc;
          } else if (weekCalc === 'local') {
            return weekCalc;
          } else if (weekCalc === 'iso' || weekCalc === 'ISO') {
            return 'ISO';
          }
        })(options.weekNumberCalculation);
        t.defaultAllDayEventDuration = moment.duration(options.defaultAllDayEventDuration);
        t.defaultTimedEventDuration = moment.duration(options.defaultTimedEventDuration);
        t.moment = function() {
          var mom;
          if (options.timezone === 'local') {
            mom = FC.moment.apply(null, arguments);
            if (mom.hasTime()) {
              mom.local();
            }
          } else if (options.timezone === 'UTC') {
            mom = FC.moment.utc.apply(null, arguments);
          } else {
            mom = FC.moment.parseZone.apply(null, arguments);
          }
          if ('_locale' in mom) {
            mom._locale = localeData;
          } else {
            mom._lang = localeData;
          }
          return mom;
        };
        t.getIsAmbigTimezone = function() {
          return options.timezone !== 'local' && options.timezone !== 'UTC';
        };
        t.applyTimezone = function(date) {
          if (!date.hasTime()) {
            return date.clone();
          }
          var zonedDate = t.moment(date.toArray());
          var timeAdjust = date.time() - zonedDate.time();
          var adjustedZonedDate;
          if (timeAdjust) {
            adjustedZonedDate = zonedDate.clone().add(timeAdjust);
            if (date.time() - adjustedZonedDate.time() === 0) {
              zonedDate = adjustedZonedDate;
            }
          }
          return zonedDate;
        };
        t.getNow = function() {
          var now = options.now;
          if (typeof now === 'function') {
            now = now();
          }
          return t.moment(now).stripZone();
        };
        t.getEventEnd = function(event) {
          if (event.end) {
            return event.end.clone();
          } else {
            return t.getDefaultEventEnd(event.allDay, event.start);
          }
        };
        t.getDefaultEventEnd = function(allDay, zonedStart) {
          var end = zonedStart.clone();
          if (allDay) {
            end.stripTime().add(t.defaultAllDayEventDuration);
          } else {
            end.add(t.defaultTimedEventDuration);
          }
          if (t.getIsAmbigTimezone()) {
            end.stripZone();
          }
          return end;
        };
        t.humanizeDuration = function(duration) {
          return (duration.locale || duration.lang).call(duration, options.lang).humanize();
        };
        EventManager.call(t, options);
        var isFetchNeeded = t.isFetchNeeded;
        var fetchEvents = t.fetchEvents;
        var _element = element[0];
        var header;
        var headerElement;
        var content;
        var tm;
        var currentView;
        var viewsByType = {};
        var suggestedViewHeight;
        var windowResizeProxy;
        var ignoreWindowResize = 0;
        var events = [];
        var date;
        if (options.defaultDate != null) {
          date = t.moment(options.defaultDate).stripZone();
        } else {
          date = t.getNow();
        }
        function render() {
          if (!content) {
            initialRender();
          } else if (elementVisible()) {
            calcSize();
            renderView();
          }
        }
        function initialRender() {
          tm = options.theme ? 'ui' : 'fc';
          element.addClass('fc');
          if (options.isRTL) {
            element.addClass('fc-rtl');
          } else {
            element.addClass('fc-ltr');
          }
          if (options.theme) {
            element.addClass('ui-widget');
          } else {
            element.addClass('fc-unthemed');
          }
          content = $("<div class='fc-view-container'/>").prependTo(element);
          header = t.header = new Header(t, options);
          headerElement = header.render();
          if (headerElement) {
            element.prepend(headerElement);
          }
          renderView(options.defaultView);
          if (options.handleWindowResize) {
            windowResizeProxy = debounce(windowResize, options.windowResizeDelay);
            $(window).resize(windowResizeProxy);
          }
        }
        function destroy() {
          if (currentView) {
            currentView.removeElement();
          }
          header.removeElement();
          content.remove();
          element.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');
          if (windowResizeProxy) {
            $(window).unbind('resize', windowResizeProxy);
          }
        }
        function elementVisible() {
          return element.is(':visible');
        }
        function renderView(viewType) {
          ignoreWindowResize++;
          if (currentView && viewType && currentView.type !== viewType) {
            header.deactivateButton(currentView.type);
            freezeContentHeight();
            currentView.removeElement();
            currentView = t.view = null;
          }
          if (!currentView && viewType) {
            currentView = t.view = viewsByType[viewType] || (viewsByType[viewType] = t.instantiateView(viewType));
            currentView.setElement($("<div class='fc-view fc-" + viewType + "-view' />").appendTo(content));
            header.activateButton(viewType);
          }
          if (currentView) {
            date = currentView.massageCurrentDate(date);
            if (!currentView.displaying || !date.isWithin(currentView.intervalStart, currentView.intervalEnd)) {
              if (elementVisible()) {
                currentView.display(date);
                unfreezeContentHeight();
                updateHeaderTitle();
                updateTodayButton();
                getAndRenderEvents();
              }
            }
          }
          unfreezeContentHeight();
          ignoreWindowResize--;
        }
        t.getSuggestedViewHeight = function() {
          if (suggestedViewHeight === undefined) {
            calcSize();
          }
          return suggestedViewHeight;
        };
        t.isHeightAuto = function() {
          return options.contentHeight === 'auto' || options.height === 'auto';
        };
        function updateSize(shouldRecalc) {
          if (elementVisible()) {
            if (shouldRecalc) {
              _calcSize();
            }
            ignoreWindowResize++;
            currentView.updateSize(true);
            ignoreWindowResize--;
            return true;
          }
        }
        function calcSize() {
          if (elementVisible()) {
            _calcSize();
          }
        }
        function _calcSize() {
          if (typeof options.contentHeight === 'number') {
            suggestedViewHeight = options.contentHeight;
          } else if (typeof options.height === 'number') {
            suggestedViewHeight = options.height - (headerElement ? headerElement.outerHeight(true) : 0);
          } else {
            suggestedViewHeight = Math.round(content.width() / Math.max(options.aspectRatio, .5));
          }
        }
        function windowResize(ev) {
          if (!ignoreWindowResize && ev.target === window && currentView.start) {
            if (updateSize(true)) {
              currentView.trigger('windowResize', _element);
            }
          }
        }
        function refetchEvents() {
          destroyEvents();
          fetchAndRenderEvents();
        }
        function renderEvents() {
          if (elementVisible()) {
            freezeContentHeight();
            currentView.displayEvents(events);
            unfreezeContentHeight();
          }
        }
        function destroyEvents() {
          freezeContentHeight();
          currentView.clearEvents();
          unfreezeContentHeight();
        }
        function getAndRenderEvents() {
          if (!options.lazyFetching || isFetchNeeded(currentView.start, currentView.end)) {
            fetchAndRenderEvents();
          } else {
            renderEvents();
          }
        }
        function fetchAndRenderEvents() {
          fetchEvents(currentView.start, currentView.end);
        }
        function reportEvents(_events) {
          events = _events;
          renderEvents();
        }
        function reportEventChange() {
          renderEvents();
        }
        function updateHeaderTitle() {
          header.updateTitle(currentView.title);
        }
        function updateTodayButton() {
          var now = t.getNow();
          if (now.isWithin(currentView.intervalStart, currentView.intervalEnd)) {
            header.disableButton('today');
          } else {
            header.enableButton('today');
          }
        }
        function select(zonedStartInput, zonedEndInput) {
          currentView.select(t.buildSelectSpan.apply(t, arguments));
        }
        function unselect() {
          if (currentView) {
            currentView.unselect();
          }
        }
        function prev() {
          date = currentView.computePrevDate(date);
          renderView();
        }
        function next() {
          date = currentView.computeNextDate(date);
          renderView();
        }
        function prevYear() {
          date.add(-1, 'years');
          renderView();
        }
        function nextYear() {
          date.add(1, 'years');
          renderView();
        }
        function today() {
          date = t.getNow();
          renderView();
        }
        function gotoDate(zonedDateInput) {
          date = t.moment(zonedDateInput).stripZone();
          renderView();
        }
        function incrementDate(delta) {
          date.add(moment.duration(delta));
          renderView();
        }
        function zoomTo(newDate, viewType) {
          var spec;
          viewType = viewType || 'day';
          spec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);
          date = newDate.clone();
          renderView(spec ? spec.type : null);
        }
        function getDate() {
          return t.applyTimezone(date);
        }
        t.freezeContentHeight = freezeContentHeight;
        t.unfreezeContentHeight = unfreezeContentHeight;
        function freezeContentHeight() {
          content.css({
            width: '100%',
            height: content.height(),
            overflow: 'hidden'
          });
        }
        function unfreezeContentHeight() {
          content.css({
            width: '',
            height: '',
            overflow: ''
          });
        }
        function getCalendar() {
          return t;
        }
        function getView() {
          return currentView;
        }
        function option(name, value) {
          if (value === undefined) {
            return options[name];
          }
          if (name == 'height' || name == 'contentHeight' || name == 'aspectRatio') {
            options[name] = value;
            updateSize(true);
          }
        }
        function trigger(name, thisObj) {
          var args = Array.prototype.slice.call(arguments, 2);
          thisObj = thisObj || _element;
          this.triggerWith(name, thisObj, args);
          if (options[name]) {
            return options[name].apply(thisObj, args);
          }
        }
        t.initialize();
      }
      ;
      ;
      Calendar.defaults = {
        titleRangeSeparator: ' \u2014 ',
        monthYearFormat: 'MMMM YYYY',
        defaultTimedEventDuration: '02:00:00',
        defaultAllDayEventDuration: {days: 1},
        forceEventDuration: false,
        nextDayThreshold: '09:00:00',
        defaultView: 'month',
        aspectRatio: 1.35,
        header: {
          left: 'title',
          center: '',
          right: 'today prev,next'
        },
        weekends: true,
        weekNumbers: false,
        weekNumberTitle: 'W',
        weekNumberCalculation: 'local',
        scrollTime: '06:00:00',
        lazyFetching: true,
        startParam: 'start',
        endParam: 'end',
        timezoneParam: 'timezone',
        timezone: false,
        isRTL: false,
        buttonText: {
          prev: "prev",
          next: "next",
          prevYear: "prev year",
          nextYear: "next year",
          year: 'year',
          today: 'today',
          month: 'month',
          week: 'week',
          day: 'day'
        },
        buttonIcons: {
          prev: 'left-single-arrow',
          next: 'right-single-arrow',
          prevYear: 'left-double-arrow',
          nextYear: 'right-double-arrow'
        },
        theme: false,
        themeButtonIcons: {
          prev: 'circle-triangle-w',
          next: 'circle-triangle-e',
          prevYear: 'seek-prev',
          nextYear: 'seek-next'
        },
        dragOpacity: .75,
        dragRevertDuration: 500,
        dragScroll: true,
        unselectAuto: true,
        dropAccept: '*',
        eventOrder: 'title',
        eventLimit: false,
        eventLimitText: 'more',
        eventLimitClick: 'popover',
        dayPopoverFormat: 'LL',
        handleWindowResize: true,
        windowResizeDelay: 200
      };
      Calendar.englishDefaults = {dayPopoverFormat: 'dddd, MMMM D'};
      Calendar.rtlDefaults = {
        header: {
          left: 'next,prev today',
          center: '',
          right: 'title'
        },
        buttonIcons: {
          prev: 'right-single-arrow',
          next: 'left-single-arrow',
          prevYear: 'right-double-arrow',
          nextYear: 'left-double-arrow'
        },
        themeButtonIcons: {
          prev: 'circle-triangle-e',
          next: 'circle-triangle-w',
          nextYear: 'seek-prev',
          prevYear: 'seek-next'
        }
      };
      ;
      ;
      var langOptionHash = FC.langs = {};
      FC.datepickerLang = function(langCode, dpLangCode, dpOptions) {
        var fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {});
        fcOptions.isRTL = dpOptions.isRTL;
        fcOptions.weekNumberTitle = dpOptions.weekHeader;
        $.each(dpComputableOptions, function(name, func) {
          fcOptions[name] = func(dpOptions);
        });
        if ($.datepicker) {
          $.datepicker.regional[dpLangCode] = $.datepicker.regional[langCode] = dpOptions;
          $.datepicker.regional.en = $.datepicker.regional[''];
          $.datepicker.setDefaults(dpOptions);
        }
      };
      FC.lang = function(langCode, newFcOptions) {
        var fcOptions;
        var momOptions;
        fcOptions = langOptionHash[langCode] || (langOptionHash[langCode] = {});
        if (newFcOptions) {
          fcOptions = langOptionHash[langCode] = mergeOptions([fcOptions, newFcOptions]);
        }
        momOptions = getMomentLocaleData(langCode);
        $.each(momComputableOptions, function(name, func) {
          if (fcOptions[name] == null) {
            fcOptions[name] = func(momOptions, fcOptions);
          }
        });
        Calendar.defaults.lang = langCode;
      };
      var dpComputableOptions = {
        buttonText: function(dpOptions) {
          return {
            prev: stripHtmlEntities(dpOptions.prevText),
            next: stripHtmlEntities(dpOptions.nextText),
            today: stripHtmlEntities(dpOptions.currentText)
          };
        },
        monthYearFormat: function(dpOptions) {
          return dpOptions.showMonthAfterYear ? 'YYYY[' + dpOptions.yearSuffix + '] MMMM' : 'MMMM YYYY[' + dpOptions.yearSuffix + ']';
        }
      };
      var momComputableOptions = {
        dayOfMonthFormat: function(momOptions, fcOptions) {
          var format = momOptions.longDateFormat('l');
          format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');
          if (fcOptions.isRTL) {
            format += ' ddd';
          } else {
            format = 'ddd ' + format;
          }
          return format;
        },
        mediumTimeFormat: function(momOptions) {
          return momOptions.longDateFormat('LT').replace(/\s*a$/i, 'a');
        },
        smallTimeFormat: function(momOptions) {
          return momOptions.longDateFormat('LT').replace(':mm', '(:mm)').replace(/(\Wmm)$/, '($1)').replace(/\s*a$/i, 'a');
        },
        extraSmallTimeFormat: function(momOptions) {
          return momOptions.longDateFormat('LT').replace(':mm', '(:mm)').replace(/(\Wmm)$/, '($1)').replace(/\s*a$/i, 't');
        },
        hourFormat: function(momOptions) {
          return momOptions.longDateFormat('LT').replace(':mm', '').replace(/(\Wmm)$/, '').replace(/\s*a$/i, 'a');
        },
        noMeridiemTimeFormat: function(momOptions) {
          return momOptions.longDateFormat('LT').replace(/\s*a$/i, '');
        }
      };
      var instanceComputableOptions = {
        smallDayDateFormat: function(options) {
          return options.isRTL ? 'D dd' : 'dd D';
        },
        weekFormat: function(options) {
          return options.isRTL ? 'w[ ' + options.weekNumberTitle + ']' : '[' + options.weekNumberTitle + ' ]w';
        },
        smallWeekFormat: function(options) {
          return options.isRTL ? 'w[' + options.weekNumberTitle + ']' : '[' + options.weekNumberTitle + ']w';
        }
      };
      function populateInstanceComputableOptions(options) {
        $.each(instanceComputableOptions, function(name, func) {
          if (options[name] == null) {
            options[name] = func(options);
          }
        });
      }
      function getMomentLocaleData(langCode) {
        var func = moment.localeData || moment.langData;
        return func.call(moment, langCode) || func.call(moment, 'en');
      }
      FC.lang('en', Calendar.englishDefaults);
      ;
      ;
      function Header(calendar, options) {
        var t = this;
        t.render = render;
        t.removeElement = removeElement;
        t.updateTitle = updateTitle;
        t.activateButton = activateButton;
        t.deactivateButton = deactivateButton;
        t.disableButton = disableButton;
        t.enableButton = enableButton;
        t.getViewsWithButtons = getViewsWithButtons;
        var el = $();
        var viewsWithButtons = [];
        var tm;
        function render() {
          var sections = options.header;
          tm = options.theme ? 'ui' : 'fc';
          if (sections) {
            el = $("<div class='fc-toolbar'/>").append(renderSection('left')).append(renderSection('right')).append(renderSection('center')).append('<div class="fc-clear"/>');
            return el;
          }
        }
        function removeElement() {
          el.remove();
          el = $();
        }
        function renderSection(position) {
          var sectionEl = $('<div class="fc-' + position + '"/>');
          var buttonStr = options.header[position];
          if (buttonStr) {
            $.each(buttonStr.split(' '), function(i) {
              var groupChildren = $();
              var isOnlyButtons = true;
              var groupEl;
              $.each(this.split(','), function(j, buttonName) {
                var customButtonProps;
                var viewSpec;
                var buttonClick;
                var overrideText;
                var defaultText;
                var themeIcon;
                var normalIcon;
                var innerHtml;
                var classes;
                var button;
                if (buttonName == 'title') {
                  groupChildren = groupChildren.add($('<h2>&nbsp;</h2>'));
                  isOnlyButtons = false;
                } else {
                  if ((customButtonProps = (calendar.options.customButtons || {})[buttonName])) {
                    buttonClick = function(ev) {
                      if (customButtonProps.click) {
                        customButtonProps.click.call(button[0], ev);
                      }
                    };
                    overrideText = '';
                    defaultText = customButtonProps.text;
                  } else if ((viewSpec = calendar.getViewSpec(buttonName))) {
                    buttonClick = function() {
                      calendar.changeView(buttonName);
                    };
                    viewsWithButtons.push(buttonName);
                    overrideText = viewSpec.buttonTextOverride;
                    defaultText = viewSpec.buttonTextDefault;
                  } else if (calendar[buttonName]) {
                    buttonClick = function() {
                      calendar[buttonName]();
                    };
                    overrideText = (calendar.overrides.buttonText || {})[buttonName];
                    defaultText = options.buttonText[buttonName];
                  }
                  if (buttonClick) {
                    themeIcon = customButtonProps ? customButtonProps.themeIcon : options.themeButtonIcons[buttonName];
                    normalIcon = customButtonProps ? customButtonProps.icon : options.buttonIcons[buttonName];
                    if (overrideText) {
                      innerHtml = htmlEscape(overrideText);
                    } else if (themeIcon && options.theme) {
                      innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
                    } else if (normalIcon && !options.theme) {
                      innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
                    } else {
                      innerHtml = htmlEscape(defaultText);
                    }
                    classes = ['fc-' + buttonName + '-button', tm + '-button', tm + '-state-default'];
                    button = $('<button type="button" class="' + classes.join(' ') + '">' + innerHtml + '</button>').click(function(ev) {
                      if (!button.hasClass(tm + '-state-disabled')) {
                        buttonClick(ev);
                        if (button.hasClass(tm + '-state-active') || button.hasClass(tm + '-state-disabled')) {
                          button.removeClass(tm + '-state-hover');
                        }
                      }
                    }).mousedown(function() {
                      button.not('.' + tm + '-state-active').not('.' + tm + '-state-disabled').addClass(tm + '-state-down');
                    }).mouseup(function() {
                      button.removeClass(tm + '-state-down');
                    }).hover(function() {
                      button.not('.' + tm + '-state-active').not('.' + tm + '-state-disabled').addClass(tm + '-state-hover');
                    }, function() {
                      button.removeClass(tm + '-state-hover').removeClass(tm + '-state-down');
                    });
                    groupChildren = groupChildren.add(button);
                  }
                }
              });
              if (isOnlyButtons) {
                groupChildren.first().addClass(tm + '-corner-left').end().last().addClass(tm + '-corner-right').end();
              }
              if (groupChildren.length > 1) {
                groupEl = $('<div/>');
                if (isOnlyButtons) {
                  groupEl.addClass('fc-button-group');
                }
                groupEl.append(groupChildren);
                sectionEl.append(groupEl);
              } else {
                sectionEl.append(groupChildren);
              }
            });
          }
          return sectionEl;
        }
        function updateTitle(text) {
          el.find('h2').text(text);
        }
        function activateButton(buttonName) {
          el.find('.fc-' + buttonName + '-button').addClass(tm + '-state-active');
        }
        function deactivateButton(buttonName) {
          el.find('.fc-' + buttonName + '-button').removeClass(tm + '-state-active');
        }
        function disableButton(buttonName) {
          el.find('.fc-' + buttonName + '-button').attr('disabled', 'disabled').addClass(tm + '-state-disabled');
        }
        function enableButton(buttonName) {
          el.find('.fc-' + buttonName + '-button').removeAttr('disabled').removeClass(tm + '-state-disabled');
        }
        function getViewsWithButtons() {
          return viewsWithButtons;
        }
      }
      ;
      ;
      FC.sourceNormalizers = [];
      FC.sourceFetchers = [];
      var ajaxDefaults = {
        dataType: 'json',
        cache: false
      };
      var eventGUID = 1;
      function EventManager(options) {
        var t = this;
        t.isFetchNeeded = isFetchNeeded;
        t.fetchEvents = fetchEvents;
        t.addEventSource = addEventSource;
        t.removeEventSource = removeEventSource;
        t.updateEvent = updateEvent;
        t.renderEvent = renderEvent;
        t.removeEvents = removeEvents;
        t.clientEvents = clientEvents;
        t.mutateEvent = mutateEvent;
        t.normalizeEventDates = normalizeEventDates;
        t.normalizeEventTimes = normalizeEventTimes;
        var reportEvents = t.reportEvents;
        var stickySource = {events: []};
        var sources = [stickySource];
        var rangeStart,
            rangeEnd;
        var currentFetchID = 0;
        var pendingSourceCnt = 0;
        var cache = [];
        $.each((options.events ? [options.events] : []).concat(options.eventSources || []), function(i, sourceInput) {
          var source = buildEventSource(sourceInput);
          if (source) {
            sources.push(source);
          }
        });
        function isFetchNeeded(start, end) {
          return !rangeStart || start < rangeStart || end > rangeEnd;
        }
        function fetchEvents(start, end) {
          rangeStart = start;
          rangeEnd = end;
          cache = [];
          var fetchID = ++currentFetchID;
          var len = sources.length;
          pendingSourceCnt = len;
          for (var i = 0; i < len; i++) {
            fetchEventSource(sources[i], fetchID);
          }
        }
        function fetchEventSource(source, fetchID) {
          _fetchEventSource(source, function(eventInputs) {
            var isArraySource = $.isArray(source.events);
            var i,
                eventInput;
            var abstractEvent;
            if (fetchID == currentFetchID) {
              if (eventInputs) {
                for (i = 0; i < eventInputs.length; i++) {
                  eventInput = eventInputs[i];
                  if (isArraySource) {
                    abstractEvent = eventInput;
                  } else {
                    abstractEvent = buildEventFromInput(eventInput, source);
                  }
                  if (abstractEvent) {
                    cache.push.apply(cache, expandEvent(abstractEvent));
                  }
                }
              }
              pendingSourceCnt--;
              if (!pendingSourceCnt) {
                reportEvents(cache);
              }
            }
          });
        }
        function _fetchEventSource(source, callback) {
          var i;
          var fetchers = FC.sourceFetchers;
          var res;
          for (i = 0; i < fetchers.length; i++) {
            res = fetchers[i].call(t, source, rangeStart.clone(), rangeEnd.clone(), options.timezone, callback);
            if (res === true) {
              return;
            } else if (typeof res == 'object') {
              _fetchEventSource(res, callback);
              return;
            }
          }
          var events = source.events;
          if (events) {
            if ($.isFunction(events)) {
              t.pushLoading();
              events.call(t, rangeStart.clone(), rangeEnd.clone(), options.timezone, function(events) {
                callback(events);
                t.popLoading();
              });
            } else if ($.isArray(events)) {
              callback(events);
            } else {
              callback();
            }
          } else {
            var url = source.url;
            if (url) {
              var success = source.success;
              var error = source.error;
              var complete = source.complete;
              var customData;
              if ($.isFunction(source.data)) {
                customData = source.data();
              } else {
                customData = source.data;
              }
              var data = $.extend({}, customData || {});
              var startParam = firstDefined(source.startParam, options.startParam);
              var endParam = firstDefined(source.endParam, options.endParam);
              var timezoneParam = firstDefined(source.timezoneParam, options.timezoneParam);
              if (startParam) {
                data[startParam] = rangeStart.format();
              }
              if (endParam) {
                data[endParam] = rangeEnd.format();
              }
              if (options.timezone && options.timezone != 'local') {
                data[timezoneParam] = options.timezone;
              }
              t.pushLoading();
              $.ajax($.extend({}, ajaxDefaults, source, {
                data: data,
                success: function(events) {
                  events = events || [];
                  var res = applyAll(success, this, arguments);
                  if ($.isArray(res)) {
                    events = res;
                  }
                  callback(events);
                },
                error: function() {
                  applyAll(error, this, arguments);
                  callback();
                },
                complete: function() {
                  applyAll(complete, this, arguments);
                  t.popLoading();
                }
              }));
            } else {
              callback();
            }
          }
        }
        function addEventSource(sourceInput) {
          var source = buildEventSource(sourceInput);
          if (source) {
            sources.push(source);
            pendingSourceCnt++;
            fetchEventSource(source, currentFetchID);
          }
        }
        function buildEventSource(sourceInput) {
          var normalizers = FC.sourceNormalizers;
          var source;
          var i;
          if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
            source = {events: sourceInput};
          } else if (typeof sourceInput === 'string') {
            source = {url: sourceInput};
          } else if (typeof sourceInput === 'object') {
            source = $.extend({}, sourceInput);
          }
          if (source) {
            if (source.className) {
              if (typeof source.className === 'string') {
                source.className = source.className.split(/\s+/);
              }
            } else {
              source.className = [];
            }
            if ($.isArray(source.events)) {
              source.origArray = source.events;
              source.events = $.map(source.events, function(eventInput) {
                return buildEventFromInput(eventInput, source);
              });
            }
            for (i = 0; i < normalizers.length; i++) {
              normalizers[i].call(t, source);
            }
            return source;
          }
        }
        function removeEventSource(source) {
          sources = $.grep(sources, function(src) {
            return !isSourcesEqual(src, source);
          });
          cache = $.grep(cache, function(e) {
            return !isSourcesEqual(e.source, source);
          });
          reportEvents(cache);
        }
        function isSourcesEqual(source1, source2) {
          return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
        }
        function getSourcePrimitive(source) {
          return ((typeof source === 'object') ? (source.origArray || source.googleCalendarId || source.url || source.events) : null) || source;
        }
        function updateEvent(event) {
          event.start = t.moment(event.start);
          if (event.end) {
            event.end = t.moment(event.end);
          } else {
            event.end = null;
          }
          mutateEvent(event, getMiscEventProps(event));
          reportEvents(cache);
        }
        function getMiscEventProps(event) {
          var props = {};
          $.each(event, function(name, val) {
            if (isMiscEventPropName(name)) {
              if (val !== undefined && isAtomic(val)) {
                props[name] = val;
              }
            }
          });
          return props;
        }
        function isMiscEventPropName(name) {
          return !/^_|^(id|allDay|start|end)$/.test(name);
        }
        function renderEvent(eventInput, stick) {
          var abstractEvent = buildEventFromInput(eventInput);
          var events;
          var i,
              event;
          if (abstractEvent) {
            events = expandEvent(abstractEvent);
            for (i = 0; i < events.length; i++) {
              event = events[i];
              if (!event.source) {
                if (stick) {
                  stickySource.events.push(event);
                  event.source = stickySource;
                }
                cache.push(event);
              }
            }
            reportEvents(cache);
            return events;
          }
          return [];
        }
        function removeEvents(filter) {
          var eventID;
          var i;
          if (filter == null) {
            filter = function() {
              return true;
            };
          } else if (!$.isFunction(filter)) {
            eventID = filter + '';
            filter = function(event) {
              return event._id == eventID;
            };
          }
          cache = $.grep(cache, filter, true);
          for (i = 0; i < sources.length; i++) {
            if ($.isArray(sources[i].events)) {
              sources[i].events = $.grep(sources[i].events, filter, true);
            }
          }
          reportEvents(cache);
        }
        function clientEvents(filter) {
          if ($.isFunction(filter)) {
            return $.grep(cache, filter);
          } else if (filter != null) {
            filter += '';
            return $.grep(cache, function(e) {
              return e._id == filter;
            });
          }
          return cache;
        }
        function buildEventFromInput(input, source) {
          var out = {};
          var start,
              end;
          var allDay;
          if (options.eventDataTransform) {
            input = options.eventDataTransform(input);
          }
          if (source && source.eventDataTransform) {
            input = source.eventDataTransform(input);
          }
          $.extend(out, input);
          if (source) {
            out.source = source;
          }
          out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');
          if (input.className) {
            if (typeof input.className == 'string') {
              out.className = input.className.split(/\s+/);
            } else {
              out.className = input.className;
            }
          } else {
            out.className = [];
          }
          start = input.start || input.date;
          end = input.end;
          if (isTimeString(start)) {
            start = moment.duration(start);
          }
          if (isTimeString(end)) {
            end = moment.duration(end);
          }
          if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {
            out.start = start ? moment.duration(start) : null;
            out.end = end ? moment.duration(end) : null;
            out._recurring = true;
          } else {
            if (start) {
              start = t.moment(start);
              if (!start.isValid()) {
                return false;
              }
            }
            if (end) {
              end = t.moment(end);
              if (!end.isValid()) {
                end = null;
              }
            }
            allDay = input.allDay;
            if (allDay === undefined) {
              allDay = firstDefined(source ? source.allDayDefault : undefined, options.allDayDefault);
            }
            assignDatesToEvent(start, end, allDay, out);
          }
          return out;
        }
        function assignDatesToEvent(start, end, allDay, event) {
          event.start = start;
          event.end = end;
          event.allDay = allDay;
          normalizeEventDates(event);
          backupEventDates(event);
        }
        function normalizeEventDates(eventProps) {
          normalizeEventTimes(eventProps);
          if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {
            eventProps.end = null;
          }
          if (!eventProps.end) {
            if (options.forceEventDuration) {
              eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);
            } else {
              eventProps.end = null;
            }
          }
        }
        function normalizeEventTimes(eventProps) {
          if (eventProps.allDay == null) {
            eventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));
          }
          if (eventProps.allDay) {
            eventProps.start.stripTime();
            if (eventProps.end) {
              eventProps.end.stripTime();
            }
          } else {
            if (!eventProps.start.hasTime()) {
              eventProps.start = t.applyTimezone(eventProps.start.time(0));
            }
            if (eventProps.end && !eventProps.end.hasTime()) {
              eventProps.end = t.applyTimezone(eventProps.end.time(0));
            }
          }
        }
        function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
          var events = [];
          var dowHash;
          var dow;
          var i;
          var date;
          var startTime,
              endTime;
          var start,
              end;
          var event;
          _rangeStart = _rangeStart || rangeStart;
          _rangeEnd = _rangeEnd || rangeEnd;
          if (abstractEvent) {
            if (abstractEvent._recurring) {
              if ((dow = abstractEvent.dow)) {
                dowHash = {};
                for (i = 0; i < dow.length; i++) {
                  dowHash[dow[i]] = true;
                }
              }
              date = _rangeStart.clone().stripTime();
              while (date.isBefore(_rangeEnd)) {
                if (!dowHash || dowHash[date.day()]) {
                  startTime = abstractEvent.start;
                  endTime = abstractEvent.end;
                  start = date.clone();
                  end = null;
                  if (startTime) {
                    start = start.time(startTime);
                  }
                  if (endTime) {
                    end = date.clone().time(endTime);
                  }
                  event = $.extend({}, abstractEvent);
                  assignDatesToEvent(start, end, !startTime && !endTime, event);
                  events.push(event);
                }
                date.add(1, 'days');
              }
            } else {
              events.push(abstractEvent);
            }
          }
          return events;
        }
        function mutateEvent(event, newProps, largeUnit) {
          var miscProps = {};
          var oldProps;
          var clearEnd;
          var startDelta;
          var endDelta;
          var durationDelta;
          var undoFunc;
          function diffDates(date1, date0) {
            if (largeUnit) {
              return diffByUnit(date1, date0, largeUnit);
            } else if (newProps.allDay) {
              return diffDay(date1, date0);
            } else {
              return diffDayTime(date1, date0);
            }
          }
          newProps = newProps || {};
          if (!newProps.start) {
            newProps.start = event.start.clone();
          }
          if (newProps.end === undefined) {
            newProps.end = event.end ? event.end.clone() : null;
          }
          if (newProps.allDay == null) {
            newProps.allDay = event.allDay;
          }
          normalizeEventDates(newProps);
          oldProps = {
            start: event._start.clone(),
            end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
            allDay: newProps.allDay
          };
          normalizeEventDates(oldProps);
          clearEnd = event._end !== null && newProps.end === null;
          startDelta = diffDates(newProps.start, oldProps.start);
          if (newProps.end) {
            endDelta = diffDates(newProps.end, oldProps.end);
            durationDelta = endDelta.subtract(startDelta);
          } else {
            durationDelta = null;
          }
          $.each(newProps, function(name, val) {
            if (isMiscEventPropName(name)) {
              if (val !== undefined) {
                miscProps[name] = val;
              }
            }
          });
          undoFunc = mutateEvents(clientEvents(event._id), clearEnd, newProps.allDay, startDelta, durationDelta, miscProps);
          return {
            dateDelta: startDelta,
            durationDelta: durationDelta,
            undo: undoFunc
          };
        }
        function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
          var isAmbigTimezone = t.getIsAmbigTimezone();
          var undoFunctions = [];
          if (dateDelta && !dateDelta.valueOf()) {
            dateDelta = null;
          }
          if (durationDelta && !durationDelta.valueOf()) {
            durationDelta = null;
          }
          $.each(events, function(i, event) {
            var oldProps;
            var newProps;
            oldProps = {
              start: event.start.clone(),
              end: event.end ? event.end.clone() : null,
              allDay: event.allDay
            };
            $.each(miscProps, function(name) {
              oldProps[name] = event[name];
            });
            newProps = {
              start: event._start,
              end: event._end,
              allDay: allDay
            };
            normalizeEventDates(newProps);
            if (clearEnd) {
              newProps.end = null;
            } else if (durationDelta && !newProps.end) {
              newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
            }
            if (dateDelta) {
              newProps.start.add(dateDelta);
              if (newProps.end) {
                newProps.end.add(dateDelta);
              }
            }
            if (durationDelta) {
              newProps.end.add(durationDelta);
            }
            if (isAmbigTimezone && !newProps.allDay && (dateDelta || durationDelta)) {
              newProps.start.stripZone();
              if (newProps.end) {
                newProps.end.stripZone();
              }
            }
            $.extend(event, miscProps, newProps);
            backupEventDates(event);
            undoFunctions.push(function() {
              $.extend(event, oldProps);
              backupEventDates(event);
            });
          });
          return function() {
            for (var i = 0; i < undoFunctions.length; i++) {
              undoFunctions[i]();
            }
          };
        }
        t.getBusinessHoursEvents = getBusinessHoursEvents;
        function getBusinessHoursEvents(wholeDay) {
          var optionVal = options.businessHours;
          var defaultVal = {
            className: 'fc-nonbusiness',
            start: '09:00',
            end: '17:00',
            dow: [1, 2, 3, 4, 5],
            rendering: 'inverse-background'
          };
          var view = t.getView();
          var eventInput;
          if (optionVal) {
            eventInput = $.extend({}, defaultVal, typeof optionVal === 'object' ? optionVal : {});
          }
          if (eventInput) {
            if (wholeDay) {
              eventInput.start = null;
              eventInput.end = null;
            }
            return expandEvent(buildEventFromInput(eventInput), view.start, view.end);
          }
          return [];
        }
        t.isEventSpanAllowed = isEventSpanAllowed;
        t.isExternalSpanAllowed = isExternalSpanAllowed;
        t.isSelectionSpanAllowed = isSelectionSpanAllowed;
        function isEventSpanAllowed(span, event) {
          var source = event.source || {};
          var constraint = firstDefined(event.constraint, source.constraint, options.eventConstraint);
          var overlap = firstDefined(event.overlap, source.overlap, options.eventOverlap);
          return isSpanAllowed(span, constraint, overlap, event);
        }
        function isExternalSpanAllowed(eventSpan, eventLocation, eventProps) {
          var eventInput;
          var event;
          if (eventProps) {
            eventInput = $.extend({}, eventProps, eventLocation);
            event = expandEvent(buildEventFromInput(eventInput))[0];
          }
          if (event) {
            return isEventSpanAllowed(eventSpan, event);
          } else {
            return isSelectionSpanAllowed(eventSpan);
          }
        }
        function isSelectionSpanAllowed(span) {
          return isSpanAllowed(span, options.selectConstraint, options.selectOverlap);
        }
        function isSpanAllowed(span, constraint, overlap, event) {
          var constraintEvents;
          var anyContainment;
          var peerEvents;
          var i,
              peerEvent;
          var peerOverlap;
          if (constraint != null) {
            constraintEvents = constraintToEvents(constraint);
            anyContainment = false;
            for (i = 0; i < constraintEvents.length; i++) {
              if (eventContainsRange(constraintEvents[i], span)) {
                anyContainment = true;
                break;
              }
            }
            if (!anyContainment) {
              return false;
            }
          }
          peerEvents = t.getPeerEvents(span, event);
          for (i = 0; i < peerEvents.length; i++) {
            peerEvent = peerEvents[i];
            if (eventIntersectsRange(peerEvent, span)) {
              if (overlap === false) {
                return false;
              } else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {
                return false;
              }
              if (event) {
                peerOverlap = firstDefined(peerEvent.overlap, (peerEvent.source || {}).overlap);
                if (peerOverlap === false) {
                  return false;
                }
                if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {
                  return false;
                }
              }
            }
          }
          return true;
        }
        function constraintToEvents(constraintInput) {
          if (constraintInput === 'businessHours') {
            return getBusinessHoursEvents();
          }
          if (typeof constraintInput === 'object') {
            return expandEvent(buildEventFromInput(constraintInput));
          }
          return clientEvents(constraintInput);
        }
        function eventContainsRange(event, range) {
          var eventStart = event.start.clone().stripZone();
          var eventEnd = t.getEventEnd(event).stripZone();
          return range.start >= eventStart && range.end <= eventEnd;
        }
        function eventIntersectsRange(event, range) {
          var eventStart = event.start.clone().stripZone();
          var eventEnd = t.getEventEnd(event).stripZone();
          return range.start < eventEnd && range.end > eventStart;
        }
        t.getEventCache = function() {
          return cache;
        };
      }
      Calendar.prototype.getPeerEvents = function(span, event) {
        var cache = this.getEventCache();
        var peerEvents = [];
        var i,
            otherEvent;
        for (i = 0; i < cache.length; i++) {
          otherEvent = cache[i];
          if (!event || event._id !== otherEvent._id) {
            peerEvents.push(otherEvent);
          }
        }
        return peerEvents;
      };
      function backupEventDates(event) {
        event._allDay = event.allDay;
        event._start = event.start.clone();
        event._end = event.end ? event.end.clone() : null;
      }
      ;
      ;
      var BasicView = FC.BasicView = View.extend({
        dayGridClass: DayGrid,
        dayGrid: null,
        dayNumbersVisible: false,
        weekNumbersVisible: false,
        weekNumberWidth: null,
        headContainerEl: null,
        headRowEl: null,
        initialize: function() {
          this.dayGrid = this.instantiateDayGrid();
        },
        instantiateDayGrid: function() {
          var subclass = this.dayGridClass.extend(basicDayGridMethods);
          return new subclass(this);
        },
        setRange: function(range) {
          View.prototype.setRange.call(this, range);
          this.dayGrid.breakOnWeeks = /year|month|week/.test(this.intervalUnit);
          this.dayGrid.setRange(range);
        },
        computeRange: function(date) {
          var range = View.prototype.computeRange.call(this, date);
          if (/year|month/.test(range.intervalUnit)) {
            range.start.startOf('week');
            range.start = this.skipHiddenDays(range.start);
            if (range.end.weekday()) {
              range.end.add(1, 'week').startOf('week');
              range.end = this.skipHiddenDays(range.end, -1, true);
            }
          }
          return range;
        },
        renderDates: function() {
          this.dayNumbersVisible = this.dayGrid.rowCnt > 1;
          this.weekNumbersVisible = this.opt('weekNumbers');
          this.dayGrid.numbersVisible = this.dayNumbersVisible || this.weekNumbersVisible;
          this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
          this.renderHead();
          this.scrollerEl = this.el.find('.fc-day-grid-container');
          this.dayGrid.setElement(this.el.find('.fc-day-grid'));
          this.dayGrid.renderDates(this.hasRigidRows());
        },
        renderHead: function() {
          this.headContainerEl = this.el.find('.fc-head-container').html(this.dayGrid.renderHeadHtml());
          this.headRowEl = this.headContainerEl.find('.fc-row');
        },
        unrenderDates: function() {
          this.dayGrid.unrenderDates();
          this.dayGrid.removeElement();
        },
        renderBusinessHours: function() {
          this.dayGrid.renderBusinessHours();
        },
        renderSkeletonHtml: function() {
          return '' + '<table>' + '<thead class="fc-head">' + '<tr>' + '<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' + '</tr>' + '</thead>' + '<tbody class="fc-body">' + '<tr>' + '<td class="' + this.widgetContentClass + '">' + '<div class="fc-day-grid-container">' + '<div class="fc-day-grid"/>' + '</div>' + '</td>' + '</tr>' + '</tbody>' + '</table>';
        },
        weekNumberStyleAttr: function() {
          if (this.weekNumberWidth !== null) {
            return 'style="width:' + this.weekNumberWidth + 'px"';
          }
          return '';
        },
        hasRigidRows: function() {
          var eventLimit = this.opt('eventLimit');
          return eventLimit && typeof eventLimit !== 'number';
        },
        updateWidth: function() {
          if (this.weekNumbersVisible) {
            this.weekNumberWidth = matchCellWidths(this.el.find('.fc-week-number'));
          }
        },
        setHeight: function(totalHeight, isAuto) {
          var eventLimit = this.opt('eventLimit');
          var scrollerHeight;
          unsetScroller(this.scrollerEl);
          uncompensateScroll(this.headRowEl);
          this.dayGrid.removeSegPopover();
          if (eventLimit && typeof eventLimit === 'number') {
            this.dayGrid.limitRows(eventLimit);
          }
          scrollerHeight = this.computeScrollerHeight(totalHeight);
          this.setGridHeight(scrollerHeight, isAuto);
          if (eventLimit && typeof eventLimit !== 'number') {
            this.dayGrid.limitRows(eventLimit);
          }
          if (!isAuto && setPotentialScroller(this.scrollerEl, scrollerHeight)) {
            compensateScroll(this.headRowEl, getScrollbarWidths(this.scrollerEl));
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scrollerEl.height(scrollerHeight);
          }
        },
        setGridHeight: function(height, isAuto) {
          if (isAuto) {
            undistributeHeight(this.dayGrid.rowEls);
          } else {
            distributeHeight(this.dayGrid.rowEls, height, true);
          }
        },
        prepareHits: function() {
          this.dayGrid.prepareHits();
        },
        releaseHits: function() {
          this.dayGrid.releaseHits();
        },
        queryHit: function(left, top) {
          return this.dayGrid.queryHit(left, top);
        },
        getHitSpan: function(hit) {
          return this.dayGrid.getHitSpan(hit);
        },
        getHitEl: function(hit) {
          return this.dayGrid.getHitEl(hit);
        },
        renderEvents: function(events) {
          this.dayGrid.renderEvents(events);
          this.updateHeight();
        },
        getEventSegs: function() {
          return this.dayGrid.getEventSegs();
        },
        unrenderEvents: function() {
          this.dayGrid.unrenderEvents();
        },
        renderDrag: function(dropLocation, seg) {
          return this.dayGrid.renderDrag(dropLocation, seg);
        },
        unrenderDrag: function() {
          this.dayGrid.unrenderDrag();
        },
        renderSelection: function(span) {
          this.dayGrid.renderSelection(span);
        },
        unrenderSelection: function() {
          this.dayGrid.unrenderSelection();
        }
      });
      var basicDayGridMethods = {
        renderHeadIntroHtml: function() {
          var view = this.view;
          if (view.weekNumbersVisible) {
            return '' + '<th class="fc-week-number ' + view.widgetHeaderClass + '" ' + view.weekNumberStyleAttr() + '>' + '<span>' + htmlEscape(view.opt('weekNumberTitle')) + '</span>' + '</th>';
          }
          return '';
        },
        renderNumberIntroHtml: function(row) {
          var view = this.view;
          if (view.weekNumbersVisible) {
            return '' + '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' + '<span>' + this.getCellDate(row, 0).format('w') + '</span>' + '</td>';
          }
          return '';
        },
        renderBgIntroHtml: function() {
          var view = this.view;
          if (view.weekNumbersVisible) {
            return '<td class="fc-week-number ' + view.widgetContentClass + '" ' + view.weekNumberStyleAttr() + '></td>';
          }
          return '';
        },
        renderIntroHtml: function() {
          var view = this.view;
          if (view.weekNumbersVisible) {
            return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
          }
          return '';
        }
      };
      ;
      ;
      var MonthView = FC.MonthView = BasicView.extend({
        computeRange: function(date) {
          var range = BasicView.prototype.computeRange.call(this, date);
          var rowCnt;
          if (this.isFixedWeeks()) {
            rowCnt = Math.ceil(range.end.diff(range.start, 'weeks', true));
            range.end.add(6 - rowCnt, 'weeks');
          }
          return range;
        },
        setGridHeight: function(height, isAuto) {
          isAuto = isAuto || this.opt('weekMode') === 'variable';
          if (isAuto) {
            height *= this.rowCnt / 6;
          }
          distributeHeight(this.dayGrid.rowEls, height, !isAuto);
        },
        isFixedWeeks: function() {
          var weekMode = this.opt('weekMode');
          if (weekMode) {
            return weekMode === 'fixed';
          }
          return this.opt('fixedWeekCount');
        }
      });
      ;
      ;
      fcViews.basic = {'class': BasicView};
      fcViews.basicDay = {
        type: 'basic',
        duration: {days: 1}
      };
      fcViews.basicWeek = {
        type: 'basic',
        duration: {weeks: 1}
      };
      fcViews.month = {
        'class': MonthView,
        duration: {months: 1},
        defaults: {fixedWeekCount: true}
      };
      ;
      ;
      var AgendaView = FC.AgendaView = View.extend({
        timeGridClass: TimeGrid,
        timeGrid: null,
        dayGridClass: DayGrid,
        dayGrid: null,
        axisWidth: null,
        headContainerEl: null,
        noScrollRowEls: null,
        bottomRuleEl: null,
        bottomRuleHeight: null,
        initialize: function() {
          this.timeGrid = this.instantiateTimeGrid();
          if (this.opt('allDaySlot')) {
            this.dayGrid = this.instantiateDayGrid();
          }
        },
        instantiateTimeGrid: function() {
          var subclass = this.timeGridClass.extend(agendaTimeGridMethods);
          return new subclass(this);
        },
        instantiateDayGrid: function() {
          var subclass = this.dayGridClass.extend(agendaDayGridMethods);
          return new subclass(this);
        },
        setRange: function(range) {
          View.prototype.setRange.call(this, range);
          this.timeGrid.setRange(range);
          if (this.dayGrid) {
            this.dayGrid.setRange(range);
          }
        },
        renderDates: function() {
          this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
          this.renderHead();
          this.scrollerEl = this.el.find('.fc-time-grid-container');
          this.timeGrid.setElement(this.el.find('.fc-time-grid'));
          this.timeGrid.renderDates();
          this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>').appendTo(this.timeGrid.el);
          if (this.dayGrid) {
            this.dayGrid.setElement(this.el.find('.fc-day-grid'));
            this.dayGrid.renderDates();
            this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
          }
          this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');
        },
        renderHead: function() {
          this.headContainerEl = this.el.find('.fc-head-container').html(this.timeGrid.renderHeadHtml());
        },
        unrenderDates: function() {
          this.timeGrid.unrenderDates();
          this.timeGrid.removeElement();
          if (this.dayGrid) {
            this.dayGrid.unrenderDates();
            this.dayGrid.removeElement();
          }
        },
        renderBusinessHours: function() {
          this.timeGrid.renderBusinessHours();
          if (this.dayGrid) {
            this.dayGrid.renderBusinessHours();
          }
        },
        renderSkeletonHtml: function() {
          return '' + '<table>' + '<thead class="fc-head">' + '<tr>' + '<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' + '</tr>' + '</thead>' + '<tbody class="fc-body">' + '<tr>' + '<td class="' + this.widgetContentClass + '">' + (this.dayGrid ? '<div class="fc-day-grid"/>' + '<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' : '') + '<div class="fc-time-grid-container">' + '<div class="fc-time-grid"/>' + '</div>' + '</td>' + '</tr>' + '</tbody>' + '</table>';
        },
        axisStyleAttr: function() {
          if (this.axisWidth !== null) {
            return 'style="width:' + this.axisWidth + 'px"';
          }
          return '';
        },
        updateSize: function(isResize) {
          this.timeGrid.updateSize(isResize);
          View.prototype.updateSize.call(this, isResize);
        },
        updateWidth: function() {
          this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
        },
        setHeight: function(totalHeight, isAuto) {
          var eventLimit;
          var scrollerHeight;
          if (this.bottomRuleHeight === null) {
            this.bottomRuleHeight = this.bottomRuleEl.outerHeight();
          }
          this.bottomRuleEl.hide();
          this.scrollerEl.css('overflow', '');
          unsetScroller(this.scrollerEl);
          uncompensateScroll(this.noScrollRowEls);
          if (this.dayGrid) {
            this.dayGrid.removeSegPopover();
            eventLimit = this.opt('eventLimit');
            if (eventLimit && typeof eventLimit !== 'number') {
              eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT;
            }
            if (eventLimit) {
              this.dayGrid.limitRows(eventLimit);
            }
          }
          if (!isAuto) {
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            if (setPotentialScroller(this.scrollerEl, scrollerHeight)) {
              compensateScroll(this.noScrollRowEls, getScrollbarWidths(this.scrollerEl));
              scrollerHeight = this.computeScrollerHeight(totalHeight);
              this.scrollerEl.height(scrollerHeight);
            } else {
              this.scrollerEl.height(scrollerHeight).css('overflow', 'hidden');
              this.bottomRuleEl.show();
            }
          }
        },
        computeInitialScroll: function() {
          var scrollTime = moment.duration(this.opt('scrollTime'));
          var top = this.timeGrid.computeTimeTop(scrollTime);
          top = Math.ceil(top);
          if (top) {
            top++;
          }
          return top;
        },
        prepareHits: function() {
          this.timeGrid.prepareHits();
          if (this.dayGrid) {
            this.dayGrid.prepareHits();
          }
        },
        releaseHits: function() {
          this.timeGrid.releaseHits();
          if (this.dayGrid) {
            this.dayGrid.releaseHits();
          }
        },
        queryHit: function(left, top) {
          var hit = this.timeGrid.queryHit(left, top);
          if (!hit && this.dayGrid) {
            hit = this.dayGrid.queryHit(left, top);
          }
          return hit;
        },
        getHitSpan: function(hit) {
          return hit.component.getHitSpan(hit);
        },
        getHitEl: function(hit) {
          return hit.component.getHitEl(hit);
        },
        renderEvents: function(events) {
          var dayEvents = [];
          var timedEvents = [];
          var daySegs = [];
          var timedSegs;
          var i;
          for (i = 0; i < events.length; i++) {
            if (events[i].allDay) {
              dayEvents.push(events[i]);
            } else {
              timedEvents.push(events[i]);
            }
          }
          timedSegs = this.timeGrid.renderEvents(timedEvents);
          if (this.dayGrid) {
            daySegs = this.dayGrid.renderEvents(dayEvents);
          }
          this.updateHeight();
        },
        getEventSegs: function() {
          return this.timeGrid.getEventSegs().concat(this.dayGrid ? this.dayGrid.getEventSegs() : []);
        },
        unrenderEvents: function() {
          this.timeGrid.unrenderEvents();
          if (this.dayGrid) {
            this.dayGrid.unrenderEvents();
          }
        },
        renderDrag: function(dropLocation, seg) {
          if (dropLocation.start.hasTime()) {
            return this.timeGrid.renderDrag(dropLocation, seg);
          } else if (this.dayGrid) {
            return this.dayGrid.renderDrag(dropLocation, seg);
          }
        },
        unrenderDrag: function() {
          this.timeGrid.unrenderDrag();
          if (this.dayGrid) {
            this.dayGrid.unrenderDrag();
          }
        },
        renderSelection: function(span) {
          if (span.start.hasTime() || span.end.hasTime()) {
            this.timeGrid.renderSelection(span);
          } else if (this.dayGrid) {
            this.dayGrid.renderSelection(span);
          }
        },
        unrenderSelection: function() {
          this.timeGrid.unrenderSelection();
          if (this.dayGrid) {
            this.dayGrid.unrenderSelection();
          }
        }
      });
      var agendaTimeGridMethods = {
        renderHeadIntroHtml: function() {
          var view = this.view;
          var weekText;
          if (view.opt('weekNumbers')) {
            weekText = this.start.format(view.opt('smallWeekFormat'));
            return '' + '<th class="fc-axis fc-week-number ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '>' + '<span>' + htmlEscape(weekText) + '</span>' + '</th>';
          } else {
            return '<th class="fc-axis ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '></th>';
          }
        },
        renderBgIntroHtml: function() {
          var view = this.view;
          return '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '></td>';
        },
        renderIntroHtml: function() {
          var view = this.view;
          return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
        }
      };
      var agendaDayGridMethods = {
        renderBgIntroHtml: function() {
          var view = this.view;
          return '' + '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' + '<span>' + (view.opt('allDayHtml') || htmlEscape(view.opt('allDayText'))) + '</span>' + '</td>';
        },
        renderIntroHtml: function() {
          var view = this.view;
          return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
        }
      };
      ;
      ;
      var AGENDA_ALL_DAY_EVENT_LIMIT = 5;
      var AGENDA_STOCK_SUB_DURATIONS = [{hours: 1}, {minutes: 30}, {minutes: 15}, {seconds: 30}, {seconds: 15}];
      fcViews.agenda = {
        'class': AgendaView,
        defaults: {
          allDaySlot: true,
          allDayText: 'all-day',
          slotDuration: '00:30:00',
          minTime: '00:00:00',
          maxTime: '24:00:00',
          slotEventOverlap: true
        }
      };
      fcViews.agendaDay = {
        type: 'agenda',
        duration: {days: 1}
      };
      fcViews.agendaWeek = {
        type: 'agenda',
        duration: {weeks: 1}
      };
      ;
      ;
      return FC;
    });
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("7c", ["7b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('7b');
  global.define = __define;
  return module.exports;
});

$__System.register('7d', ['12', '70', '74', '75', '76', '78', '6d', 'b', '7a', '7c'], function (_export) {
    var Vue, _getIterator, _Array$from, tmpl, moment, _Map, debug, $, fullCalendar;

    return {
        setters: [function (_5) {
            Vue = _5['default'];
        }, function (_) {
            _getIterator = _['default'];
        }, function (_2) {
            _Array$from = _2['default'];
        }, function (_3) {}, function (_4) {
            tmpl = _4['default'];
        }, function (_6) {
            moment = _6['default'];
        }, function (_d) {
            _Map = _d['default'];
        }, function (_b) {
            debug = _b.debug;
        }, function (_a) {
            $ = _a['default'];
        }, function (_c) {
            fullCalendar = _c['default'];
        }],
        execute: function () {
            'use strict';

            _export('default', Vue.extend({
                template: tmpl,
                components: {},
                props: ['calendar'],
                data: function data() {
                    return {
                        'element': null,
                        'view': {},
                        'options': {
                            header: false,
                            minTime: '06:00:00',
                            maxTime: '22:00:00',
                            firstDay: 1,
                            weekends: false,
                            timeFormat: 'hh:mm a',
                            allDayText: '',
                            defaultView: 'month',
                            businessHours: false,
                            slotLabelFormat: 'h a',
                            slotEventOverlap: false,
                            views: {
                                week: {
                                    titleFormat: 'D MMM YYYY',
                                    columnFormat: 'dddd Do'
                                }
                            }
                        }
                    };
                },
                ready: function ready() {
                    if (debug) window.calendar_panel = this;

                    this.$root.control.get_bookings(this.calendar);

                    this.element = $('#calendar');
                    this.element.fullCalendar(this.options);

                    this.view = this.element.fullCalendar('getView');

                    Vue.nextTick(this.resize_calendar);
                },
                methods: {
                    page: function page() {
                        var direction = arguments.length <= 0 || arguments[0] === undefined ? 'next' : arguments[0];

                        this.element.fullCalendar(direction);
                    },
                    change_view: function change_view(view_name) {
                        this.element.fullCalendar('changeView', view_name);
                        this.view = this.element.fullCalendar('getView'); // TODO: view properties not reactive (e.g. changing month, title stops udating)
                    },
                    resize_calendar: function resize_calendar() {
                        var calendar_height = this.$els.panel.offsetHeight - this.$els.header.offsetHeight - 1; // take 1px off to resolve rounding error
                        this.element.fullCalendar('option', 'height', calendar_height);
                    }
                },
                computed: {
                    display_title: function display_title() {
                        var title = this.view.title ? this.view.title : "Loading";
                        return title.replace('', '-');
                    },
                    grouped_bookings: function grouped_bookings() {
                        // Takes bookings that only differ on resource and groups them into a single entity
                        var groups = new _Map();
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = _getIterator(this.calendar.bookings), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var b = _step.value;

                                var key = b.start_date + '-' + b.end_date + '-' + b.event.id;
                                var group = groups.has(key) ? groups.get(key) : groups.set(key, {
                                    start_date: b.start_date,
                                    end_date: b.end_date,
                                    event: b.event,
                                    bookings: []
                                }).get(key);

                                group.bookings.push({
                                    id: b.id,
                                    resource: b.resource
                                });
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator['return']) {
                                    _iterator['return']();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }

                        return _Array$from(groups.values());
                    }
                },
                watch: {},
                events: {
                    resize: function resize(size) {
                        this.resize_calendar();
                        return true;
                    }
                }
            }));
        }
    };
});
$__System.register("7e", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("7f", [], function() {
  return "\n<div class=\"EventsPanel\" v-el:panel>\n\n    <div class=\"list-header u-full-width\" v-el:header>\n        <span id=\"event-panel-title\" class=\"panel-title\">\n            <input\n                v-el:search\n                class=\"action-bar-search pull-right\"\n                type=\"text\"\n                v-if=\"state == states.SEARCH\"\n                transition=\"expand-horizontal-fade\"\n                v-model=\"search_query\"\n                placeholder=\"search\"\n                @keyup.esc=\"search_query ? search_query = '' : state = states.NORMAL\">\n            <span class=\"action-container search-action pull-right\">\n                <i  id=\"event-panel-search-button\"\n                    class=\"action-bar-button fa fa-search fa-fw\"\n                    v-if=\"state != states.INSERT\"\n                    transition=\"fade\"\n                    @click=\"search_button_clicked()\"></i>\n            </span>\n\n            <h4 class=\"title-text\" v-if=\"state != states.SEARCH\" transition=\"expand-horizontal-fade\"> {{ title }} </h4>\n        </span>\n        <span class=\"action-bar no-select pull-right\">\n            <span class=\"action-container\">\n                <i  id=\"event-panel-filter-button\"\n                    class=\"action-bar-button fa fa-filter fa-fw\"\n                    v-if=\"state != states.INSERT\"\n                    transition=\"fade\"></i>\n            </span>\n\n            <span class=\"action-container\">\n                <i  id=\"event-panel-sort-button\"\n                    :class=\"['action-bar-button', 'fa', 'fa-fw', sort_order == 1 ? 'fa-sort-alpha-asc' : 'fa-sort-alpha-desc']\"\n                    v-if=\"state != states.INSERT\"\n                    transition=\"fade\"\n                    @click=\"sort_order *= -1\"></i>\n            </span>\n\n            <span class=\"action-container\">\n                <i  id=\"event-panel-plus-button\"\n                    class=\"action-bar-button fa fa-plus fa-fw rotate-45\"\n                    @click=\"plus_button_clicked()\"\n                    :class=\"{'rotate-45-enter': state != states.NORMAL}\"></i>\n            </span>\n        </span>\n    </div>\n    <div id=\"events-panel-list\" class=\"list-body u-full-width\" v-el:list>\n        <ul>\n            <li v-for=\"event in calendar.events | filterBy search_query in 'name' 'notes' | orderBy 'name' sort_order\"\n                class=\"event-item no-select\"\n                :class=\"{'selected': event == selected_event}\"\n                draggable=\"true\"\n                v-on:dragstart=\"selected_event = event\"\n                v-on:dragend=\"selected_event = null\"\n                @click=\"selected_event = selected_event == event ? null : event\">\n\n                <span class=\"list-item-text\"> {{ event.name }} </span>\n                <span class=\"event-button info-button pull-right\" >\n                    <i class=\"fa fa-info fa-fw\"></i>\n                </span>\n                <span class=\"event-button edit-button pull-right\" >\n                    <i class=\"fa fa-pencil fa-fw\"></i>\n                </span>\n            </li>\n        </ul>\n\n        <div v-if=\"state == states.INSERT\" transition=\"shade\"></div>\n        <div v-if=\"state == states.INSERT\" transition=\"drop-down\">\n            <insert-event-panel\n                :calendar=\"calendar\"\n                v-on:completed=\"handle_insert_completion\"></insert-event-panel>\n        </div>\n    </div>\n\n</div>\n";
});

_removeDefine();
})();
$__System.register("80", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("81", [], function() {
  return "<!-- TemplateName -->\n<div class=\"InsertEventPanel\">\n    <!-- Content -->\n    <form class=\"main-form\">\n        <div id=\"insert-event-panel-name-required\" :class=\"{'required': !event.name}\">\n            <input\n                v-el:name\n                id=\"insert-event-panel-name\"\n                class=\"u-full-width\"\n                type=\"text\"\n                placeholder=\"name\"\n                v-model=\"event.name\"\n                @keyup.esc=\"event.name ? event.name = '' : $emit('completed')\">\n        </div>\n        <textarea\n                id=\"insert-event-panel-note\"\n                class=\"u-full-width\"\n                placeholder=\"notes\"\n                v-model=\"event.notes\"\n                @keyup.esc=\"event.notes ? event.notes = '' : $emit('completed')\"></textarea>\n        <input\n                id=\"insert-event-submit\"\n                class=\"button-primary u-full-width\"\n                type=\"submit\"\n                value=\"Create\"\n                v-bind:disabled=\"!valid_event\"\n                @click=\"insert_event(event)\">\n    </form>\n</div>";
});

_removeDefine();
})();
$__System.register('82', ['12', '80', '81'], function (_export) {
    'use strict';

    var Vue, tmpl;
    return {
        setters: [function (_3) {
            Vue = _3['default'];
        }, function (_) {}, function (_2) {
            tmpl = _2['default'];
        }],
        execute: function () {
            _export('default', Vue.extend({
                template: tmpl,
                components: {},
                props: ["calendar", "completed"],
                data: function data() {
                    return {
                        event: {
                            name: null,
                            notes: null,
                            start_date: null,
                            end_date: null,
                            required_hours: null
                        }
                    };
                },
                ready: function ready() {
                    this.$els.name.focus();
                },
                methods: {
                    insert_event: function insert_event(event) {
                        var _this = this;

                        event.calendar_id = this.calendar.id;
                        this.$root.control.insert_event(event, function (error) {
                            if (!error) _this.$emit('completed');
                        });
                    }
                },
                computed: {
                    valid_event: function valid_event() {
                        return this.event.name ? true : false;
                    }
                }
            }));
        }
    };
});
$__System.register('83', ['12', '82', '7e', '7f'], function (_export) {
    'use strict';

    var Vue, InsertEventPanel, tmpl;
    return {
        setters: [function (_) {
            Vue = _['default'];
        }, function (_2) {
            InsertEventPanel = _2['default'];
        }, function (_e) {}, function (_f) {
            tmpl = _f['default'];
        }],
        execute: function () {
            _export('default', Vue.extend({
                template: tmpl,
                components: {
                    'insert-event-panel': InsertEventPanel
                },
                props: ['calendar'],
                data: function data() {
                    return {
                        title: 'Events',
                        state: 0,
                        states: {
                            NORMAL: 0,
                            INSERT: 1,
                            SEARCH: 2
                        },
                        search_query: null,
                        sort_order: 1,
                        selected_event: null
                    };
                },
                ready: function ready() {
                    this.$root.control.get_events(this.calendar);

                    Vue.nextTick(this.resize_list);
                },
                methods: {
                    resize_list: function resize_list() {
                        var panel_height = this.$els.panel.offsetHeight,
                            header_height = this.$els.header.offsetHeight,
                            list_height = panel_height - header_height - 1; // takes 1px off to resolve rounding error

                        this.$els.list.style.height = list_height + "px";
                    },
                    handle_insert_completion: function handle_insert_completion() {
                        this.state = this.states.NORMAL;
                    },
                    plus_button_clicked: function plus_button_clicked() {
                        if (this.state == this.states.NORMAL) {
                            this.state = this.states.INSERT;
                        } else if (this.state == this.states.SEARCH) {
                            this.search_query = '';
                            this.state = this.states.NORMAL;
                        } else {
                            this.state = this.states.NORMAL;
                        }
                    },
                    search_button_clicked: function search_button_clicked() {
                        var _this = this;

                        this.state = this.states.SEARCH;
                        this.$nextTick(function () {
                            _this.$els.search.focus();
                        });
                    }
                },
                computed: {},
                events: {
                    resize: function resize(size) {
                        this.resize_list();
                        return true;
                    }
                },
                watch: {}
            }));
        }
    };
});
$__System.register("84", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("85", [], function() {
  return "\n<div class=\"ResourcesPanel\" v-el:panel>\n\n    <div class=\"list-header u-full-width\" v-el:header>\n        <span id=\"resource-panel-title\" class=\"panel-title\">\n            <input\n                v-el:search\n                class=\"action-bar-search pull-right\"\n                type=\"text\"\n                v-if=\"state == states.SEARCH\"\n                transition=\"expand-horizontal-fade\"\n                v-model=\"search_query\"\n                placeholder=\"search\"\n                @keyup.esc=\"search_query ? search_query = '' : state = states.NORMAL\">\n            <span class=\"action-container search-action pull-right\">\n                <i  id=\"resource-panel-search-button\"\n                    class=\"action-bar-button fa fa-search fa-fw\"\n                    v-if=\"state != states.INSERT\"\n                    transition=\"fade\"\n                    @click=\"search_button_clicked()\"></i>\n            </span>\n\n            <h4 class=\"title-text\" v-if=\"state != states.SEARCH\" transition=\"expand-horizontal-fade\"> {{ title }} </h4>\n        </span>\n        <span class=\"action-bar no-select pull-right\">\n            <span class=\"action-container\">\n                <i  id=\"resource-panel-filter-button\"\n                    class=\"action-bar-button fa fa-filter fa-fw\"\n                    v-if=\"state != states.INSERT\"\n                    transition=\"fade\"></i>\n            </span>\n\n            <span class=\"action-container\">\n                <i  id=\"resource-panel-sort-button\"\n                    :class=\"['action-bar-button', 'fa', 'fa-fw', sort_order == 1 ? 'fa-sort-alpha-asc' : 'fa-sort-alpha-desc']\"\n                    v-if=\"state != states.INSERT\"\n                    transition=\"fade\"\n                    @click=\"sort_order *= -1\"></i>\n            </span>\n\n            <span class=\"action-container\">\n                <i  id=\"resource-panel-plus-button\"\n                    class=\"action-bar-button fa fa-plus fa-fw rotate-45\"\n                    @click=\"plus_button_clicked()\"\n                    :class=\"{'rotate-45-enter': state != states.NORMAL}\"></i>\n            </span>\n        </span>\n    </div>\n    <div id=\"resources-panel-list\" class=\"list-body u-full-width\" v-el:list>\n        <ul>\n            <li v-for=\"resource in display_resources\"\n                class=\"resource-item no-select\"\n                :class=\"{'selected': selected_resources.indexOf(resource) != -1}\"\n                draggable=\"true\"\n                v-on:dragstart=\"drag_start(resource)\"\n                v-on:dragend=\"selected_resources.empty()\"\n                @click=\"select_resource(resource)\" >\n\n                <span class=\"list-item-text\"> {{ resource.name }} </span>\n                <span class=\"resource-button info-button pull-right\" >\n                    <i class=\"fa fa-info fa-fw\"></i>\n                </span>\n                <span class=\"resource-button edit-button pull-right\" >\n                    <i class=\"fa fa-pencil fa-fw\"></i>\n                </span>\n            </li>\n        </ul>\n\n\n        <div v-if=\"state == states.INSERT\" transition=\"shade\"></div>\n        <div v-if=\"state == states.INSERT\" transition=\"drop-down\">\n            <insert-resource-panel\n                :calendar=\"calendar\"\n                v-on:completed=\"handle_insert_completion\"></insert-resource-panel>\n        </div>\n    </div>\n\n</div>\n";
});

_removeDefine();
})();
$__System.register("86", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("87", [], function() {
  return "<!-- TemplateName -->\n<div class=\"InsertResourcePanel\">\n    <!-- Content -->\n    <form class=\"main-form\">\n        <div id=\"insert-resource-panel-name-required\" class=\"required\">\n            <input\n                id=\"insert-resource-panel-name\"\n                class=\"u-full-width\"\n                type=\"text\"\n                placeholder=\"name\"\n                v-model=\"resource.name\"\n                @keyup.esc=\"resource.name ? resource.name = '' : $emit('completed')\">\n        </div>\n        <input\n                id=\"insert-resource-submit\"\n                class=\"button-primary u-full-width\"\n                type=\"submit\"\n                value=\"Create\"\n                @click=\"insert_resource(resource)\">\n    </form>\n</div>\n";
});

_removeDefine();
})();
$__System.register('88', ['12', '86', '87'], function (_export) {
    'use strict';

    var Vue, tmpl;
    return {
        setters: [function (_3) {
            Vue = _3['default'];
        }, function (_) {}, function (_2) {
            tmpl = _2['default'];
        }],
        execute: function () {
            _export('default', Vue.extend({
                template: tmpl,
                components: {},
                props: ["calendar", "completed"],
                data: function data() {
                    return {
                        resource: {
                            name: null,
                            tags: null
                        }
                    };
                },
                ready: function ready() {},
                methods: {
                    insert_resource: function insert_resource(resource) {
                        var _this = this;

                        resource.calendar_id = this.calendar.id;
                        this.$root.control.insert_resource(resource, function (error) {
                            if (!error) _this.$emit('completed');
                        });
                    }
                },
                computed: {},
                watch: {},
                events: {}
            }));
        }
    };
});
$__System.register("89", [], function (_export) {
    "use strict";

    var operating_systems;

    _export("parse_os_from_user_agent", parse_os_from_user_agent);

    function parse_os_from_user_agent(user_agent) {
        user_agent = user_agent.toLowerCase();

        if (/windows/.test(user_agent)) {
            return operating_systems.WINDOWS;
        } else if (/linux|ubuntu/.test(user_agent)) {
            return operating_systems.LINUX;
        } else if (/osx|os x|mac/.test(user_agent)) {
            return operating_systems.OSX;
        } else {
            return operating_systems.UNKNOWN;
        }
    }

    return {
        setters: [],
        execute: function () {
            operating_systems = {
                UNKNOWN: 0,
                WINDOWS: 1,
                LINUX: 2,
                OSX: 3
            };

            _export("operating_systems", operating_systems);
        }
    };
});
$__System.register("8a", [], function (_export) {
    "use strict";

    var key_codes;
    return {
        setters: [],
        execute: function () {
            key_codes = {
                CTRL: 17,
                CMD: 91,
                SHIFT: 16
            };

            _export("key_codes", key_codes);
        }
    };
});
$__System.register('8b', ['12', '84', '85', '88', '89', '8a'], function (_export) {
    'use strict';

    var Vue, tmpl, InsertResourcePanel, systems, key_codes;
    return {
        setters: [function (_3) {
            Vue = _3['default'];
        }, function (_) {}, function (_2) {
            tmpl = _2['default'];
        }, function (_4) {
            InsertResourcePanel = _4['default'];
        }, function (_5) {
            systems = _5;
        }, function (_a) {
            key_codes = _a.key_codes;
        }],
        execute: function () {
            _export('default', Vue.extend({
                template: tmpl,
                components: {
                    'insert-resource-panel': InsertResourcePanel
                },
                props: ['calendar'],
                data: function data() {
                    return {
                        title: 'Resources',
                        state: 0,
                        states: {
                            NORMAL: 0,
                            INSERT: 1,
                            SEARCH: 2
                        },
                        search_query: null,
                        sort_order: 1,
                        selected_resources: []
                    };
                },
                ready: function ready() {
                    this.$root.control.get_resources(this.calendar);

                    Vue.nextTick(this.resize_list);
                },
                methods: {
                    resize_list: function resize_list() {
                        var panel_height = this.$els.panel.offsetHeight,
                            header_height = this.$els.header.offsetHeight,
                            list_height = panel_height - header_height - 1; // take 1px off to resolve rounding error

                        this.$els.list.style.height = list_height + "px";
                    },
                    handle_insert_completion: function handle_insert_completion() {
                        this.state = this.states.NORMAL;
                    },
                    plus_button_clicked: function plus_button_clicked() {
                        if (this.state == this.states.NORMAL) {
                            this.state = this.states.INSERT;
                        } else if (this.state == this.states.SEARCH) {
                            this.search_query = '';
                            this.state = this.states.NORMAL;
                        } else {
                            this.state = this.states.NORMAL;
                        }
                    },
                    search_button_clicked: function search_button_clicked() {
                        var _this = this;

                        this.state = this.states.SEARCH;
                        this.$nextTick(function () {
                            _this.$els.search.focus();
                        });
                    },
                    drag_start: function drag_start(resource) {
                        // Make resources only selected if not alraedy part of selected list (otherwise take all selected)
                        if (!this.selected_resources.has(resource)) {
                            this.selected_resources.empty();
                            this.selected_resources.set(resource);
                        }
                    },
                    select_resource: function select_resource(resource, resources) {
                        // TODO: what if resource is removed by server. needto add watcher to listen for that event here and remove obj from selected
                        var osx_client = this.$root.user_os == systems.operating_systems.OSX,
                            keys_down = this.$root.keys_down,
                            selected = this.selected_resources,
                            add = osx_client ? keys_down.has(key_codes.CMD) : keys_down.has(key_codes.CTRL);
                        // add resource - cmd (os x) or ctrl (other os) and only key pressed
                        if (add && keys_down.length == 1) {
                            // deselect or seelc bepending if already seelcted
                            if (selected.has(resource)) selected.remove(resource);else selected.set(resource);
                        }
                        // add _to_ resource (shift)
                        else if (keys_down.has(key_codes.SHIFT) && keys_down.length == 1) {
                                // Get the index of the last selected item (if none then go from the top of the list)
                                var last_selected = selected.lastIndex != -1 ? selected.last() : this.display_resources[0],
                                    last_index = this.display_resources.indexOf(last_selected),
                                    current_index = this.display_resources.indexOf(resource),
                                    ordered_index = [last_index, current_index].sort(),
                                    new_resources = this.display_resources.slice(ordered_index[0], ordered_index[1] + 1);

                                new_resources.map(function (r) {
                                    return selected.set(r);
                                });
                            }
                            // select resource
                            else {
                                    // deselect if only one already selected
                                    if (selected.has(resource) && selected.length == 1) {
                                        selected.remove(resource);
                                    } else {
                                        selected.empty();
                                        selected.set(resource);
                                    }
                                }
                    }
                },
                computed: {
                    display_resources: function display_resources() {
                        // TODO: sort and filter programatically  | filterBy search_query in 'name' 'notes' | orderBy 'name' sort_order"
                        var filter_by = Vue.options.filters['filterBy'],
                            order_by = Vue.options.filters['orderBy'],
                            result = this.calendar.resources;

                        result = filter_by(result, this.search_query, ['name', 'notes']), result = order_by(result, 'name', this.sort_order);

                        return result;
                    }
                },
                watch: {},
                events: {
                    resize: function resize(size) {
                        this.resize_list();
                        return true;
                    }
                }
            }));
        }
    };
});
$__System.register('8c', ['12', '43', '44', '83', '7d', '8b'], function (_export) {
    'use strict';

    var Vue, tmpl, EventsPanel, CalendarPanel, ResourcesPanel;
    return {
        setters: [function (_3) {
            Vue = _3['default'];
        }, function (_) {}, function (_2) {
            tmpl = _2['default'];
        }, function (_4) {
            EventsPanel = _4['default'];
        }, function (_d) {
            CalendarPanel = _d['default'];
        }, function (_b) {
            ResourcesPanel = _b['default'];
        }],
        execute: function () {
            _export('default', Vue.extend({
                template: tmpl,
                components: {
                    'calendar-panel': CalendarPanel,
                    'events-panel': EventsPanel,
                    'resources-panel': ResourcesPanel
                },
                props: ['calendars'],
                data: function data() {
                    return {};
                },
                ready: function ready() {
                    this.$root.control.get_calendars();
                },
                route: {},
                methods: {},
                computed: {
                    selected_calendar: function selected_calendar() {
                        var url_id = this.$route.params.calendar_id;
                        return this.calendars ? this.calendars.find(function (cal) {
                            return cal.id == url_id;
                        }) : null;
                    }
                },
                watch: {},
                events: {}
            }));
        }
    };
});
$__System.register("8d", [], function() { return { setters: [], execute: function() {} } });

(function() {
var _removeDefine = $__System.get("@@amd-helpers").createDefine();
define("8e", [], function() {
  return "<div class=\"LoginPanel\" v-el:panel>\n\n    <form class=\"login-panel-form login-form\" @submit.stop.prevent=\"login\">\n        <img class=\"u-full-width\" src=\"/images/a2zcloud.png\" v-el:logo>\n\n        <input class=\"u-full-width\" type=\"text\" placeholder=\"username\" name=\"username\" v-model=\"username\" />\n\n        <input class=\"u-full-width\" type=\"password\" name=\"password\" placeholder=\"password\" v-model=\"password\" />\n\n        <button class=\"button button-primary u-full-width\" type=\"submit\">Sign In</button>\n    </form>\n\n    <div class=\"error\" v-if=\"error_message\"> {{error_message}} </div>\n\n</div>\n";
});

_removeDefine();
})();
$__System.register('8f', ['12', '8d', '8e'], function (_export) {
    'use strict';

    var Vue, tmpl;
    return {
        setters: [function (_) {
            Vue = _['default'];
        }, function (_d) {}, function (_e) {
            tmpl = _e['default'];
        }],
        execute: function () {
            _export('default', Vue.extend({
                template: tmpl,
                data: function data() {
                    return {
                        username: null,
                        password: null,
                        pending_request: false,
                        error_message: null
                    };
                },
                ready: function ready() {
                    this.resize(this.$root.window_size());
                },
                methods: {
                    resize: function resize(size) {
                        // Make panel full height
                        this.$els.panel.style.height = size.height + "px";
                        // Pull loging down the page
                        this.$els.logo.style.paddingTop = size.height / 10 + "px";
                    },
                    login: function login() {
                        var _this = this;

                        this.pending_request = true;
                        this.error_message = null;

                        this.$root.control.login(this.username, this.password, function (error_message) {
                            _this.error_message = error_message;
                        });
                    }
                },
                computed: {},
                watch: {},
                events: {
                    resize: 'resize'
                }
            }));
        }
    };
});
$__System.register("90", [], function (_export) {
  /*\
  |*|
  |*|  :: cookies.js ::
  |*|
  |*|  A complete cookies reader/writer framework with full unicode support.
  |*|
  |*|  Revision #1 - September 4, 2014
  |*|
  |*|  https://developer.mozilla.org/en-US/docs/Web/API/document.cookie
  |*|  https://developer.mozilla.org/User:fusionchess
  |*|
  |*|  This framework is released under the GNU Public License, version 3 or later.
  |*|  http://www.gnu.org/licenses/gpl-3.0-standalone.html
  |*|
  |*|  Syntaxes:
  |*|
  |*|  * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])
  |*|  * docCookies.getItem(name)
  |*|  * docCookies.removeItem(name[, path[, domain]])
  |*|  * docCookies.hasItem(name)
  |*|  * docCookies.keys()
  |*|
  \*/

  "use strict";

  var docCookies;
  return {
    setters: [],
    execute: function () {
      docCookies = {
        getItem: function getItem(sKey) {
          if (!sKey) {
            return null;
          }
          return decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
        },
        setItem: function setItem(sKey, sValue, vEnd, sPath, sDomain, bSecure) {
          if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) {
            return false;
          }
          var sExpires = "";
          if (vEnd) {
            switch (vEnd.constructor) {
              case Number:
                sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
                break;
              case String:
                sExpires = "; expires=" + vEnd;
                break;
              case Date:
                sExpires = "; expires=" + vEnd.toUTCString();
                break;
            }
          }
          document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
          return true;
        },
        removeItem: function removeItem(sKey, sPath, sDomain) {
          if (!this.hasItem(sKey)) {
            return false;
          }
          document.cookie = encodeURIComponent(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT" + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "");
          return true;
        },
        hasItem: function hasItem(sKey) {
          if (!sKey) {
            return false;
          }
          return new RegExp("(?:^|;\\s*)" + encodeURIComponent(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(document.cookie);
        },
        keys: function keys() {
          var aKeys = document.cookie.replace(/((?:^|\s*;)[^\=]+)(?=;|$)|^\s*|\s*(?:\=[^;]*)?(?:\1|$)/g, "").split(/\s*(?:\=[^;]*)?;\s*/);
          for (var nLen = aKeys.length, nIdx = 0; nIdx < nLen; nIdx++) {
            aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]);
          }
          return aKeys;
        }
      };

      _export("default", docCookies);
    }
  };
});
$__System.registerDynamic("91", ["5a", "25"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = req('5a');
  req('25')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("92", ["13", "91"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = req('13');
  req('91');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("93", ["92"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('92'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("94", ["93"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$getOwnPropertyDescriptor = req('93')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("95", ["13", "1e", "5f", "22"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var getDesc = req('13').getDesc,
      isObject = req('1e'),
      anObject = req('5f');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = req('22')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("96", ["23", "95"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $export = req('23');
  $export($export.S, 'Object', {setPrototypeOf: req('95').set});
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("97", ["96", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('96');
  module.exports = req('20').Object.setPrototypeOf;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("98", ["97"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('97'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("99", ["19", "98"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _Object$create = req('19')["default"];
  var _Object$setPrototypeOf = req('98')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9a", ["63", "51", "4e", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var classof = req('63'),
      ITERATOR = req('51')('iterator'),
      Iterators = req('4e');
  module.exports = req('20').isIterable = function(it) {
    var O = Object(it);
    return O[ITERATOR] !== undefined || '@@iterator' in O || Iterators.hasOwnProperty(classof(O));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9b", ["5c", "55", "9a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('5c');
  req('55');
  module.exports = req('9a');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9c", ["9b"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('9b'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9d", ["70", "9c"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "use strict";
  var _getIterator = req('70')["default"];
  var _isIterable = req('9c')["default"];
  exports["default"] = (function() {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;
      try {
        for (var _i = _getIterator(arr),
            _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);
          if (i && _arr.length === i)
            break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"])
            _i["return"]();
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
    return function(arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (_isIterable(Object(arr))) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  })();
  exports.__esModule = true;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9e", ["13", "5a"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = req('13'),
      toIObject = req('5a');
  module.exports = function(object, el) {
    var O = toIObject(object),
        keys = $.getKeys(O),
        length = keys.length,
        index = 0,
        key;
    while (length > index)
      if (O[key = keys[index++]] === el)
        return key;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("9f", ["5a", "13"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var toIObject = req('5a'),
      getNames = req('13').getNames,
      toString = {}.toString;
  var windowNames = typeof window == 'object' && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
  var getWindowNames = function(it) {
    try {
      return getNames(it);
    } catch (e) {
      return windowNames.slice();
    }
  };
  module.exports.get = function getOwnPropertyNames(it) {
    if (windowNames && toString.call(it) == '[object Window]')
      return getWindowNames(it);
    return getNames(toIObject(it));
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a0", ["13"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var $ = req('13');
  module.exports = function(it) {
    var keys = $.getKeys(it),
        getSymbols = $.getSymbols;
    if (getSymbols) {
      var symbols = getSymbols(it),
          isEnum = $.isEnum,
          i = 0,
          key;
      while (symbols.length > i)
        if (isEnum.call(it, key = symbols[i++]))
          keys.push(key);
    }
    return keys;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a1", ["58"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var cof = req('58');
  module.exports = Array.isArray || function(arg) {
    return cof(arg) == 'Array';
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a2", ["13", "1f", "4d", "4a", "23", "4c", "24", "4f", "52", "50", "51", "9e", "9f", "a0", "a1", "5f", "5a", "49", "48"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  var $ = req('13'),
      global = req('1f'),
      has = req('4d'),
      DESCRIPTORS = req('4a'),
      $export = req('23'),
      redefine = req('4c'),
      $fails = req('24'),
      shared = req('4f'),
      setToStringTag = req('52'),
      uid = req('50'),
      wks = req('51'),
      keyOf = req('9e'),
      $names = req('9f'),
      enumKeys = req('a0'),
      isArray = req('a1'),
      anObject = req('5f'),
      toIObject = req('5a'),
      createDesc = req('49'),
      getDesc = $.getDesc,
      setDesc = $.setDesc,
      _create = $.create,
      getNames = $names.get,
      $Symbol = global.Symbol,
      $JSON = global.JSON,
      _stringify = $JSON && $JSON.stringify,
      setter = false,
      HIDDEN = wks('_hidden'),
      isEnum = $.isEnum,
      SymbolRegistry = shared('symbol-registry'),
      AllSymbols = shared('symbols'),
      useNative = typeof $Symbol == 'function',
      ObjectProto = Object.prototype;
  var setSymbolDesc = DESCRIPTORS && $fails(function() {
    return _create(setDesc({}, 'a', {get: function() {
        return setDesc(this, 'a', {value: 7}).a;
      }})).a != 7;
  }) ? function(it, key, D) {
    var protoDesc = getDesc(ObjectProto, key);
    if (protoDesc)
      delete ObjectProto[key];
    setDesc(it, key, D);
    if (protoDesc && it !== ObjectProto)
      setDesc(ObjectProto, key, protoDesc);
  } : setDesc;
  var wrap = function(tag) {
    var sym = AllSymbols[tag] = _create($Symbol.prototype);
    sym._k = tag;
    DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: function(value) {
        if (has(this, HIDDEN) && has(this[HIDDEN], tag))
          this[HIDDEN][tag] = false;
        setSymbolDesc(this, tag, createDesc(1, value));
      }
    });
    return sym;
  };
  var isSymbol = function(it) {
    return typeof it == 'symbol';
  };
  var $defineProperty = function defineProperty(it, key, D) {
    if (D && has(AllSymbols, key)) {
      if (!D.enumerable) {
        if (!has(it, HIDDEN))
          setDesc(it, HIDDEN, createDesc(1, {}));
        it[HIDDEN][key] = true;
      } else {
        if (has(it, HIDDEN) && it[HIDDEN][key])
          it[HIDDEN][key] = false;
        D = _create(D, {enumerable: createDesc(0, false)});
      }
      return setSymbolDesc(it, key, D);
    }
    return setDesc(it, key, D);
  };
  var $defineProperties = function defineProperties(it, P) {
    anObject(it);
    var keys = enumKeys(P = toIObject(P)),
        i = 0,
        l = keys.length,
        key;
    while (l > i)
      $defineProperty(it, key = keys[i++], P[key]);
    return it;
  };
  var $create = function create(it, P) {
    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
  };
  var $propertyIsEnumerable = function propertyIsEnumerable(key) {
    var E = isEnum.call(this, key);
    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
  };
  var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
    var D = getDesc(it = toIObject(it), key);
    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
      D.enumerable = true;
    return D;
  };
  var $getOwnPropertyNames = function getOwnPropertyNames(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (!has(AllSymbols, key = names[i++]) && key != HIDDEN)
        result.push(key);
    return result;
  };
  var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
    var names = getNames(toIObject(it)),
        result = [],
        i = 0,
        key;
    while (names.length > i)
      if (has(AllSymbols, key = names[i++]))
        result.push(AllSymbols[key]);
    return result;
  };
  var $stringify = function stringify(it) {
    if (it === undefined || isSymbol(it))
      return;
    var args = [it],
        i = 1,
        $$ = arguments,
        replacer,
        $replacer;
    while ($$.length > i)
      args.push($$[i++]);
    replacer = args[1];
    if (typeof replacer == 'function')
      $replacer = replacer;
    if ($replacer || !isArray(replacer))
      replacer = function(key, value) {
        if ($replacer)
          value = $replacer.call(this, key, value);
        if (!isSymbol(value))
          return value;
      };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  };
  var buggyJSON = $fails(function() {
    var S = $Symbol();
    return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
  });
  if (!useNative) {
    $Symbol = function Symbol() {
      if (isSymbol(this))
        throw TypeError('Symbol is not a constructor');
      return wrap(uid(arguments.length > 0 ? arguments[0] : undefined));
    };
    redefine($Symbol.prototype, 'toString', function toString() {
      return this._k;
    });
    isSymbol = function(it) {
      return it instanceof $Symbol;
    };
    $.create = $create;
    $.isEnum = $propertyIsEnumerable;
    $.getDesc = $getOwnPropertyDescriptor;
    $.setDesc = $defineProperty;
    $.setDescs = $defineProperties;
    $.getNames = $names.get = $getOwnPropertyNames;
    $.getSymbols = $getOwnPropertySymbols;
    if (DESCRIPTORS && !req('48')) {
      redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
    }
  }
  var symbolStatics = {
    'for': function(key) {
      return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
    },
    keyFor: function keyFor(key) {
      return keyOf(SymbolRegistry, key);
    },
    useSetter: function() {
      setter = true;
    },
    useSimple: function() {
      setter = false;
    }
  };
  $.each.call(('hasInstance,isConcatSpreadable,iterator,match,replace,search,' + 'species,split,toPrimitive,toStringTag,unscopables').split(','), function(it) {
    var sym = wks(it);
    symbolStatics[it] = useNative ? sym : wrap(sym);
  });
  setter = true;
  $export($export.G + $export.W, {Symbol: $Symbol});
  $export($export.S, 'Symbol', symbolStatics);
  $export($export.S + $export.F * !useNative, 'Object', {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
  });
  $JSON && $export($export.S + $export.F * (!useNative || buggyJSON), 'JSON', {stringify: $stringify});
  setToStringTag($Symbol, 'Symbol');
  setToStringTag(Math, 'Math', true);
  setToStringTag(global.JSON, 'JSON', true);
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a3", ["a2", "45", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('a2');
  req('45');
  module.exports = req('20').Symbol;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a4", ["a3"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('a3');
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a5", ["a4"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('a4'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a6", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = Object.is || function is(x, y) {
    return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a7", ["5f", "21", "51"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var anObject = req('5f'),
      aFunction = req('21'),
      SPECIES = req('51')('species');
  module.exports = function(O, D) {
    var C = anObject(O).constructor,
        S;
    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a8", [], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = function(fn, args, that) {
    var un = that === undefined;
    switch (args.length) {
      case 0:
        return un ? fn() : fn.call(that);
      case 1:
        return un ? fn(args[0]) : fn.call(that, args[0]);
      case 2:
        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
      case 3:
        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
      case 4:
        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
    }
    return fn.apply(that, args);
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("a9", ["1f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('1f').document && document.documentElement;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("aa", ["1e", "1f"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var isObject = req('1e'),
      document = req('1f').document,
      is = isObject(document) && isObject(document.createElement);
  module.exports = function(it) {
    return is ? document.createElement(it) : {};
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ab", ["22", "a8", "a9", "aa", "1f", "58", "10"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var ctx = req('22'),
        invoke = req('a8'),
        html = req('a9'),
        cel = req('aa'),
        global = req('1f'),
        process = global.process,
        setTask = global.setImmediate,
        clearTask = global.clearImmediate,
        MessageChannel = global.MessageChannel,
        counter = 0,
        queue = {},
        ONREADYSTATECHANGE = 'onreadystatechange',
        defer,
        channel,
        port;
    var run = function() {
      var id = +this;
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };
    var listner = function(event) {
      run.call(event.data);
    };
    if (!setTask || !clearTask) {
      setTask = function setImmediate(fn) {
        var args = [],
            i = 1;
        while (arguments.length > i)
          args.push(arguments[i++]);
        queue[++counter] = function() {
          invoke(typeof fn == 'function' ? fn : Function(fn), args);
        };
        defer(counter);
        return counter;
      };
      clearTask = function clearImmediate(id) {
        delete queue[id];
      };
      if (req('58')(process) == 'process') {
        defer = function(id) {
          process.nextTick(ctx(run, id, 1));
        };
      } else if (MessageChannel) {
        channel = new MessageChannel;
        port = channel.port2;
        channel.port1.onmessage = listner;
        defer = ctx(port.postMessage, port, 1);
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
        defer = function(id) {
          global.postMessage(id + '', '*');
        };
        global.addEventListener('message', listner, false);
      } else if (ONREADYSTATECHANGE in cel('script')) {
        defer = function(id) {
          html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function() {
            html.removeChild(this);
            run.call(id);
          };
        };
      } else {
        defer = function(id) {
          setTimeout(ctx(run, id, 1), 0);
        };
      }
    }
    module.exports = {
      set: setTask,
      clear: clearTask
    };
  })(req('10'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ac", ["1f", "ab", "58", "10"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    var global = req('1f'),
        macrotask = req('ab').set,
        Observer = global.MutationObserver || global.WebKitMutationObserver,
        process = global.process,
        Promise = global.Promise,
        isNode = req('58')(process) == 'process',
        head,
        last,
        notify;
    var flush = function() {
      var parent,
          domain,
          fn;
      if (isNode && (parent = process.domain)) {
        process.domain = null;
        parent.exit();
      }
      while (head) {
        domain = head.domain;
        fn = head.fn;
        if (domain)
          domain.enter();
        fn();
        if (domain)
          domain.exit();
        head = head.next;
      }
      last = undefined;
      if (parent)
        parent.enter();
    };
    if (isNode) {
      notify = function() {
        process.nextTick(flush);
      };
    } else if (Observer) {
      var toggle = 1,
          node = document.createTextNode('');
      new Observer(flush).observe(node, {characterData: true});
      notify = function() {
        node.data = toggle = -toggle;
      };
    } else if (Promise && Promise.resolve) {
      notify = function() {
        Promise.resolve().then(flush);
      };
    } else {
      notify = function() {
        macrotask.call(global, flush);
      };
    }
    module.exports = function asap(fn) {
      var task = {
        fn: fn,
        next: undefined,
        domain: isNode && process.domain
      };
      if (last)
        last.next = task;
      if (!head) {
        head = task;
        notify();
      }
      last = task;
    };
  })(req('10'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ad", ["13", "48", "1f", "22", "63", "23", "1e", "5f", "21", "5e", "65", "95", "a6", "51", "a7", "ac", "4a", "5d", "52", "66", "20", "71", "10"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    'use strict';
    var $ = req('13'),
        LIBRARY = req('48'),
        global = req('1f'),
        ctx = req('22'),
        classof = req('63'),
        $export = req('23'),
        isObject = req('1e'),
        anObject = req('5f'),
        aFunction = req('21'),
        strictNew = req('5e'),
        forOf = req('65'),
        setProto = req('95').set,
        same = req('a6'),
        SPECIES = req('51')('species'),
        speciesConstructor = req('a7'),
        asap = req('ac'),
        PROMISE = 'Promise',
        process = global.process,
        isNode = classof(process) == 'process',
        P = global[PROMISE],
        Wrapper;
    var testResolve = function(sub) {
      var test = new P(function() {});
      if (sub)
        test.constructor = Object;
      return P.resolve(test) === test;
    };
    var USE_NATIVE = function() {
      var works = false;
      function P2(x) {
        var self = new P(x);
        setProto(self, P2.prototype);
        return self;
      }
      try {
        works = P && P.resolve && testResolve();
        setProto(P2, P);
        P2.prototype = $.create(P.prototype, {constructor: {value: P2}});
        if (!(P2.resolve(5).then(function() {}) instanceof P2)) {
          works = false;
        }
        if (works && req('4a')) {
          var thenableThenGotten = false;
          P.resolve($.setDesc({}, 'then', {get: function() {
              thenableThenGotten = true;
            }}));
          works = thenableThenGotten;
        }
      } catch (e) {
        works = false;
      }
      return works;
    }();
    var sameConstructor = function(a, b) {
      if (LIBRARY && a === P && b === Wrapper)
        return true;
      return same(a, b);
    };
    var getConstructor = function(C) {
      var S = anObject(C)[SPECIES];
      return S != undefined ? S : C;
    };
    var isThenable = function(it) {
      var then;
      return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
    };
    var PromiseCapability = function(C) {
      var resolve,
          reject;
      this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined)
          throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve), this.reject = aFunction(reject);
    };
    var perform = function(exec) {
      try {
        exec();
      } catch (e) {
        return {error: e};
      }
    };
    var notify = function(record, isReject) {
      if (record.n)
        return;
      record.n = true;
      var chain = record.c;
      asap(function() {
        var value = record.v,
            ok = record.s == 1,
            i = 0;
        var run = function(reaction) {
          var handler = ok ? reaction.ok : reaction.fail,
              resolve = reaction.resolve,
              reject = reaction.reject,
              result,
              then;
          try {
            if (handler) {
              if (!ok)
                record.h = true;
              result = handler === true ? value : handler(value);
              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else
                resolve(result);
            } else
              reject(value);
          } catch (e) {
            reject(e);
          }
        };
        while (chain.length > i)
          run(chain[i++]);
        chain.length = 0;
        record.n = false;
        if (isReject)
          setTimeout(function() {
            var promise = record.p,
                handler,
                console;
            if (isUnhandled(promise)) {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }
            record.a = undefined;
          }, 1);
      });
    };
    var isUnhandled = function(promise) {
      var record = promise._d,
          chain = record.a || record.c,
          i = 0,
          reaction;
      if (record.h)
        return false;
      while (chain.length > i) {
        reaction = chain[i++];
        if (reaction.fail || !isUnhandled(reaction.promise))
          return false;
      }
      return true;
    };
    var $reject = function(value) {
      var record = this;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      record.v = value;
      record.s = 2;
      record.a = record.c.slice();
      notify(record, true);
    };
    var $resolve = function(value) {
      var record = this,
          then;
      if (record.d)
        return;
      record.d = true;
      record = record.r || record;
      try {
        if (record.p === value)
          throw TypeError("Promise can't be resolved itself");
        if (then = isThenable(value)) {
          asap(function() {
            var wrapper = {
              r: record,
              d: false
            };
            try {
              then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
            } catch (e) {
              $reject.call(wrapper, e);
            }
          });
        } else {
          record.v = value;
          record.s = 1;
          notify(record, false);
        }
      } catch (e) {
        $reject.call({
          r: record,
          d: false
        }, e);
      }
    };
    if (!USE_NATIVE) {
      P = function Promise(executor) {
        aFunction(executor);
        var record = this._d = {
          p: strictNew(this, P, PROMISE),
          c: [],
          a: undefined,
          s: 0,
          d: false,
          v: undefined,
          h: false,
          n: false
        };
        try {
          executor(ctx($resolve, record, 1), ctx($reject, record, 1));
        } catch (err) {
          $reject.call(record, err);
        }
      };
      req('5d')(P.prototype, {
        then: function then(onFulfilled, onRejected) {
          var reaction = new PromiseCapability(speciesConstructor(this, P)),
              promise = reaction.promise,
              record = this._d;
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          record.c.push(reaction);
          if (record.a)
            record.a.push(reaction);
          if (record.s)
            notify(record, false);
          return promise;
        },
        'catch': function(onRejected) {
          return this.then(undefined, onRejected);
        }
      });
    }
    $export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: P});
    req('52')(P, PROMISE);
    req('66')(PROMISE);
    Wrapper = req('20')[PROMISE];
    $export($export.S + $export.F * !USE_NATIVE, PROMISE, {reject: function reject(r) {
        var capability = new PromiseCapability(this),
            $$reject = capability.reject;
        $$reject(r);
        return capability.promise;
      }});
    $export($export.S + $export.F * (!USE_NATIVE || testResolve(true)), PROMISE, {resolve: function resolve(x) {
        if (x instanceof P && sameConstructor(x.constructor, this))
          return x;
        var capability = new PromiseCapability(this),
            $$resolve = capability.resolve;
        $$resolve(x);
        return capability.promise;
      }});
    $export($export.S + $export.F * !(USE_NATIVE && req('71')(function(iter) {
      P.all(iter)['catch'](function() {});
    })), PROMISE, {
      all: function all(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            resolve = capability.resolve,
            reject = capability.reject,
            values = [];
        var abrupt = perform(function() {
          forOf(iterable, false, values.push, values);
          var remaining = values.length,
              results = Array(remaining);
          if (remaining)
            $.each.call(values, function(promise, index) {
              var alreadyCalled = false;
              C.resolve(promise).then(function(value) {
                if (alreadyCalled)
                  return;
                alreadyCalled = true;
                results[index] = value;
                --remaining || resolve(results);
              }, reject);
            });
          else
            resolve(results);
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      },
      race: function race(iterable) {
        var C = getConstructor(this),
            capability = new PromiseCapability(C),
            reject = capability.reject;
        var abrupt = perform(function() {
          forOf(iterable, false, function(promise) {
            C.resolve(promise).then(capability.resolve, reject);
          });
        });
        if (abrupt)
          reject(abrupt.error);
        return capability.promise;
      }
    });
  })(req('10'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("ae", ["45", "55", "5c", "ad", "20"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  req('45');
  req('55');
  req('5c');
  req('ad');
  module.exports = req('20').Promise;
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("af", ["ae"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = {
    "default": req('ae'),
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b0", ["a5", "19", "98", "af", "10"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  (function(process) {
    "use strict";
    var _Symbol = req('a5')["default"];
    var _Object$create = req('19')["default"];
    var _Object$setPrototypeOf = req('98')["default"];
    var _Promise = req('af')["default"];
    !(function(global) {
      "use strict";
      var hasOwn = Object.prototype.hasOwnProperty;
      var undefined;
      var $Symbol = typeof _Symbol === "function" ? _Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      var inModule = typeof module === "object";
      var runtime = global.regeneratorRuntime;
      if (runtime) {
        if (inModule) {
          module.exports = runtime;
        }
        return;
      }
      runtime = global.regeneratorRuntime = inModule ? module.exports : {};
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var generator = _Object$create((outerFn || Generator).prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }
      runtime.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          prototype[method] = function(arg) {
            return this._invoke(method, arg);
          };
        });
      }
      runtime.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      runtime.mark = function(genFun) {
        if (_Object$setPrototypeOf) {
          _Object$setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = "GeneratorFunction";
          }
        }
        genFun.prototype = _Object$create(Gp);
        return genFun;
      };
      runtime.awrap = function(arg) {
        return new AwaitArgument(arg);
      };
      function AwaitArgument(arg) {
        this.arg = arg;
      }
      function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value instanceof AwaitArgument) {
              return _Promise.resolve(value.arg).then(function(value) {
                invoke("next", value, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return _Promise.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, reject);
          }
        }
        if (typeof process === "object" && process.domain) {
          invoke = process.domain.bind(invoke);
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new _Promise(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      runtime.async = function(innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
        return runtime.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              if (method === "return" || method === "throw" && delegate.iterator[method] === undefined) {
                context.delegate = null;
                var returnMethod = delegate.iterator["return"];
                if (returnMethod) {
                  var record = tryCatch(returnMethod, delegate.iterator, arg);
                  if (record.type === "throw") {
                    method = "throw";
                    arg = record.arg;
                    continue;
                  }
                }
                if (method === "return") {
                  continue;
                }
              }
              var record = tryCatch(delegate.iterator[method], delegate.iterator, arg);
              if (record.type === "throw") {
                context.delegate = null;
                method = "throw";
                arg = record.arg;
                continue;
              }
              method = "next";
              arg = undefined;
              var info = record.arg;
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
              } else {
                state = GenStateSuspendedYield;
                return info;
              }
              context.delegate = null;
            }
            if (method === "next") {
              if (state === GenStateSuspendedYield) {
                context.sent = arg;
              } else {
                context.sent = undefined;
              }
            } else if (method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw arg;
              }
              if (context.dispatchException(arg)) {
                method = "next";
                arg = undefined;
              }
            } else if (method === "return") {
              context.abrupt("return", arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              var info = {
                value: record.arg,
                done: context.done
              };
              if (record.arg === ContinueSentinel) {
                if (context.delegate && method === "next") {
                  arg = undefined;
                }
              } else {
                return info;
              }
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              method = "throw";
              arg = record.arg;
            }
          }
        };
      }
      defineIteratorMethods(Gp);
      Gp[iteratorSymbol] = function() {
        return this;
      };
      Gp[toStringTagSymbol] = "Generator";
      Gp.toString = function() {
        return "[object Generator]";
      };
      function pushTryEntry(locs) {
        var entry = {tryLoc: locs[0]};
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{tryLoc: "root"}];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      runtime.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key = keys.pop();
            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }
                  next.value = undefined;
                  next.done = true;
                  return next;
                };
            return next.next = next;
          }
        }
        return {next: doneResult};
      }
      runtime.values = values;
      function doneResult() {
        return {
          value: undefined,
          done: true
        };
      }
      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = undefined;
          this.done = false;
          this.delegate = null;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.next = finallyEntry.finallyLoc;
          } else {
            this.complete(record);
          }
          return ContinueSentinel;
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = record.arg;
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };
          return ContinueSentinel;
        }
      };
    })(typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : undefined);
  })(req('10'));
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b1", ["b0"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var g = typeof global === "object" ? global : typeof window === "object" ? window : typeof self === "object" ? self : this;
  var hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
  var oldRuntime = hadRuntime && g.regeneratorRuntime;
  g.regeneratorRuntime = undefined;
  module.exports = req('b0');
  if (hadRuntime) {
    g.regeneratorRuntime = oldRuntime;
  } else {
    try {
      delete g.regeneratorRuntime;
    } catch (e) {
      g.regeneratorRuntime = undefined;
    }
  }
  module.exports = {
    "default": module.exports,
    __esModule: true
  };
  global.define = __define;
  return module.exports;
});

$__System.registerDynamic("b2", ["b1"], true, function(req, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = req('b1');
  global.define = __define;
  return module.exports;
});

$__System.register('b3', ['16', '17', '70', '9d', 'b2', '2e', 'b4'], function (_export) {
    var _createClass, _classCallCheck, _getIterator, _slicedToArray, _regeneratorRuntime, _Object$keys, classify, Uniquable;

    return {
        setters: [function (_) {
            _createClass = _['default'];
        }, function (_2) {
            _classCallCheck = _2['default'];
        }, function (_3) {
            _getIterator = _3['default'];
        }, function (_d) {
            _slicedToArray = _d['default'];
        }, function (_b2) {
            _regeneratorRuntime = _b2['default'];
        }, function (_e) {
            _Object$keys = _e['default'];
        }, function (_b4) {
            classify = _b4['default'];
        }],
        execute: function () {

            // const PRIMARY_KEYS = ['id']

            'use strict';

            Uniquable = (function () {
                function Uniquable() {
                    var _surrogate = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

                    _classCallCheck(this, Uniquable);

                    this._primary_keys = ['id'];
                    this.__surrogate = _surrogate;
                }

                _createClass(Uniquable, [{
                    key: 'public_properties',
                    value: _regeneratorRuntime.mark(function public_properties() {
                        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, key;

                        return _regeneratorRuntime.wrap(function public_properties$(context$2$0) {
                            while (1) switch (context$2$0.prev = context$2$0.next) {
                                case 0:
                                    context$2$0.next = 2;
                                    return ['_surrogate', this._surrogate];

                                case 2:
                                    _iteratorNormalCompletion = true;
                                    _didIteratorError = false;
                                    _iteratorError = undefined;
                                    context$2$0.prev = 5;
                                    _iterator = _getIterator(_Object$keys(this));

                                case 7:
                                    if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                        context$2$0.next = 16;
                                        break;
                                    }

                                    key = _step.value;

                                    if (!(key.charAt(0) == '_')) {
                                        context$2$0.next = 11;
                                        break;
                                    }

                                    return context$2$0.abrupt('continue', 13);

                                case 11:
                                    context$2$0.next = 13;
                                    return [key, this[key]];

                                case 13:
                                    _iteratorNormalCompletion = true;
                                    context$2$0.next = 7;
                                    break;

                                case 16:
                                    context$2$0.next = 22;
                                    break;

                                case 18:
                                    context$2$0.prev = 18;
                                    context$2$0.t0 = context$2$0['catch'](5);
                                    _didIteratorError = true;
                                    _iteratorError = context$2$0.t0;

                                case 22:
                                    context$2$0.prev = 22;
                                    context$2$0.prev = 23;

                                    if (!_iteratorNormalCompletion && _iterator['return']) {
                                        _iterator['return']();
                                    }

                                case 25:
                                    context$2$0.prev = 25;

                                    if (!_didIteratorError) {
                                        context$2$0.next = 28;
                                        break;
                                    }

                                    throw _iteratorError;

                                case 28:
                                    return context$2$0.finish(25);

                                case 29:
                                    return context$2$0.finish(22);

                                case 30:
                                case 'end':
                                    return context$2$0.stop();
                            }
                        }, public_properties, this, [[5, 18, 22, 30], [23,, 25, 29]]);
                    })
                }, {
                    key: 'update_from_json',
                    value: function update_from_json(update) {
                        var _this = this;

                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                            var _loop = function () {
                                var _step2$value = _slicedToArray(_step2.value, 2);

                                var key = _step2$value[0];
                                var old = _step2$value[1];

                                // get the corrisonding new value for current property
                                var _new = update[key];

                                // if the value doesn't exist, move on to the next property
                                if (typeof _new === "undefined") {
                                    return 'continue';
                                }
                                // else, if the old value can be identified as an instance of new update it
                                else if (old instanceof Uniquable && old.is(_new)) {
                                        _this[key].update_from_json(_new);
                                    }
                                    // else, if values are both arrays
                                    else if (old instanceof Array && _new instanceof Array) {

                                            // go through old values to update or, otherwise, remove
                                            _this[key] = old.filter(function (old_child) {

                                                // if there's no chance to identify value remove it from old array
                                                if (!(old_child instanceof Uniquable)) return false;

                                                // try and find its matching value in new array
                                                var new_child_index = _new.findIndex(function (new_child) {
                                                    return old_child.is(new_child);
                                                });

                                                // if found, get it, update old value with it and remove it from new array
                                                if (new_child_index != -1) {
                                                    var new_child = _new[new_child_index];
                                                    old_child.update_from_json(new_child);
                                                    _new.splice(new_child_index, 1);

                                                    // value found and updated from _new - keep in the array
                                                    return true;
                                                }

                                                // unable to find match, remove it
                                                return false;
                                            });

                                            // Add any remaining objects in new into the old array
                                            _iteratorNormalCompletion3 = true;
                                            _didIteratorError3 = false;
                                            _iteratorError3 = undefined;

                                            try {
                                                for (_iterator3 = _getIterator(_new); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                                    var new_child = _step3.value;

                                                    // Try to put into class
                                                    new_child = classify(new_child);
                                                    _this[key].push(new_child);
                                                }
                                            } catch (err) {
                                                _didIteratorError3 = true;
                                                _iteratorError3 = err;
                                            } finally {
                                                try {
                                                    if (!_iteratorNormalCompletion3 && _iterator3['return']) {
                                                        _iterator3['return']();
                                                    }
                                                } finally {
                                                    if (_didIteratorError3) {
                                                        throw _iteratorError3;
                                                    }
                                                }
                                            }
                                        }
                                        // Try to put into a class and just replace old value
                                        else {
                                                _this[key] = classify(_new);
                                            }
                            };

                            for (var _iterator2 = _getIterator(this.public_properties()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                var _iteratorNormalCompletion3;

                                var _didIteratorError3;

                                var _iteratorError3;

                                var _iterator3, _step3;

                                var _ret = _loop();

                                if (_ret === 'continue') continue;
                            }
                        } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion2 && _iterator2['return']) {
                                    _iterator2['return']();
                                }
                            } finally {
                                if (_didIteratorError2) {
                                    throw _iteratorError2;
                                }
                            }
                        }
                    }
                }, {
                    key: 'is',
                    value: function is(object) {
                        var result = true;
                        var _iteratorNormalCompletion4 = true;
                        var _didIteratorError4 = false;
                        var _iteratorError4 = undefined;

                        try {
                            for (var _iterator4 = _getIterator(this._primary_keys), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                var key = _step4.value;

                                result &= this.key == object.key;
                            }
                        } catch (err) {
                            _didIteratorError4 = true;
                            _iteratorError4 = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                                    _iterator4['return']();
                                }
                            } finally {
                                if (_didIteratorError4) {
                                    throw _iteratorError4;
                                }
                            }
                        }

                        return result;
                    }
                }, {
                    key: '_surrogate',
                    get: function get() {
                        return this.__surrogate;
                    },
                    set: function set(value) {
                        // if a object is at any time no longer a surrogate it should never be one again
                        this.__surrogate = this.__surrogate ? value : false;
                    }
                }]);

                return Uniquable;
            })();

            _export('default', Uniquable);
        }
    };
});

// surrogate counts as public as it should be modified by the update json
$__System.register('3', ['17', '94', '99', 'b3', 'b4'], function (_export) {
    var _classCallCheck, _get, _inherits, Uniquable, classify, Calendar;

    return {
        setters: [function (_3) {
            _classCallCheck = _3['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_b3) {
            Uniquable = _b3['default'];
        }, function (_b4) {
            classify = _b4['default'];
        }],
        execute: function () {
            'use strict';

            Calendar = (function (_Uniquable) {
                _inherits(Calendar, _Uniquable);

                function Calendar(_ref) {
                    var _ref$id = _ref.id;
                    var id = _ref$id === undefined ? null : _ref$id;
                    var _ref$name = _ref.name;
                    var name = _ref$name === undefined ? null : _ref$name;
                    var _ref$resources = _ref.resources;
                    var resources = _ref$resources === undefined ? [] : _ref$resources;
                    var _ref$events = _ref.events;
                    var events = _ref$events === undefined ? [] : _ref$events;
                    var _ref$bookings = _ref.bookings;
                    var bookings = _ref$bookings === undefined ? [] : _ref$bookings;
                    var _ref$owners = _ref.owners;
                    var owners = _ref$owners === undefined ? [] : _ref$owners;
                    var _ref$contributors = _ref.contributors;
                    var contributors = _ref$contributors === undefined ? [] : _ref$contributors;
                    var _ref$viewers = _ref.viewers;
                    var viewers = _ref$viewers === undefined ? [] : _ref$viewers;
                    var _ref$invites = _ref.invites;
                    var invites = _ref$invites === undefined ? [] : _ref$invites;
                    var _ref$_surrogate = _ref._surrogate;

                    var _surrogate = _ref$_surrogate === undefined ? true : _ref$_surrogate;

                    _classCallCheck(this, Calendar);

                    _get(Object.getPrototypeOf(Calendar.prototype), 'constructor', this).call(this, _surrogate);

                    this.id = id;
                    this.name = name;
                    this.resources = resources.map(function (r) {
                        return classify(r);
                    });
                    this.events = events.map(function (e) {
                        return classify(e);
                    });
                    this.bookings = bookings.map(function (b) {
                        return classify(b);
                    });
                    this.owners = owners.map(function (o) {
                        return classify(o);
                    });
                    this.contributors = contributors.map(function (c) {
                        return classify(c);
                    });
                    this.viewers = viewers.map(function (v) {
                        return classify(v);
                    });
                    this.invites = invites.map(function (i) {
                        return classify(i);
                    });
                }

                return Calendar;
            })(Uniquable);

            _export('default', Calendar);
        }
    };
});
$__System.register('6', ['17', '94', '99', 'b3', 'b4'], function (_export) {
    var _classCallCheck, _get, _inherits, Uniquable, classify, Resource;

    return {
        setters: [function (_3) {
            _classCallCheck = _3['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_b3) {
            Uniquable = _b3['default'];
        }, function (_b4) {
            classify = _b4['default'];
        }],
        execute: function () {
            'use strict';

            Resource = (function (_Uniquable) {
                _inherits(Resource, _Uniquable);

                function Resource(_ref) {
                    var _ref$id = _ref.id;
                    var id = _ref$id === undefined ? null : _ref$id;
                    var _ref$name = _ref.name;
                    var name = _ref$name === undefined ? null : _ref$name;
                    var _ref$preferences = _ref.preferences;
                    var preferences = _ref$preferences === undefined ? {} : _ref$preferences;
                    var _ref$calendar = _ref.calendar;
                    var calendar = _ref$calendar === undefined ? null : _ref$calendar;
                    var _ref$bookings = _ref.bookings;
                    var bookings = _ref$bookings === undefined ? [] : _ref$bookings;
                    var _ref$tags = _ref.tags;
                    var tags = _ref$tags === undefined ? [] : _ref$tags;
                    var _ref$_surrogate = _ref._surrogate;

                    var _surrogate = _ref$_surrogate === undefined ? true : _ref$_surrogate;

                    _classCallCheck(this, Resource);

                    _get(Object.getPrototypeOf(Resource.prototype), 'constructor', this).call(this, _surrogate);

                    this.id = id;
                    this.name = name;
                    this.preferences = preferences;
                    this.calendar = classify(calendar);
                    this.bookings = bookings.map(function (b) {
                        return classify(b);
                    });
                    this.tags = tags;
                }

                return Resource;
            })(Uniquable);

            _export('default', Resource);
        }
    };
});
$__System.register('2', ['17', '94', '99', 'b3', 'b4'], function (_export) {
    var _classCallCheck, _get, _inherits, Uniquable, classify, Booking;

    return {
        setters: [function (_3) {
            _classCallCheck = _3['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_b3) {
            Uniquable = _b3['default'];
        }, function (_b4) {
            classify = _b4['default'];
        }],
        execute: function () {
            'use strict';

            Booking = (function (_Uniquable) {
                _inherits(Booking, _Uniquable);

                function Booking(_ref) {
                    var _ref$id = _ref.id;
                    var id = _ref$id === undefined ? null : _ref$id;
                    var _ref$start_date = _ref.start_date;
                    var start_date = _ref$start_date === undefined ? null : _ref$start_date;
                    var _ref$end_date = _ref.end_date;
                    var end_date = _ref$end_date === undefined ? null : _ref$end_date;
                    var _ref$event = _ref.event;
                    var event = _ref$event === undefined ? null : _ref$event;
                    var _ref$resource = _ref.resource;
                    var resource = _ref$resource === undefined ? null : _ref$resource;
                    var _ref$_surrogate = _ref._surrogate;

                    var _surrogate = _ref$_surrogate === undefined ? true : _ref$_surrogate;

                    _classCallCheck(this, Booking);

                    _get(Object.getPrototypeOf(Booking.prototype), 'constructor', this).call(this, _surrogate);

                    this.id = id;
                    this.start_date = start_date;
                    this.end_date = end_date;
                    this.event = classify(event);
                    this.resource = classify(resource);
                }

                return Booking;
            })(Uniquable);

            _export('default', Booking);
        }
    };
});
$__System.register('5', ['17', '94', '99', 'b3', 'b4'], function (_export) {
    var _classCallCheck, _get, _inherits, Uniquable, classify, Invite;

    return {
        setters: [function (_3) {
            _classCallCheck = _3['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_b3) {
            Uniquable = _b3['default'];
        }, function (_b4) {
            classify = _b4['default'];
        }],
        execute: function () {
            'use strict';

            Invite = (function (_Uniquable) {
                _inherits(Invite, _Uniquable);

                function Invite(_ref) {
                    var _ref$id = _ref.id;
                    var id = _ref$id === undefined ? null : _ref$id;
                    var _ref$title = _ref.title;
                    var title = _ref$title === undefined ? null : _ref$title;
                    var _ref$user = _ref.user;
                    var user = _ref$user === undefined ? null : _ref$user;
                    var _ref$calendar = _ref.calendar;
                    var calendar = _ref$calendar === undefined ? null : _ref$calendar;
                    var _ref$_surrogate = _ref._surrogate;

                    var _surrogate = _ref$_surrogate === undefined ? true : _ref$_surrogate;

                    _classCallCheck(this, Invite);

                    _get(Object.getPrototypeOf(Invite.prototype), 'constructor', this).call(this, _surrogate);

                    this.id = id;
                    this.title = title;
                    this.user = classify(user);
                    this.calendar = classify(calendar);
                }

                return Invite;
            })(Uniquable);

            _export('default', Invite);
        }
    };
});
$__System.register('4', ['17', '94', '99', 'b3', 'b4'], function (_export) {
    var _classCallCheck, _get, _inherits, Uniquable, classify, Event;

    return {
        setters: [function (_3) {
            _classCallCheck = _3['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_b3) {
            Uniquable = _b3['default'];
        }, function (_b4) {
            classify = _b4['default'];
        }],
        execute: function () {
            'use strict';

            Event = (function (_Uniquable) {
                _inherits(Event, _Uniquable);

                function Event(_ref) {
                    var _ref$id = _ref.id;
                    var id = _ref$id === undefined ? null : _ref$id;
                    var _ref$name = _ref.name;
                    var name = _ref$name === undefined ? null : _ref$name;
                    var _ref$start_date = _ref.start_date;
                    var start_date = _ref$start_date === undefined ? null : _ref$start_date;
                    var _ref$end_date = _ref.end_date;
                    var end_date = _ref$end_date === undefined ? null : _ref$end_date;
                    var _ref$notes = _ref.notes;
                    var notes = _ref$notes === undefined ? null : _ref$notes;
                    var _ref$hours = _ref.hours;
                    var hours = _ref$hours === undefined ? null : _ref$hours;
                    var _ref$bookings = _ref.bookings;
                    var bookings = _ref$bookings === undefined ? [] : _ref$bookings;
                    var _ref$_surrogate = _ref._surrogate;

                    var _surrogate = _ref$_surrogate === undefined ? true : _ref$_surrogate;

                    _classCallCheck(this, Event);

                    _get(Object.getPrototypeOf(Event.prototype), 'constructor', this).call(this, _surrogate);

                    this.id = id;
                    this.name = name;
                    this.start_date = start_date;
                    this.end_date = end_date;
                    this.notes = notes;
                    this.hours = hours;
                    this.bookings = bookings.map(function (b) {
                        return classify(b);
                    });
                }

                return Event;
            })(Uniquable);

            _export('default', Event);
        }
    };
});
$__System.register('7', ['17', '94', '99', 'b3', 'b4'], function (_export) {
    var _classCallCheck, _get, _inherits, Uniquable, classify, User;

    return {
        setters: [function (_3) {
            _classCallCheck = _3['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_b3) {
            Uniquable = _b3['default'];
        }, function (_b4) {
            classify = _b4['default'];
        }],
        execute: function () {
            'use strict';

            User = (function (_Uniquable) {
                _inherits(User, _Uniquable);

                function User(_ref) {
                    var _ref$id = _ref.id;
                    var id = _ref$id === undefined ? null : _ref$id;
                    var _ref$username = _ref.username;
                    var username = _ref$username === undefined ? null : _ref$username;
                    var _ref$email_address = _ref.email_address;
                    var email_address = _ref$email_address === undefined ? null : _ref$email_address;
                    var _ref$calendars = _ref.calendars;
                    var calendars = _ref$calendars === undefined ? [] : _ref$calendars;
                    var _ref$invites = _ref.invites;
                    var invites = _ref$invites === undefined ? [] : _ref$invites;
                    var _ref$_surrogate = _ref._surrogate;

                    var _surrogate = _ref$_surrogate === undefined ? true : _ref$_surrogate;

                    _classCallCheck(this, User);

                    _get(Object.getPrototypeOf(User.prototype), 'constructor', this).call(this, _surrogate);

                    this.id = id;
                    this.username = username;
                    this.email_address = email_address;
                    this.calendars = calendars.map(function (c) {
                        return classify(c);
                    });
                    this.invites = invites.map(function (i) {
                        return classify(i);
                    });
                }

                return User;
            })(Uniquable);

            _export('default', User);
        }
    };
});
$__System.register('b4', ['2', '3', '4', '5', '6', '7'], function (_export) {
    'use strict';

    var Booking, Calendar, Event, Invite, Resource, User;

    _export('default', classify);

    function classify() {
        var json = arguments.length <= 0 || arguments[0] === undefined ? null : arguments[0];

        var type = json && json._type ? json._type : 'unknown';

        switch (type.toLowerCase()) {
            case 'calendar':
                return new Calendar(json);
            case 'resource':
                return new Resource(json);
            case 'booking':
                return new Booking(json);
            case 'invite':
                return new Invite(json);
            case 'event':
                return new Event(json);
            case 'user':
                return new User(json);

            default:
                return json;
        }
    }

    return {
        setters: [function (_3) {
            Booking = _3['default'];
        }, function (_) {
            Calendar = _['default'];
        }, function (_5) {
            Event = _5['default'];
        }, function (_4) {
            Invite = _4['default'];
        }, function (_2) {
            Resource = _2['default'];
        }, function (_6) {
            User = _6['default'];
        }],
        execute: function () {}
    };
});
$__System.register("b5", ["16", "17", "90", "b4"], function (_export) {
    var _createClass, _classCallCheck, docCookies, classify, Connection;

    return {
        setters: [function (_) {
            _createClass = _["default"];
        }, function (_2) {
            _classCallCheck = _2["default"];
        }, function (_3) {
            docCookies = _3["default"];
        }, function (_b4) {
            classify = _b4["default"];
        }],
        execute: function () {
            "use strict";

            Connection = (function () {
                function Connection(app, url) {
                    var _this = this;

                    _classCallCheck(this, Connection);

                    this._url = url;
                    this._app = app;
                    this._ws = null;
                    this._next_id = 1;
                    this._pending_request = [];
                    this._pending_response = {};
                    this._send_timeout = null;
                    this._connected = false;
                    this._handshake_complete = false;
                    this.connect();

                    // ping to keep connection alive
                    setInterval(function () {
                        if (_this._connected) {
                            _this.send("ping");
                        }
                    }, 30000);
                }

                _createClass(Connection, [{
                    key: "connect",
                    value: function connect() {
                        var _this2 = this;

                        this._ws = new WebSocket(this._url);
                        this._ws.onopen = function () {
                            _this2._connected = true;
                        };
                        this._ws.onmessage = function (evt) {
                            var payload = JSON.parse(evt.data);
                            if (payload.response_id) {
                                var request = _this2._pending_response[payload.response_id];
                                if (request) {
                                    delete _this2._pending_response[payload.response_id];
                                    request.callback(request, payload);
                                }
                            } else if (payload.signal == "cookie") {
                                var value = docCookies.getItem(payload.message.cookie_name);
                                if (value) {
                                    _this2.send("cookie", { value: value });
                                } else {
                                    _this2._handshake_complete = true;
                                }
                            } else if (payload.signal == "user") {
                                _this2._app.$emit('insert_user', payload.message);
                                if (payload.cookie) {
                                    var expires = new Date();
                                    expires.setMonth(expires.getMonth() + 1);
                                    docCookies.setItem(payload.cookie_name, payload.cookie, expires.toGMTString());
                                }
                                _this2._handshake_complete = true;
                            } else {
                                _this2._app.$emit(payload.signal, payload.message);
                            }
                        };
                        this._ws.onclose = function () {
                            _this2._ws = null;
                            _this2._connected = false;
                        };
                    }
                }, {
                    key: "send",
                    value: function send(action, args, callback) {
                        this._pending_request.push({
                            id: this._next_id++,
                            action: action,
                            args: args,
                            callback: callback
                        });
                        if (!this._send_timeout && this._connected) {
                            this._send_timeout = setTimeout(this._send.bind(this), 0);
                        }
                    }
                }, {
                    key: "_send",
                    value: function _send() {
                        var _this3 = this;

                        this._send_timeout = null;
                        this._ws.send(JSON.stringify({
                            requests: this._pending_request.map(function (item) {
                                if (item.callback) {
                                    _this3._pending_response[item.id] = item;
                                }
                                return [item.id, item.action, item.args];
                            })
                        }));
                        this._pending_request = [];
                    }
                }, {
                    key: "login",
                    value: function login(username, password, error_back) {
                        this.send("login", { username: username, password: password }, function (request, response) {
                            if (response.error && error_back) {
                                error_back(response.error);
                            }
                        });
                    }
                }, {
                    key: "logout",
                    value: function logout(error_back) {
                        var _this4 = this;

                        this.send("logout", {}, function (request, response) {
                            if (response.error) {
                                if (error_back) {
                                    error_back(response.error);
                                }
                                return;
                            }
                            _this4._app.store.user = null;
                            docCookies.removeItem(response.result);
                        });
                    }
                }, {
                    key: "get_calendars",
                    value: function get_calendars(error_back) {
                        var _this5 = this;

                        this.send('get_calendars', {}, function (request, response) {
                            if (response.error) {
                                if (error_back) error_back(response.error);
                                return;
                            }
                            _this5._app.$emit('set_calendars', response.result);
                        });
                    }
                }, {
                    key: "get_events",
                    value: function get_events(calendar, error_back) {
                        var _this6 = this;

                        this.send('get_events', { calendar_id: calendar.id }, function (request, response) {
                            if (response.error) {
                                if (error_back) error_back(response.error);
                                return;
                            }
                            _this6._app.$emit('set_events', calendar.id, response.result);
                        });
                    }
                }, {
                    key: "insert_event",
                    value: function insert_event(event, error_back) {
                        this.send('insert_event', event, function (request, response) {
                            if (error_back) error_back(response.error);
                        });
                    }
                }, {
                    key: "get_resources",
                    value: function get_resources(calendar, error_back) {
                        var _this7 = this;

                        this.send('get_resources', { calendar_id: calendar.id }, function (request, response) {
                            if (response.error) {
                                if (error_back) error_back(response.error);
                                return;
                            }
                            _this7._app.$emit('set_resources', calendar.id, response.result);
                        });
                    }
                }, {
                    key: "insert_resource",
                    value: function insert_resource(resource, error_back) {
                        this.send('insert_resource', resource, function (request, response) {
                            if (error_back) error_back(response.error);
                        });
                    }
                }, {
                    key: "get_bookings",
                    value: function get_bookings(calendar, error_back) {
                        var _this8 = this;

                        this.send('get_bookings', { calendar_id: calendar.id }, function (request, response) {
                            if (response.error) {
                                if (error_back) error_back(response.error);
                                return;
                            }
                            _this8._app.$emit('set_bookings', calendar.id, response.result);
                        });
                    }
                }]);

                return Connection;
            })();

            _export("default", Connection);
        }
    };
});
$__System.register('1', ['8', '9', '12', '37', '42', '89', 'a', 'b', 'c', '8c', '8f', 'b5', 'b4'], function (_export) {
    // CSS Imports

    // Vue global settings

    // -- Connection to server

    // -- App panels

    // -- Prototype Extentions

    // -- Vue

    // JS Imports
    // -- Consts
    'use strict';

    // -- Utils
    var Vue, VueRouter, ResizeMixin, systems, debug, ws_url, SchedulerPanel, LoginPanel, Control, classify, router;
    return {
        setters: [function (_) {}, function (_2) {}, function (_3) {
            Vue = _3['default'];
        }, function (_4) {
            VueRouter = _4['default'];
        }, function (_5) {
            ResizeMixin = _5['default'];
        }, function (_6) {
            systems = _6;
        }, function (_a) {}, function (_b) {
            debug = _b.debug;
            ws_url = _b.ws_url;
        }, function (_c) {}, function (_c2) {
            SchedulerPanel = _c2['default'];
        }, function (_f) {
            LoginPanel = _f['default'];
        }, function (_b5) {
            Control = _b5['default'];
        }, function (_b4) {
            classify = _b4['default'];
        }],
        execute: function () {
            Vue.config.debug = debug;
            Vue.use(VueRouter);

            router = window.router = new VueRouter();

            router.map({
                '/calendar/:calendar_id': {
                    name: 'calendar',
                    component: SchedulerPanel
                }
            });

            router.start({
                mixins: [ResizeMixin],
                data: function data() {
                    return {
                        control: null,
                        store: {
                            user: null
                        },
                        user_os: systems.parse_os_from_user_agent(navigator.userAgent),
                        keys_down: null
                    };
                },
                created: function created() {
                    this.control = new Control(this, ws_url);
                    this.keys_down = [];
                },
                ready: function ready() {
                    if (debug) {
                        console.warn("Running Debug");
                        window.app = this;
                    }

                    // watch key presses
                    document.onkeydown = this.key_down;
                    document.onkeyup = this.key_up;
                },
                watch: {},
                methods: {
                    window_size: function window_size() {
                        return { height: window.innerHeight, width: window.innerWidth };
                    },
                    key_down: function key_down(event) {
                        event = event || window.event;
                        this.keys_down.set(event.keyCode);
                        console.log(this.keys_down);
                    },
                    key_up: function key_up(event) {
                        event = event || window.event;
                        this.keys_down.remove(event.keyCode);
                    }
                },
                computed: {
                    // Monitors when the handshake between the server and client end (cookie for user exchange)
                    handshake_complete: function handshake_complete() {
                        return this.control._handshake_complete;
                    }
                },
                events: {
                    resize: function resize(size) {
                        this.$broadcast('resize', size);
                    },
                    insert_user: function insert_user(user) {
                        this.store.user = classify(user);
                    },
                    update_user: function update_user(user) {
                        this.store.user.update_from_json(user);
                    },
                    delete_user: function delete_user(user) {
                        this.store.user = null;
                    },
                    set_calendars: function set_calendars(calendars) {
                        this.store.user.update_from_json({
                            calendars: calendars
                        });
                    },
                    insert_calendar: function insert_calendar(calendar) {
                        calendar = classify(calendar);
                        this.store.user.calendars.push(calendar);
                    },
                    update_calendar: function update_calendar(calendar) {
                        var old_calendar = this.store.user.calendars.find(function (c) {
                            return c.id == calendar.id;
                        });
                        old_calendar.update_from_json(calendar);
                    },
                    delete_calendar: function delete_calendar(id) {
                        var index = this.store.user.calendars.findIndex(function (c) {
                            return c.id == id;
                        });
                        calendar.calendars.splice(index, 1);
                    },
                    set_invites: function set_invites(invites) {
                        this.store.user.update_from_json({
                            invites: invites
                        });
                    },
                    insert_invite: function insert_invite(invite) {
                        invite = classify(invite);
                        this.store.user.invites.push(invite);
                    },
                    update_invite: function update_invite(invite) {
                        var old_invite = this.store.user.invites.find(function (i) {
                            return i.id == invite.id;
                        });
                        old_invite.update_from_json(invite);
                    },
                    delete_invite: function delete_invite(id) {
                        var index = this.store.user.invites.findIndex(function (i) {
                            return i.id == id;
                        });
                        calendar.invites.splice(index, 1);
                    },
                    set_events: function set_events(calendar_id, events) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == calendar_id;
                        });
                        calendar.update_from_json({
                            events: events
                        });
                    },
                    insert_event: function insert_event(event) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == event.calendar.id;
                        });
                        event = classify(event);
                        calendar.events.push(event);
                    },
                    update_event: function update_event(event) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == event.calendar.id;
                        });
                        var old_event = calendar.events.find(function (e) {
                            return e.id == event.id;
                        });
                        old_event.update_from_json(event);
                    },
                    delete_event: function delete_event(id) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == event.calendar.id;
                        });
                        var index = calendar.events.findIndex(function (e) {
                            return e.id == id;
                        });
                        calendar.events.splice(index, 1);
                    },
                    set_resources: function set_resources(calendar_id, resources) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == calendar_id;
                        });
                        calendar.update_from_json({
                            resources: resources
                        });
                    },
                    insert_resource: function insert_resource(resource) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == resource.calendar.id;
                        });
                        resources = classify(resource);
                        calendar.resources.push(resource);
                    },
                    update_resource: function update_resource(resource) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == resource.calendar.id;
                        });
                        var old_resource = calendar.resources.find(function (r) {
                            return r.id == resource.id;
                        });
                        old_resource.update_from_json(resource);
                    },
                    delete_resource: function delete_resource(id) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == resource.calendar.id;
                        });
                        var index = calendar.resources.findIndex(function (r) {
                            return r.id == id;
                        });
                        calendar.resources.splice(index, 1);
                    },
                    set_bookings: function set_bookings(calendar_id, bookings) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == calendar_id;
                        });
                        calendar.update_from_json({
                            bookings: bookings
                        });
                    },
                    insert_booking: function insert_booking(booking) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == booking.calendar.id;
                        });
                        booking = classify(booking);
                        calendar.bookings.push(booking);
                    },
                    update_booking: function update_booking(booking) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == booking.calendar.id;
                        });
                        var old_booking = calendar.bookings.find(function (b) {
                            return b.id == booking.id;
                        });
                        old_booking.update_from_json(booking);
                    },
                    delete_booking: function delete_booking(id) {
                        var calendar = this.store.user.calendars.find(function (c) {
                            return c.id == booking.calendar.id;
                        });
                        var index = calendar.bookings.findIndex(function (b) {
                            return b.id == id;
                        });
                        calendar.bookings.splice(index, 1);
                    }
                },
                components: {
                    'login-panel': LoginPanel
                }
            }, 'body');
        }
    };
});
$__System.register('npm:skeleton-css@2.0.4/css/normalize.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('npm:skeleton-css@2.0.4/css/skeleton.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('app/main.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('app/components/scheduler-panel/scheduler.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('app/components/calendar-panel/calendar.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('app/components/events-panel/events.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('app/components/insert-event-panel/insert_event.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('app/components/resources-panel/resources.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('app/components/insert-resource-panel/insert_resource.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
$__System.register('app/components/login-panel/login.css!github:systemjs/plugin-css@0.1.20', [], false, function() {});
(function(c){if (typeof document == 'undefined') return; var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
("/*! normalize.css v3.0.2 | MIT License | git.io/normalize */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none} input[type=reset],button,html input[type=button],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}.container{position:relative;width:100%;max-width:960px;margin:0 auto;padding:0 20px;box-sizing:border-box}.column,.columns{width:100%;float:left;box-sizing:border-box}@media (min-width:400px){.container{width:85%;padding:0}}@media (min-width:550px){.container{width:80%}.column,.columns{margin-left:4%}.column:first-child,.columns:first-child{margin-left:0}.one.column,.one.columns{width:4.66666666667%}.two.columns{width:13.3333333333%}.three.columns{width:22%}.four.columns{width:30.6666666667%}.five.columns{width:39.3333333333%}.six.columns{width:48%}.seven.columns{width:56.6666666667%}.eight.columns{width:65.3333333333%}.nine.columns{width:74%}.ten.columns{width:82.6666666667%}.eleven.columns{width:91.3333333333%}.twelve.columns{width:100%;margin-left:0}.one-third.column{width:30.6666666667%}.two-thirds.column{width:65.3333333333%}.one-half.column{width:48%}.offset-by-one.column,.offset-by-one.columns{margin-left:8.66666666667%}.offset-by-two.column,.offset-by-two.columns{margin-left:17.3333333333%}.offset-by-three.column,.offset-by-three.columns{margin-left:26%}.offset-by-four.column,.offset-by-four.columns{margin-left:34.6666666667%}.offset-by-five.column,.offset-by-five.columns{margin-left:43.3333333333%}.offset-by-six.column,.offset-by-six.columns{margin-left:52%}.offset-by-seven.column,.offset-by-seven.columns{margin-left:60.6666666667%}.offset-by-eight.column,.offset-by-eight.columns{margin-left:69.3333333333%}.offset-by-nine.column,.offset-by-nine.columns{margin-left:78%}.offset-by-ten.column,.offset-by-ten.columns{margin-left:86.6666666667%}.offset-by-eleven.column,.offset-by-eleven.columns{margin-left:95.3333333333%}.offset-by-one-third.column,.offset-by-one-third.columns{margin-left:34.6666666667%}.offset-by-two-thirds.column,.offset-by-two-thirds.columns{margin-left:69.3333333333%}.offset-by-one-half.column,.offset-by-one-half.columns{margin-left:52%}}html{font-size:62.5%}body{font-size:1.5em;line-height:1.6;font-weight:400;font-family:Raleway,HelveticaNeue,\"Helvetica Neue\",Helvetica,Arial,sans-serif;color:#222}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:2rem;font-weight:300}h1{font-size:4rem;line-height:1.2;letter-spacing:-.1rem}h2{font-size:3.6rem;line-height:1.25;letter-spacing:-.1rem}h3{font-size:3rem;line-height:1.3;letter-spacing:-.1rem}h4{font-size:2.4rem;line-height:1.35;letter-spacing:-.08rem}h5{font-size:1.8rem;line-height:1.5;letter-spacing:-.05rem}h6{font-size:1.5rem;line-height:1.6;letter-spacing:0}@media (min-width:550px){h1{font-size:5rem}h2{font-size:4.2rem}h3{font-size:3.6rem}h4{font-size:3rem}h5{font-size:2.4rem}h6{font-size:1.5rem}}p{margin-top:0}a{color:#1EAEDB}a:hover{color:#0FA0CE}.button,button,input[type=button],input[type=reset],input[type=submit]{display:inline-block;height:38px;padding:0 30px;color:#555;text-align:center;font-size:11px;font-weight:600;line-height:38px;letter-spacing:.1rem;text-transform:uppercase;text-decoration:none;white-space:nowrap;background-color:transparent;border-radius:4px;border:1px solid #bbb;cursor:pointer;box-sizing:border-box}.button:focus,.button:hover,button:focus,button:hover,input[type=button]:focus,input[type=button]:hover,input[type=reset]:focus,input[type=reset]:hover,input[type=submit]:focus,input[type=submit]:hover{color:#333;border-color:#888;outline:0}.button.button-primary,button.button-primary,input[type=button].button-primary,input[type=reset].button-primary,input[type=submit].button-primary{color:#FFF;background-color:#33C3F0;border-color:#33C3F0}.button.button-primary:focus,.button.button-primary:hover,button.button-primary:focus,button.button-primary:hover,input[type=button].button-primary:focus,input[type=button].button-primary:hover,input[type=reset].button-primary:focus,input[type=reset].button-primary:hover,input[type=submit].button-primary:focus,input[type=submit].button-primary:hover{color:#FFF;background-color:#1EAEDB;border-color:#1EAEDB}input[type=email],input[type=text],input[type=tel],input[type=url],input[type=password],input[type=number],input[type=search],select,textarea{height:38px;padding:6px 10px;background-color:#fff;border:1px solid #D1D1D1;border-radius:4px;box-shadow:none;box-sizing:border-box}input[type=email],input[type=text],input[type=tel],input[type=url],input[type=password],input[type=number],input[type=search],textarea{-webkit-appearance:none;-moz-appearance:none;appearance:none}textarea{min-height:65px;padding-top:6px;padding-bottom:6px}input[type=email]:focus,input[type=text]:focus,input[type=tel]:focus,input[type=url]:focus,input[type=password]:focus,input[type=number]:focus,input[type=search]:focus,select:focus,textarea:focus{border:1px solid #33C3F0;outline:0}label,legend{display:block;margin-bottom:.5rem;font-weight:600}fieldset{padding:0;border-width:0}input[type=checkbox],input[type=radio]{display:inline}label>.label-body{display:inline-block;margin-left:.5rem;font-weight:400}ul{list-style:circle inside}ol{list-style:decimal inside}ol,ul{padding-left:0;margin-top:0}ol ol,ol ul,ul ol,ul ul{margin:1.5rem 0 1.5rem 3rem;font-size:90%}li{margin-bottom:1rem}code{padding:.2rem .5rem;margin:0 .2rem;font-size:90%;white-space:nowrap;background:#F1F1F1;border:1px solid #E1E1E1;border-radius:4px}pre>code{display:block;padding:1rem 1.5rem;white-space:pre}td,th{padding:12px 15px;text-align:left;border-bottom:1px solid #E1E1E1}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}.button,button{margin-bottom:1rem}fieldset,input,select,textarea{margin-bottom:1.5rem}blockquote,dl,figure,form,ol,p,pre,table,ul{margin-bottom:2.5rem}.u-full-width{width:100%;box-sizing:border-box}.u-max-full-width{max-width:100%;box-sizing:border-box}.u-pull-right{float:right}.u-pull-left{float:left}hr{margin-top:3rem;margin-bottom:3.5rem;border-width:0;border-top:1px solid #E1E1E1}.container:after,.row:after,.u-cf{content:\"\";display:table;clear:both}h1,h2,h3,h4{font-family:Arimo,sans-serif;text-transform:uppercase;margin:0;font-size:18px;display:inline-block}body{position:absolute;height:100%;width:100%;font-family:Oxygen,sans-serif;font-weight:100}.button.button-primary,a.button-primary,button.button-primary,input[type=submit].button-primary{border-radius:0;background-color:#D25858;border-color:#D25858;-webkit-transition:.3s;-moz-transition:.3s;-ms-transition:.3s;-o-transition:.3s;transition:.3s}.button.button-primary:focus,.button.button-primary:hover,a.button-primary:focus,a.button-primary:hover,button.button-primary:focus,button.button-primary:hover,input[type=submit].button-primary:focus,input[type=submit].button-primary:hover{background-color:#B02727;border-color:#B02727}.button.button-primary:disabled,a.button-primary:disabled,button.button-primary:disabled,input[type=submit].button-primary:disabled{background-color:#E8ABAB;border-color:#E8ABAB}.button.button-primary:active,a.button-primary:active,button.button-primary:active,input[type=submit].button-primary:active{-webkit-box-shadow:inset 5px 5px 30px 5px rgba(0,0,0,.3);-moz-box-shadow:inset 5px 5px 30px 5px rgba(0,0,0,.3);box-shadow:inset 5px 5px 30px 5px rgba(0,0,0,.3)}input[type=email],input[type=text],input[type=tel],input[type=url],input[type=password],input[type=number],input[type=search],select,textarea{border:none;border-bottom:1px solid #D1D1D1;max-width:100%;border-radius:0}input[type=email]:focus,input[type=email]:hover,input[type=text]:focus,input[type=text]:hover,input[type=tel]:focus,input[type=tel]:hover,input[type=url]:focus,input[type=url]:hover,input[type=password]:focus,input[type=password]:hover,input[type=number]:focus,input[type=number]:hover,input[type=search]:focus,input[type=search]:hover,select:focus,select:hover,textarea:focus,textarea:hover{border:none;border-bottom:1px solid #D25858}#Scheduler{position:absolute;height:100%;width:100%}#Scheduler .required::after{position:absolute;top:15px;right:20px;content:\"\\f069\";font-family:FontAwesome;color:#D25858}#Scheduler .scroll-container{overflow:auto!important}#Scheduler .logo-icon{display:inline-block;width:22px;height:12px}#Scheduler .no-select{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}#Scheduler .cursor-pointer{cursor:pointer}#Scheduler .list-header{height:50px;background-color:#D25858;font-weight:700;font-size:20px;color:#fff;padding:8px 16px;margin-bottom:0;z-index:100;word-spacing:0}#Scheduler .list-body{position:absolute;margin-bottom:0;height:100%}#Scheduler .list-body ul{list-style-type:none;margin-bottom:0;height:100%;overflow:auto}#Scheduler .list-body ul li{border-bottom:1px solid #F1F1F1;background-color:#fff;padding:8px 16px;margin:0}#Scheduler .list-body ul li.selected{font-weight:700;border-left:3px solid #D25858}#Scheduler .list-body ul li:hover{background-color:#FFF3F2}#Scheduler .list-body ul li span{font-size:16px;margin-bottom:-7px}#Scheduler .list-body .list-item-text{display:inline-block;max-width:90%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.sk-cube-grid{width:40px;height:40px;margin:100px auto}.sk-cube-grid .sk-cube{width:33%;height:33%;background-color:#D25858;float:left;-webkit-animation:sk-cubeGridScaleDelay 1.3s infinite ease-in-out;animation:sk-cubeGridScaleDelay 1.3s infinite ease-in-out}.sk-cube-grid .sk-cube1{-webkit-animation-delay:.2s;animation-delay:.2s}.sk-cube-grid .sk-cube2{-webkit-animation-delay:.3s;animation-delay:.3s}.sk-cube-grid .sk-cube3{-webkit-animation-delay:.4s;animation-delay:.4s}.sk-cube-grid .sk-cube4{-webkit-animation-delay:.1s;animation-delay:.1s}.sk-cube-grid .sk-cube5{-webkit-animation-delay:.2s;animation-delay:.2s}.sk-cube-grid .sk-cube6{-webkit-animation-delay:.3s;animation-delay:.3s}.sk-cube-grid .sk-cube7{-webkit-animation-delay:0s;animation-delay:0s}.sk-cube-grid .sk-cube8{-webkit-animation-delay:.1s;animation-delay:.1s}.sk-cube-grid .sk-cube9{-webkit-animation-delay:.2s;animation-delay:.2s}@-webkit-keyframes sk-cubeGridScaleDelay{0%,100%,70%{-webkit-transform:scale3D(1,1,1);transform:scale3D(1,1,1)}35%{-webkit-transform:scale3D(0,0,1);transform:scale3D(0,0,1)}}@keyframes sk-cubeGridScaleDelay{0%,100%,70%{-webkit-transform:scale3D(1,1,1);transform:scale3D(1,1,1)}35%{-webkit-transform:scale3D(0,0,1);transform:scale3D(0,0,1)}}@media (min-width:400px){.container{width:100%}.column,.columns{margin:0}.three.columns{width:26%}}@media (min-width:550px){.container{width:100%}.column,.columns{margin:0}.three.columns{width:26%}}@media (min-width:750px){.container{width:100%}.column,.columns{margin:0}.three.columns{width:26%}}@media (min-width:1000px){.container{width:100%}}@media (min-width:1200px){.container{width:100%}}@-ms-viewport{width:device-width}@-o-viewport{width:device-width}@viewport{width:device-width}.item-hint{-webkit-animation:item-hint 3s ease forwards;-o-animation:item-hint 3s ease forwards;animation:item-hint 3s ease forwards}@keyframes item-hint{0%{background-color:#fff}50%{background-color:#FFF3F2}100%{background-color:#fff}}.fade-transition{transition:all .3s ease;opacity:1}.fade-enter,.fade-leave{opacity:0}.expand-horizontal-fade-transition{transition:all .3s ease;opacity:1;width:82%}.expand-horizontal-fade-enter,.expand-horizontal-fade-leave{opacity:0;width:0}.rotate-45-transition{-webkit-transform:rotate(0);-ms-transform:rotate(0);transform:rotate(0);-webkit-transition:.3s;transition:.3s;transition-timing-function:ease-out}.rotate-45-enter,.rotate-45-leave{-webkit-transform:rotate(-45deg);-ms-transform:rotate(-45deg);transform:rotate(-45deg)}.shade-transition{transition:all .3s ease;position:absolute;top:0;height:100%;width:100%;background-color:#000;opacity:.3}.shade-enter,.shade-leave{opacity:0}.drop-down-transition{transition:all .3s ease;position:absolute;top:0;width:100%;height:100%;overflow:hidden;padding:0}.drop-down-enter,.drop-down-leave{height:0%}.SchedulerPanel{height:100%}.SchedulerPanel .view-box{position:relative;height:100%}.SchedulerPanel .main-panel,.SchedulerPanel .side-left,.SchedulerPanel .side-right{height:100%}.SchedulerPanel .side-left{position:absolute;top:0;left:0;right:330px}.SchedulerPanel .side-right{position:absolute;top:0;right:0;width:330px}.SchedulerPanel .side-panel{height:50%}#resource-panel{background-color:#F1F1F1}/*!\n * FullCalendar v2.5.0 Stylesheet\n * Docs & License: http://fullcalendar.io/\n * (c) 2015 Adam Shaw\n */.fc{direction:ltr;text-align:left}.fc-rtl{text-align:right}body .fc{font-size:1em}.fc-unthemed .fc-divider,.fc-unthemed .fc-popover,.fc-unthemed .fc-row,.fc-unthemed tbody,.fc-unthemed td,.fc-unthemed th,.fc-unthemed thead{border-color:#ddd}.fc-unthemed .fc-popover{background-color:#fff}.fc-unthemed .fc-divider,.fc-unthemed .fc-popover .fc-header{background:#eee}.fc-unthemed .fc-popover .fc-header .fc-close{color:#666}.fc-unthemed .fc-today{background:#fcf8e3}.fc-highlight{background:#bce8f1;opacity:.3;filter:alpha(opacity=30)}.fc-bgevent{background:#8fdf82;opacity:.3;filter:alpha(opacity=30)}.fc-nonbusiness{background:#d7d7d7}.fc-icon{display:inline-block;width:1em;height:1em;line-height:1em;font-size:1em;text-align:center;overflow:hidden;font-family:\"Courier New\",Courier,monospace;-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.fc-icon:after{position:relative;margin:0 -1em}.fc-icon-left-single-arrow:after{content:\"\\02039\";font-weight:700;font-size:200%;top:-7%;left:3%}.fc-icon-right-single-arrow:after{content:\"\\0203A\";font-weight:700;font-size:200%;top:-7%;left:-3%}.fc-icon-left-double-arrow:after{content:\"\\000AB\";font-size:160%;top:-7%}.fc-icon-right-double-arrow:after{content:\"\\000BB\";font-size:160%;top:-7%}.fc-icon-left-triangle:after{content:\"\\25C4\";font-size:125%;top:3%;left:-2%}.fc-icon-right-triangle:after{content:\"\\25BA\";font-size:125%;top:3%;left:2%}.fc-icon-down-triangle:after{content:\"\\25BC\";font-size:125%;top:2%}.fc-icon-x:after{content:\"\\000D7\";font-size:200%;top:6%}.fc button{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box;margin:0;height:2.1em;padding:0 .6em;font-size:1em;white-space:nowrap;cursor:pointer}.fc button::-moz-focus-inner{margin:0;padding:0}.fc-state-default{border:1px solid}.fc-state-default.fc-corner-left{border-top-left-radius:4px;border-bottom-left-radius:4px}.fc-state-default.fc-corner-right{border-top-right-radius:4px;border-bottom-right-radius:4px}.fc button .fc-icon{position:relative;top:-.05em;margin:0 .2em;vertical-align:middle}.fc-state-default{background-color:#f5f5f5;background-image:-moz-linear-gradient(top,#fff,#e6e6e6);background-image:-webkit-gradient(linear,0 0,0 100%,from(#fff),to(#e6e6e6));background-image:-webkit-linear-gradient(top,#fff,#e6e6e6);background-image:-o-linear-gradient(top,#fff,#e6e6e6);background-image:linear-gradient(to bottom,#fff,#e6e6e6);background-repeat:repeat-x;border-color:#e6e6e6 #e6e6e6 #bfbfbf;border-color:rgba(0,0,0,.1) rgba(0,0,0,.1) rgba(0,0,0,.25);color:#333;text-shadow:0 1px 1px rgba(255,255,255,.75);box-shadow:inset 0 1px 0 rgba(255,255,255,.2),0 1px 2px rgba(0,0,0,.05)}.fc-state-active,.fc-state-disabled,.fc-state-down,.fc-state-hover{color:#333;background-color:#e6e6e6}.fc-state-hover{color:#333;text-decoration:none;background-position:0 -15px;-webkit-transition:background-position .1s linear;-moz-transition:background-position .1s linear;-o-transition:background-position .1s linear;transition:background-position .1s linear}.fc-state-active,.fc-state-down{background-color:#ccc;background-image:none;box-shadow:inset 0 2px 4px rgba(0,0,0,.15),0 1px 2px rgba(0,0,0,.05)}.fc-state-disabled{cursor:default;background-image:none;opacity:.65;filter:alpha(opacity=65);box-shadow:none}.fc-button-group{display:inline-block}.fc .fc-button-group>*{float:left;margin:0 0 0 -1px}.fc .fc-button-group>:first-child{margin-left:0}.fc-popover{position:absolute;box-shadow:0 2px 6px rgba(0,0,0,.15)}.fc-popover .fc-header{padding:2px 4px}.fc-popover .fc-header .fc-title{margin:0 2px}.fc-popover .fc-header .fc-close{cursor:pointer}.fc-ltr .fc-popover .fc-header .fc-title,.fc-rtl .fc-popover .fc-header .fc-close{float:left}.fc-ltr .fc-popover .fc-header .fc-close,.fc-rtl .fc-popover .fc-header .fc-title{float:right}.fc-unthemed .fc-popover{border-width:1px;border-style:solid}.fc-unthemed .fc-popover .fc-header .fc-close{font-size:.9em;margin-top:2px}.fc-popover>.ui-widget-header+.ui-widget-content{border-top:0}.fc-divider{border-style:solid;border-width:1px}hr.fc-divider{height:0;margin:0;padding:0 0 2px;border-width:1px 0}.fc-clear{clear:both}.fc-bg,.fc-bgevent-skeleton,.fc-helper-skeleton,.fc-highlight-skeleton{position:absolute;top:0;left:0;right:0}.fc-bg{bottom:0}.fc-bg table{height:100%}.fc table{width:100%;table-layout:fixed;border-collapse:collapse;border-spacing:0;font-size:1em}.fc th{text-align:center}.fc td,.fc th{border-style:solid;border-width:1px;padding:0;vertical-align:top}.fc td.fc-today{border-style:double}.fc .fc-row{border-style:solid;border-width:0}.fc-row table{border-left:0 hidden transparent;border-right:0 hidden transparent;border-bottom:0 hidden transparent}.fc-row:first-child table{border-top:0 hidden transparent}.fc-row{position:relative}.fc-row .fc-bg{z-index:1}.fc-row .fc-bgevent-skeleton,.fc-row .fc-highlight-skeleton{bottom:0}.fc-row .fc-bgevent-skeleton table,.fc-row .fc-highlight-skeleton table{height:100%}.fc-row .fc-bgevent-skeleton td,.fc-row .fc-highlight-skeleton td{border-color:transparent}.fc-row .fc-bgevent-skeleton{z-index:2}.fc-row .fc-highlight-skeleton{z-index:3}.fc-row .fc-content-skeleton{position:relative;z-index:4;padding-bottom:2px}.fc-row .fc-helper-skeleton{z-index:5}.fc-row .fc-content-skeleton td,.fc-row .fc-helper-skeleton td{background:0 0;border-color:transparent;border-bottom:0}.fc-row .fc-content-skeleton tbody td,.fc-row .fc-helper-skeleton tbody td{border-top:0}.fc-scroller{overflow-y:scroll;overflow-x:hidden}.fc-scroller>*{position:relative;width:100%;overflow:hidden}.fc-event{position:relative;display:block;font-size:.85em;line-height:1.3;border-radius:3px;border:1px solid #3a87ad;background-color:#3a87ad;font-weight:400}.fc-event,.fc-event:hover,.ui-widget .fc-event{color:#fff;text-decoration:none}.fc-event.fc-draggable,.fc-event[href]{cursor:pointer}.fc-not-allowed,.fc-not-allowed .fc-event{cursor:not-allowed}.fc-event .fc-bg{z-index:1;background:#fff;opacity:.25;filter:alpha(opacity=25)}.fc-event .fc-content{position:relative;z-index:2}.fc-event .fc-resizer{position:absolute;z-index:3}.fc-ltr .fc-h-event.fc-not-start,.fc-rtl .fc-h-event.fc-not-end{margin-left:0;border-left-width:0;padding-left:1px;border-top-left-radius:0;border-bottom-left-radius:0}.fc-ltr .fc-h-event.fc-not-end,.fc-rtl .fc-h-event.fc-not-start{margin-right:0;border-right-width:0;padding-right:1px;border-top-right-radius:0;border-bottom-right-radius:0}.fc-h-event .fc-resizer{top:-1px;bottom:-1px;left:-1px;right:-1px;width:5px}.fc-ltr .fc-h-event .fc-start-resizer,.fc-ltr .fc-h-event .fc-start-resizer:after,.fc-ltr .fc-h-event .fc-start-resizer:before,.fc-rtl .fc-h-event .fc-end-resizer,.fc-rtl .fc-h-event .fc-end-resizer:after,.fc-rtl .fc-h-event .fc-end-resizer:before{right:auto;cursor:w-resize}.fc-ltr .fc-h-event .fc-end-resizer,.fc-ltr .fc-h-event .fc-end-resizer:after,.fc-ltr .fc-h-event .fc-end-resizer:before,.fc-rtl .fc-h-event .fc-start-resizer,.fc-rtl .fc-h-event .fc-start-resizer:after,.fc-rtl .fc-h-event .fc-start-resizer:before{left:auto;cursor:e-resize}.fc-day-grid-event{margin:1px 2px 0;padding:0 1px}.fc-day-grid-event .fc-content{white-space:nowrap;overflow:hidden}.fc-day-grid-event .fc-time{font-weight:700}.fc-day-grid-event .fc-resizer{left:-3px;right:-3px;width:7px}a.fc-more{margin:1px 3px;font-size:.85em;cursor:pointer;text-decoration:none}a.fc-more:hover{text-decoration:underline}.fc-limited{display:none}.fc-day-grid .fc-row{z-index:1}.fc-more-popover{z-index:2;width:220px}.fc-more-popover .fc-event-container{padding:10px}.fc-toolbar{text-align:center;margin-bottom:1em}.fc-toolbar .fc-left{float:left}.fc-toolbar .fc-right{float:right}.fc-toolbar .fc-center{display:inline-block}.fc .fc-toolbar>*>*{float:left;margin-left:.75em}.fc .fc-toolbar>*>:first-child{margin-left:0}.fc-toolbar h2{margin:0}.fc-toolbar button{position:relative}.fc-toolbar .fc-state-hover,.fc-toolbar .ui-state-hover{z-index:2}.fc-toolbar .fc-state-down{z-index:3}.fc-toolbar .fc-state-active,.fc-toolbar .ui-state-active{z-index:4}.fc-toolbar button:focus{z-index:5}.fc-view-container *,.fc-view-container :after,.fc-view-container :before{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}.fc-view,.fc-view>table{position:relative;z-index:1}.fc-basicDay-view .fc-content-skeleton,.fc-basicWeek-view .fc-content-skeleton{padding-top:1px;padding-bottom:1em}.fc-basic-view .fc-body .fc-row{min-height:4em}.fc-row.fc-rigid{overflow:hidden}.fc-row.fc-rigid .fc-content-skeleton{position:absolute;top:0;left:0;right:0}.fc-basic-view .fc-day-number,.fc-basic-view .fc-week-number{padding:0 2px}.fc-basic-view td.fc-day-number,.fc-basic-view td.fc-week-number span{padding-top:2px;padding-bottom:2px}.fc-basic-view .fc-week-number{text-align:center}.fc-basic-view .fc-week-number span{display:inline-block;min-width:1.25em}.fc-ltr .fc-basic-view .fc-day-number{text-align:right}.fc-rtl .fc-basic-view .fc-day-number{text-align:left}.fc-day-number.fc-other-month{opacity:.3;filter:alpha(opacity=30)}.fc-agenda-view .fc-day-grid{position:relative;z-index:2}.fc-agenda-view .fc-day-grid .fc-row{min-height:3em}.fc-agenda-view .fc-day-grid .fc-row .fc-content-skeleton{padding-top:1px;padding-bottom:1em}.fc .fc-axis{vertical-align:middle;padding:0 4px;white-space:nowrap}.fc-ltr .fc-axis{text-align:right}.fc-rtl .fc-axis{text-align:left}.ui-widget td.fc-axis{font-weight:400}.fc-time-grid,.fc-time-grid-container{position:relative;z-index:1}.fc-time-grid{min-height:100%}.fc-time-grid table{border:0 hidden transparent}.fc-time-grid>.fc-bg{z-index:1}.fc-time-grid .fc-slats,.fc-time-grid>hr{position:relative;z-index:2}.fc-time-grid .fc-bgevent-skeleton,.fc-time-grid .fc-content-skeleton{position:absolute;top:0;left:0;right:0}.fc-time-grid .fc-bgevent-skeleton{z-index:3}.fc-time-grid .fc-highlight-skeleton{z-index:4}.fc-time-grid .fc-content-skeleton{z-index:5}.fc-time-grid .fc-helper-skeleton{z-index:6}.fc-time-grid .fc-slats td{height:1.5em;border-bottom:0}.fc-time-grid .fc-slats .fc-minor td{border-top-style:dotted}.fc-time-grid .fc-slats .ui-widget-content{background:0 0}.fc-time-grid .fc-highlight-container{position:relative}.fc-time-grid .fc-highlight{position:absolute;left:0;right:0}.fc-time-grid .fc-bgevent-container,.fc-time-grid .fc-event-container{position:relative}.fc-ltr .fc-time-grid .fc-event-container{margin:0 2.5% 0 2px}.fc-rtl .fc-time-grid .fc-event-container{margin:0 2px 0 2.5%}.fc-time-grid .fc-bgevent,.fc-time-grid .fc-event{position:absolute;z-index:1}.fc-time-grid .fc-bgevent{left:0;right:0}.fc-v-event.fc-not-start{border-top-width:0;padding-top:1px;border-top-left-radius:0;border-top-right-radius:0}.fc-v-event.fc-not-end{border-bottom-width:0;padding-bottom:1px;border-bottom-left-radius:0;border-bottom-right-radius:0}.fc-time-grid-event{overflow:hidden}.fc-time-grid-event .fc-time,.fc-time-grid-event .fc-title{padding:0 1px}.fc-time-grid-event .fc-time{font-size:.85em;white-space:nowrap}.fc-time-grid-event.fc-short .fc-content{white-space:nowrap}.fc-time-grid-event.fc-short .fc-time,.fc-time-grid-event.fc-short .fc-title{display:inline-block;vertical-align:top}.fc-time-grid-event.fc-short .fc-time span{display:none}.fc-time-grid-event.fc-short .fc-time:before{content:attr(data-start)}.fc-time-grid-event.fc-short .fc-time:after{content:\"\\000A0-\\000A0\"}.fc-time-grid-event.fc-short .fc-title{font-size:.85em;padding:0}.fc-time-grid-event .fc-resizer{left:0;right:0;bottom:0;height:8px;overflow:hidden;line-height:8px;font-size:11px;font-family:monospace;text-align:center;cursor:s-resize}.fc-time-grid-event .fc-resizer:after{content:\"=\"}.CalendarPanel{height:100%}.CalendarPanel .title-caret{padding:5px}.CalendarPanel .calendar-header{background-color:#D25858;color:#fff;border-right:1px solid #B02727}.CalendarPanel .calendar-header i:hover{color:#B02727}.CalendarPanel .calendar-header .selected-view{color:#B02727}.CalendarPanel .calendar-title{text-align:center;min-width:200px}.CalendarPanel .view-options{padding-right:20px}.CalendarPanel .view-options .fa-align-justify{transform:rotate(90deg);-ms-transform:rotate(90deg);-webkit-transform:rotate(90deg)}.CalendarPanel #calendar table{margin-bottom:0}.CalendarPanel thead{border-color:#F1F1F1}.CalendarPanel th{font-weight:inherit}.CalendarPanel .fc-unthemed .fc-divider,.fc-unthemed .fc-popover,.fc-unthemed .fc-row,.fc-unthemed tbody,.fc-unthemed td,.fc-unthemed th,.fc-unthemed thead{border-color:#F1F1F1}.CalendarPanel .fc-today{background-color:#FFF3F2}.CalendarPanel .fc-month-view .fc-title-today{color:inherit;font-weight:inherit}.CalendarPanel .fc-agendaDay-view .fc-today{background-color:transparent}.CalendarPanel .fc-title-today{color:#D25858;font-weight:400}.CalendarPanel .fc-unthemed .fc-divider,.fc-unthemed .fc-popover .fc-header{background-color:#F1F1F1}.EventsPanel{position:relative;background-color:#F1F1F1;height:100%}.EventsPanel .panel-title{position:absolute;right:110px;left:16px}.EventsPanel .action-bar{width:90px;text-align:right;cursor:default}.EventsPanel .panel-title .title-text{max-width:50%}.EventsPanel .action-container{display:inline-block;min-width:26px;text-align:center}.EventsPanel .action-bar-button{color:#fff;cursor:pointer;-webkit-transition:.3s;-moz-transition:.3s;-ms-transition:.3s;-o-transition:.3s;transition:.3s}.EventsPanel .action-bar-button:hover{color:#B02727}.EventsPanel input.action-bar-search{height:100%;background-color:transparent;border-color:#fff;margin:0 0 0 10px;padding:0;font-weight:100;font-size:16px;vertical-align:middle;line-height:32px}.action-bar-search::-webkit-input-placeholder{color:#fff!important;opacity:.7}.action-bar-search:-moz-placeholder{color:#fff!important;opacity:.7}.action-bar-search::-moz-placeholder{color:#fff!important;opacity:.7}.action-bar-search:-ms-input-placeholder{color:#fff!important;opacity:.7}.EventsPanel .event-item{font-size:16px;cursor:pointer;border-color:#F1F1F1;background-color:#fff}.EventsPanel .event-button{display:none}.EventsPanel .event-item:hover .event-button{display:block}.EventsPanel .event-item:hover{background-color:#FFF3F2}.EventsPanel .list-body ul li .event-item.selected{background-color:#FFF3F2;font-weight:700}.EventsPanel .edit-button,.EventsPanel .info-button{font-size:16px;color:#D25858;cursor:pointer;border-radius:16px;line-height:20px;margin-top:3px}.EventsPanel .edit-button:hover,.EventsPanel .info-button:hover{color:#fff;background-color:#D25858}.EventsPanel .edit-button{margin-right:5px;padding:0 2px;font-size:14px}.InsertEventPanel{background-color:#fff;min-height:100%}.InsertEventPanel .main-form{padding:8px 16px;margin-bottom:0}.ResourcesPanel{position:relative;background-color:#F1F1F1;height:100%}.ResourcesPanel .panel-title{position:absolute;right:110px;left:16px}.ResourcesPanel .action-bar{width:90px;text-align:right;cursor:default}.ResourcesPanel .panel-title .title-text{max-width:50%}.ResourcesPanel .action-container{display:inline-block;min-width:26px;text-align:center}.ResourcesPanel .action-bar-button{color:#fff;cursor:pointer;-webkit-transition:.3s;-moz-transition:.3s;-ms-transition:.3s;-o-transition:.3s;transition:.3s}.ResourcesPanel .action-bar-button:hover{color:#B02727}.ResourcesPanel input.action-bar-search{height:100%;background-color:transparent;border-color:#fff;margin:0 0 0 10px;padding:0;font-weight:100;font-size:16px;vertical-align:middle;line-height:32px}.action-bar-search::-webkit-input-placeholder{color:#fff!important;opacity:.7}.action-bar-search:-moz-placeholder{color:#fff!important;opacity:.7}.action-bar-search::-moz-placeholder{color:#fff!important;opacity:.7}.action-bar-search:-ms-input-placeholder{color:#fff!important;opacity:.7}.ResourcesPanel .resource-item{font-size:16px;cursor:pointer;border-color:#F1F1F1;background-color:#fff}.ResourcesPanel .resource-button{display:none}.ResourcesPanel .resource-item:hover .resource-button{display:block}.ResourcesPanel .resource-item:hover{background-color:#FFF3F2}.ResourcesPanel .list-body ul li .resource-item.selected{background-color:#FFF3F2;font-weight:700}.ResourcesPanel .edit-button,.ResourcesPanel .info-button{font-size:16px;color:#D25858;cursor:pointer;border-radius:16px;line-height:20px;margin-top:3px}.ResourcesPanel .edit-button:hover,.ResourcesPanel .info-button:hover{color:#fff;background-color:#D25858}.ResourcesPanel .edit-button{margin-right:5px;padding:0 2px;font-size:14px}.InsertResourcePanel{background-color:#fff;min-height:100%}.InsertResourcePanel .main-form{padding:8px 16px;margin-bottom:0}.LoginPanel{width:100%;min-height:100%;padding-bottom:30px;box-sizing:border-box;background:#F1F1F1}.LoginPanel .login-form{width:300px;margin:auto}.LoginPanel .login-header{width:100%;padding:15px;box-sizing:border-box;background:#D25858;font-weight:100;color:#fff}.LoginPanel .form-fields{padding:15px;box-sizing:border-box;background:#fff}.LoginPanel .form-fields #login{margin-top:20px}.LoginPanel .error-container{width:80%;margin:auto;margin-top:30px;padding:15px;box-sizing:border-box;background-color:#E8ABAB;border:1px solid #D25858;color:#B02727}");
})
(function(factory) {
  factory();
});
//# sourceMappingURL=app.js.map